/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n// Imports\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%23999%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e */ \"data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%23999%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e\"), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `\n* {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  outline: none;\n}\n\n/* Alternatively, target specific elements */\nbutton:focus, a:focus, input:focus, select:focus, textarea:focus {\n  outline: none;\n}\n\nhtml, body {\n  margin: 0;\n  padding: 0;\n  background: #000;\n  color: #fff;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n  overflow-x: hidden;\n  height: 100%;\n}\n\n/* Header */\n.header {\n  position: sticky;\n  top: 0;\n  z-index: 100;\n  background: #000;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 8px;\n  gap: 8px;\n  height: 64px;\n}\n\n.search-input {\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  margin-left: 10px;\n  background: transparent;\n  border: 1px solid #2d2d2d;\n  color: #555;\n  padding: 8px 16px;\n  font-size: 12px;\n  border-radius: 35px;\n  outline: none;\n  width: 100%;\n}\n\n.search-input:focus {\n  color: #888;\n  border-color: #333;\n}\n\n.zoom-controls {\n  display: flex;\n  gap: 4px;\n}\n\n.zoom-btn {\n  background: transparent;\n  border: none;\n  color: #666666;\n  width: 28px;\n  height: 28px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 14px;\n  cursor: pointer;\n  user-select: none;\n  transition: color 0.2s;\n}\n\n.zoom-btn:hover {\n  color: #fff;\n}\n\n.category-pills-container {\n  display: flex !important;\n  flex-wrap: nowrap !important; /* Prevent wrapping to new lines */\n  overflow-x: auto !important; /* Enable horizontal scrolling */\n  padding: 16px !important;\n  gap: 8px !important;\n  justify-content: flex-start !important; /* Start from left */\n  scrollbar-width: none; /* Hide scrollbar for Firefox */\n  -ms-overflow-style: none; /* Hide scrollbar for IE and Edge */\n}\n\n/* Hide scrollbar for Chrome, Safari and Opera */\n.category-pills-container::-webkit-scrollbar {\n  display: none;\n}\n\n/* Ensure consistent size for category pills to fit properly */\n.category-pill {\n  flex: 0 0 auto !important; /* Don't allow pills to grow or shrink */\n  white-space: nowrap !important; /* Prevent text wrapping */\n}\n\n/* Add these to your styles.css */\n.grid {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr); /* Default, changed by JS */\n  gap: 20px !important; /* Increase gap between grid items */\n  padding: 20px !important;\n}\n\n.shape-container {\n  aspect-ratio: 1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  overflow: hidden;\n  background: #000;\n  transition: background 0.2s ease;\n}\n\n.shape-container.highlight {\n  background: #222;\n  animation: pulse 1s ease-out;\n}\n\n@keyframes pulse {\n  0% { background: #333; }\n  100% { background: #111; }\n}\n\n/* SVG styling */\nsvg {\n  display: block;\n  width: 100%;\n  height: 100%;\n}\n\n.shape-container.error {\n  opacity: 0.3;\n}\n\n/* Editor styling */\n.editor {\n  height: calc(100vh - 42px);\n  padding: 0;\n  transition: opacity 0.3s ease-in-out;\n}\n\n.control-button:hover {\n  background-color: #282828;\n}\n\n.transition-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: black;\n  opacity: 0.5;\n  z-index: 1000;\n  pointer-events: none;\n  transition: opacity 0.3s ease;\n}\n\nbody.prevent-scroll {\n  overflow: hidden;\n}\n\n/* Model Export */\n\n/* Export modal styles */\n.modal {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.7);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n  backdrop-filter: blur(3px);\n}\n\n.modal-content {\n  background-color: #1A1A1A;\n  border-radius: 8px;\n  padding: 24px;\n  width: 400px;\n  max-width: 90%;\n  color: #e0e0e0;\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 16px;\n  padding-bottom: 12px;\n  border-bottom: 1px solid #333;\n}\n\n.modal-header h3 {\n  margin: 0;\n  font-size: 16px;\n  font-weight: normal;\n  color: #e0e0e0;\n}\n\n.close-button {\n  background-color: transparent;\n  border: none;\n  cursor: pointer;\n  padding: 4px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  opacity: 0.7;\n  transition: opacity 0.2s;\n}\n\n.close-button:hover {\n  opacity: 1;\n}\n\n.form-group {\n  margin-bottom: 16px;\n}\n\n.form-group label {\n  display: block;\n  margin-bottom: 8px;\n  font-size: 12px;\n  color: #999;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.form-group select {\n  width: 100%;\n  background-color: #000;\n  color: #e0e0e0;\n  border: 1px solid #333;\n  border-radius: 4px;\n  padding: 8px;\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  font-size: 12px;\n  appearance: none;\n  background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});\n  background-repeat: no-repeat;\n  background-position: right 8px center;\n  background-size: 16px;\n  transition: border-color 0.2s;\n}\n\n.form-group select:focus {\n  outline: none;\n  border-color: #444;\n}\n\n.form-group select option {\n  background-color: #000;\n  color: #e0e0e0;\n}\n\n.form-group select option:disabled {\n  color: #666;\n}\n\nbutton[type=\"submit\"] {\n  background-color: #333;\n  color: #e0e0e0;\n  border: none;\n  border-radius: 30px;\n  padding: 8px 16px;\n  cursor: pointer;\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  font-size: 12px;\n  min-width: 100px;\n  transition: background-color 0.2s;\n}\n\nbutton[type=\"submit\"]:hover {\n  background-color: #444;\n}\n\n/* Animation for modal appearance */\n@keyframes fadeIn {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n\n.modal {\n  animation: fadeIn 0.2s ease-out;\n}\n\n/* Make highlight more visible */\n.shape-container.highlight {\n  background: #333;\n  box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);\n  z-index: 10;\n  position: relative;\n}\n\n.editor-layout {\n  display: grid;\n  grid-template-columns: 3fr 1fr;\n  grid-template-rows: auto 1fr;\n  grid-template-areas:\n    \"nav nav\"\n    \"preview params\";\n  height: 100%;\n}\n\n.editor-layout {\n  overflow: hidden;\n}\n\n#grid.editor {\n  height: 100vh; /* Already in your CSS */\n  overflow: hidden;\n}\n\n.nav-bar {\n  grid-area: nav;\n  background: #000;\n  display: flex;\n  align-items: center;\n  height: 32px;\n}\n\n.back-btn {\n  background: transparent;\n  width: 16px;\n  height: 16px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 14px;\n  cursor: pointer;\n  transition: color 0.2s;\n}\n\n.back-btn:hover {\n  color: white;\n}\n\n.preview-area {\n  grid-area: preview;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background: #000;\n}\n\n.params-area {\n  grid-area: params;\n  background: #000;\n  padding: 15px 12px;\n  overflow-y: auto;\n  display: flex;\n  flex-direction: column;\n  gap: 25px;\n}\n\n.param-container {\n  margin-bottom: 12px;\n  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;\n  color: #e0e0e0;\n}\n\n.param-label {\n  display: inline-block;\n  margin-bottom: 12px;\n  font-size: 12px;\n  letter-spacing: 0.5px;\n  color: #555;\n}\n\n.param-value {\n  color: #555;\n  font-size: 12px;\n  font-variant-numeric: tabular-nums;\n  text-align: left;\n  padding-right: 12px;\n}\n\n.param-slider {\n  width: 100%;\n}\n\n.param-slider::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  width: 12px;\n  height: 12px;\n  border-radius: 6px;\n  background: #555;\n  cursor: pointer;\n}\n\n.param-slider::-webkit-slider-thumb:hover {\n  background: #777;\n}\n\n.param-slider::-moz-range-thumb {\n  width: 12px;\n  height: 12px;\n  border-radius: 6px;\n  background: #555;\n  cursor: pointer;\n  border: none;\n}\n\n.param-slider::-moz-range-thumb:hover {\n  background: #777;\n}\n\n/* Bookmark & Back button styling */\n.bookmark-btn,\n.back-btn,\n.icon-button {\n  position: relative;\n  background: transparent;\n  color: #666666;\n  width: 30px;\n  height: 30px;\n  border-radius: 50%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n  transition: color 0.2s;\n}\n\n.bookmark-btn svg path,\n.icon-button svg path,\n.back-btn svg path {\n  transition: stroke 0.2s;\n}\n\n.bookmark-btn:hover,\n.icon-button:hover,\n.back-btn:hover {\n  color: white; /* This will be inherited by stroke if using \\`currentColor\\` */\n}\n\n.bookmark-btn:hover svg path,\n.icon-button:hover svg path,\n.back-btn:hover svg path {\n  stroke: white; /* Ensure the stroke changes */\n}\n\n\n\n/* Favorites overlay styling */\n.favorites-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 1.0);\n  z-index: 1000;\n  display: none;\n  justify-content: center;\n  align-items: center;\n  padding: 24px;\n}\n\n.favorites-content {\n  border-radius: 8px;\n  width: 90%;\n  max-width: 800px;\n  max-height: 80vh;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n.favorites-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 16px 20px;\n}\n\n#favoritesGrid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n  gap: 16px;\n  padding: 20px;\n  overflow-y: auto;\n  max-height: calc(80vh - 70px);\n}\n\n.shape-thumbnail {\n  aspect-ratio: 1;\n  background-color: #1a1a1a;\n  border-radius: 4px;\n  cursor: pointer;\n  position: relative;\n  transition: background-color 0.2s;\n  overflow: hidden;\n}\n\n.shape-thumbnail:hover {\n  background-color: #292929;\n}\n\n.shape-preview {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.remove-favorite {\n  position: absolute;\n  top: 6px;\n  right: 6px;\n  width: 20px;\n  height: 20px;\n  background-color: rgba(0, 0, 0, 0.5);\n  border: none;\n  border-radius: 50%;\n  color: #ccc;\n  font-size: 14px;\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  opacity: 0;\n  transition: opacity 0.2s;\n}\n\n.shape-thumbnail:hover .remove-favorite {\n  opacity: 1;\n}\n\n.empty-favorites {\n  padding: 40px;\n  text-align: center;\n  width: 320px;\n  margin: 0 auto;\n  color: #666;\n  font-size: 14px;\n  grid-column: 1 / -1;\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://generative-shapes/./src/styles.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://generative-shapes/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!url) {\n    return url;\n  }\n  url = String(url.__esModule ? url.default : url);\n\n  // If url is already wrapped in quotes, remove them\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n  if (options.hash) {\n    url += options.hash;\n  }\n\n  // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n  if (/[\"'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n  return url;\n};\n\n//# sourceURL=webpack://generative-shapes/./node_modules/css-loader/dist/runtime/getUrl.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://generative-shapes/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://generative-shapes/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://generative-shapes/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://generative-shapes/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://generative-shapes/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://generative-shapes/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://generative-shapes/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/ShapeEditor.js":
/*!****************************!*\
  !*** ./src/ShapeEditor.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar ShapeEditor = /*#__PURE__*/function () {\n  function ShapeEditor(controller) {\n    _classCallCheck(this, ShapeEditor);\n    this.controller = controller;\n    this.editorOpen = false;\n    this.currentShape = null;\n    this.parameters = {};\n\n    // Animation properties\n    this.isAnimating = false;\n    this.animationState = null;\n    this.animationFrameId = null;\n    this.lastAnimationTime = 0;\n    this.transitionPause = false;\n\n    // Store original parameters for resets\n    this.originalParameters = {};\n\n    // Append some global slider styling (one-time injection)\n    var style = document.createElement('style');\n    style.textContent = \"\\n      /* Slider track */\\n      .param-slider {\\n        -webkit-appearance: none;\\n        appearance: none;\\n        width: 100%;\\n        height: 20px;              /* Overall clickable area height */\\n        background: transparent;   /* Hide the default track */\\n        position: relative;\\n        cursor: pointer;\\n        min-width: 120px;\\n      }\\n\\n      /* Create a 1px track using a pseudo-element */\\n      .param-slider::before {\\n        content: \\\"\\\";\\n        position: absolute;\\n        top: 50%;\\n        left: 0;\\n        right: 0;\\n        height: 1px;\\n        background: #333;\\n        transform: translateY(-50%);\\n      }\\n\\n      .param-slider::-webkit-slider-thumb {\\n        -webkit-appearance: none;\\n        appearance: none;\\n        width: 12px;\\n        height: 12px;\\n        background: #e0e0e0;\\n        border-radius: 50%;\\n        position: relative;\\n        z-index: 1;\\n      }\\n\\n      .param-slider::-moz-range-thumb {\\n        width: 12px;\\n        height: 12px;\\n        background: #e0e0e0;\\n        border: none;\\n        border-radius: 50%;\\n        cursor: pointer;\\n      }\\n\\n      /* Bottom buttons hover states */\\n      .control-button:hover {\\n        background-color: #282828 !important;\\n      }\\n\\n      /* Parameter controls */\\n      .params-area {\\n        display: flex;\\n        flex-wrap: wrap;\\n        margin: 0 auto;\\n        max-width: 795px;\\n        gap: 12px;\\n      }\\n      \\n      .control-row {\\n        flex: 1;\\n        min-width: 245px;\\n      }\\n      \\n      .param-name {\\n      letter-spacing: 1px;\\n        color: #555;\\n        font-size: 10px;\\n        margin-bottom: 6px;\\n        display: block;\\n        text-transform: uppercase;\\n        letter-spacing: 0.5px;\\n      }\\n\\n      .back-btn {\\n        background-color: #000;\\n        color: #666;\\n        border: none;\\n        border-radius: 50%;\\n        width: 30px;\\n        height: 30px;\\n        font-size: 14px;\\n        display: flex;\\n        align-items: center;\\n        justify-content: center;\\n        cursor: pointer;\\n        transition: color 0.2s;\\n    }\\n      .back-btn:hover {\\n        background-color: #000;\\n        color: #fff;\\n    }\\n        \\n    \\n    \";\n    document.head.appendChild(style);\n\n    // Bind methods\n    this.showEditor = this.showEditor.bind(this);\n    this.hideEditor = this.hideEditor.bind(this);\n    this.updateShape = this.updateShape.bind(this);\n    this.createControls = this.createControls.bind(this);\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n    this.toggleAnimation = this.toggleAnimation.bind(this);\n    this.updateAnimation = this.updateAnimation.bind(this);\n    this.interpolateParameters = this.interpolateParameters.bind(this);\n  }\n\n  /**\n   * Set up animation controls for the editor\n   */\n  return _createClass(ShapeEditor, [{\n    key: \"setupAnimationControls\",\n    value: function setupAnimationControls() {\n      // Animation state - structured to match main.js but with enhancements\n      this.animationState = {\n        isAnimating: false,\n        shouldAnimate: false,\n        transitionTime: 1.0,\n        // Slightly faster than before\n        progress: 0,\n        animationType: 'randomAnimation',\n        hovering: false,\n        returningToDefault: false,\n        stopAfterDefault: false,\n        initialParams: _objectSpread({}, this.parameters),\n        currentParams: _objectSpread({}, this.parameters),\n        targetParams: _objectSpread({}, this.parameters),\n        defaultParams: _objectSpread({}, this.parameters),\n        // New properties for improved animation\n        transitionCount: 0,\n        // Track how many transitions we've done\n        animationStartTime: 0,\n        // When did this animation sequence start\n        lastTargetChange: 0 // When did we last change targets\n      };\n\n      // Animation frame ID for cancellation\n      this.animationFrameId = null;\n\n      // Reference to last animation timestamp\n      this.lastAnimationTime = performance.now();\n      this.animationState.animationStartTime = performance.now();\n    }\n\n    /**\n     * Check if a parameter should not be interpolated\n     */\n  }, {\n    key: \"isNonInterpolatedParam\",\n    value: function isNonInterpolatedParam(param) {\n      return param.toLowerCase().includes('radius') || param.toLowerCase().includes('size') || param.toLowerCase().includes('thickness') || param.toLowerCase().includes('rows') || param.toLowerCase().includes('columns') || param.toLowerCase() === 'randomlayout' || param.toLowerCase().includes('count') || param.toLowerCase().includes('segments') || param.toLowerCase().includes('sides');\n    }\n\n    /**\n     * Generate a new target state for animation\n     */\n  }, {\n    key: \"generateRandomTargetState\",\n    value: function generateRandomTargetState() {\n      var _this = this;\n      if (!this.currentShape) return;\n      var shapeName = this.currentShape;\n      var ShapeClass = this.controller.shapes[shapeName];\n      if (!ShapeClass) return;\n\n      // Get parameter definitions\n      var classParameters = ShapeClass.parameters || {};\n      var allParameters = _objectSpread(_objectSpread({}, this.controller.Shape.parameters), classParameters);\n\n      // Save current parameters as initial state for smooth transition\n      Object.keys(this.parameters).forEach(function (param) {\n        _this.animationState.initialParams[param] = _this.parameters[param];\n      });\n\n      // Set new random target values for each parameter\n      Object.entries(allParameters).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          param = _ref2[0],\n          config = _ref2[1];\n        // For options, keep the same to avoid structural changes\n        if (config.options) {\n          _this.animationState.targetParams[param] = _this.parameters[param];\n        }\n        // For numeric parameters with min/max\n        else if (typeof _this.parameters[param] === 'number' && config.min !== undefined && config.max !== undefined) {\n          // Handle structural parameters differently\n          if (_this.isNonInterpolatedParam(param)) {\n            _this.animationState.targetParams[param] = _this.parameters[param];\n          } else {\n            // For continuous parameters, generate random target\n            var min = config.min;\n            var max = config.max;\n            var currentVal = _this.parameters[param];\n\n            // Enhanced transition generation for more visual interest\n\n            // Determine if we should make a large change for visual impact\n            var makeLargeChange = Math.random() < 0.3; // 30% chance of dramatic change\n\n            if (makeLargeChange) {\n              // Make a more dramatic change\n              var targetArea = Math.random() < 0.5 ? 'min' : 'max';\n              if (targetArea === 'min') {\n                // Target the lower 30% of the range\n                var targetPoint = min + (max - min) * (Math.random() * 0.3);\n                _this.animationState.targetParams[param] = targetPoint;\n              } else {\n                // Target the upper 30% of the range\n                var _targetPoint = max - (max - min) * (Math.random() * 0.3);\n                _this.animationState.targetParams[param] = _targetPoint;\n              }\n            } else {\n              // Normal relative change based on current value\n              var direction = Math.random() > 0.5 ? 1 : -1;\n              var percentChange = 0.3 + Math.random() * 0.5; // 30-80% change for more variety\n\n              var targetValue;\n              if (direction > 0) {\n                // Move toward max\n                var roomToGrow = max - currentVal;\n                targetValue = currentVal + roomToGrow * percentChange;\n              } else {\n                // Move toward min\n                var roomToShrink = currentVal - min;\n                targetValue = currentVal - roomToShrink * percentChange;\n              }\n\n              // Ensure we're still within bounds\n              targetValue = Math.max(min, Math.min(max, targetValue));\n              _this.animationState.targetParams[param] = targetValue;\n            }\n          }\n        }\n        // For other parameters, keep the same\n        else {\n          _this.animationState.targetParams[param] = _this.parameters[param];\n        }\n      });\n\n      // Reset progress and set dynamic transition time\n      this.animationState.progress = 0;\n\n      // Vary transition speed for more organic feel\n      this.animationState.transitionTime = 0.5 + Math.random();\n\n      // Set animation type\n      this.animationState.animationType = 'randomAnimation';\n    }\n\n    /**\n     * Start the parameter animation\n     */\n  }, {\n    key: \"startAnimation\",\n    value: function startAnimation() {\n      var _this2 = this;\n      // Already running\n      if (this.isAnimating) return;\n\n      // Set animation flags\n      this.isAnimating = true;\n\n      // Update button appearance\n      var animateBtn = document.getElementById('animateBtn');\n      if (animateBtn) {\n        animateBtn.classList.add('playing');\n        // Replace icon with pause icon\n        var iconSpan = animateBtn.querySelector('span:first-child');\n        if (iconSpan) {\n          iconSpan.innerHTML = this.getPauseIcon();\n        }\n\n        // Update text\n        var textSpan = animateBtn.querySelector('span:last-child');\n        if (textSpan) {\n          textSpan.textContent = 'Pause';\n        }\n      }\n\n      // Initialize animation state if not already set up\n      if (!this.animationState) {\n        this.setupAnimationControls();\n      }\n\n      // Set animation state properties\n      this.animationState.isAnimating = true;\n      this.animationState.shouldAnimate = true;\n\n      // Store current parameters as defaults\n      Object.keys(this.parameters).forEach(function (param) {\n        _this2.animationState.defaultParams[param] = _this2.parameters[param];\n      });\n\n      // Generate first target state with enhanced randomization\n      this.generateRandomTargetState();\n\n      // Start the animation loop\n      this.lastAnimationTime = performance.now();\n      this.updateAnimation();\n    }\n\n    /**\n     * Animation loop - updates shape parameters over time\n     */\n  }, {\n    key: \"updateAnimation\",\n    value: function updateAnimation() {\n      var _this3 = this;\n      if (!this.isAnimating) return;\n\n      // Calculate delta time\n      var now = performance.now();\n      var deltaTime = (now - this.lastAnimationTime) / 1000; // Convert to seconds\n      this.lastAnimationTime = now;\n\n      // Update animation progress\n      this.animationState.progress += deltaTime / this.animationState.transitionTime;\n\n      // If we've reached the target state, generate a new one\n      if (this.animationState.progress >= 1.0) {\n        // Set current parameters to match target immediately\n        Object.keys(this.animationState.targetParams).forEach(function (param) {\n          _this3.parameters[param] = _this3.animationState.targetParams[param];\n        });\n\n        // Create a shorter, more natural transition pause\n        if (!this.transitionPause) {\n          this.transitionPause = true;\n\n          // Update shape immediately before pause\n          this.updateShape();\n\n          // Quick and subtle pause between transitions for rhythm\n          setTimeout(function () {\n            // Reset progress and generate new target\n            _this3.animationState.progress = 0;\n            _this3.generateRandomTargetState();\n            _this3.transitionPause = false;\n          }, 150); // Shorter pause (was 250ms)\n        }\n      } else {\n        // Only interpolate if we're not in a pause\n        if (!this.transitionPause) {\n          // Interpolate parameters using improved easing\n          this.interpolateParameters();\n\n          // Update the shape with new parameters\n          this.updateShape();\n\n          // Update controls strategically for better performance\n          // Only update UI about 10% of frames, more often during slower parts\n          var updateProbability = this.animationState.progress < 0.2 || this.animationState.progress > 0.8 ? 0.15 : 0.05;\n          if (Math.random() < updateProbability) {\n            this.updateParameterControls();\n          }\n        }\n      }\n\n      // Continue animation loop\n      this.animationFrameId = requestAnimationFrame(this.updateAnimation.bind(this));\n    }\n\n    /**\n     * Linear interpolation function - same as in main.js\n     */\n  }, {\n    key: \"lerp\",\n    value: function lerp(a, b, t) {\n      return a + (b - a) * t;\n    }\n\n    /**\n     * Apply easing function like in main.js\n     */\n  }, {\n    key: \"smoothStep\",\n    value: function smoothStep(t) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n      // Clamp t to 0...1 range\n      t = Math.min(Math.max(t, 0), 1);\n\n      // Enhanced easing function selection based on animation type\n      switch (type) {\n        case 'hoverIn':\n          // Quick start, gentle finish\n          return 1 - Math.pow(1 - t, 3);\n        case 'hoverOut':\n          // More linear for predictable return\n          return easingFunctions.easeInOutQuad(t);\n        case 'randomAnimation':\n          // Smoother flow with slight acceleration at start and end\n          if (t < 0.5) {\n            // Accelerate into the animation (slower start)\n            return 2 * t * t;\n          } else {\n            // Decelerate out of the animation (slower finish)\n            return -1 + (4 - 2 * t) * t;\n          }\n        default:\n          // Improved default with slight acceleration\n          return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n      }\n    }\n\n    /**\n     * Interpolate between initial and target parameters based on progress\n     */\n  }, {\n    key: \"interpolateParameters\",\n    value: function interpolateParameters() {\n      var _this4 = this;\n      var progress = this.animationState.progress;\n      var initial = this.animationState.initialParams;\n      var target = this.animationState.targetParams;\n\n      // Apply easing function to progress - match main.js\n      var t = this.smoothStep(progress, this.animationState.animationType);\n\n      // Interpolate each parameter\n      Object.keys(initial).forEach(function (param) {\n        // Skip if parameter doesn't exist in target\n        if (target[param] === undefined) return;\n\n        // For numeric parameters, interpolate\n        if (typeof initial[param] === 'number' && typeof target[param] === 'number') {\n          if (_this4.isNonInterpolatedParam(param)) {\n            // For structural parameters, keep integer values\n            if (param.toLowerCase().includes('rows') || param.toLowerCase().includes('columns') || param.toLowerCase().includes('count')) {\n              _this4.parameters[param] = Math.round(initial[param]);\n            } else {\n              _this4.parameters[param] = initial[param];\n            }\n          } else {\n            // For floating point parameters, interpolate normally with easing\n            if (param.toLowerCase().includes('rows') || param.toLowerCase().includes('columns') || param.toLowerCase().includes('count') || param.toLowerCase().includes('sides') || param.toLowerCase().includes('segments')) {\n              // Integer parameters\n              _this4.parameters[param] = Math.round(_this4.lerp(initial[param], target[param], t));\n            } else {\n              // Float parameters\n              _this4.parameters[param] = _this4.lerp(initial[param], target[param], t);\n            }\n          }\n        }\n        // For other types, maintain the initial value\n        else {\n          _this4.parameters[param] = initial[param];\n        }\n      });\n    }\n\n    /**\n     * Stop the parameter animation\n     */\n  }, {\n    key: \"stopAnimation\",\n    value: function stopAnimation() {\n      // Not running\n      if (!this.isAnimating) return;\n      this.isAnimating = false;\n\n      // Cancel any pending animation frame\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n        this.animationFrameId = null;\n      }\n\n      // Reset the animation state\n      if (this.animationState) {\n        this.animationState.isAnimating = false;\n        this.animationState.shouldAnimate = false;\n      }\n\n      // Update button appearance with transition\n      var animateBtn = document.getElementById('animateBtn');\n      if (animateBtn) {\n        animateBtn.classList.remove('playing');\n        // Replace icon with play icon\n        var iconSpan = animateBtn.querySelector('span:first-child');\n        if (iconSpan) {\n          iconSpan.innerHTML = this.getPlayIcon();\n        }\n\n        // Update text\n        var textSpan = animateBtn.querySelector('span:last-child');\n        if (textSpan) {\n          textSpan.textContent = 'Play';\n        }\n\n        // Add subtle transition effect\n        animateBtn.style.transition = 'all 0.2s ease';\n        setTimeout(function () {\n          animateBtn.style.transition = '';\n        }, 200);\n      }\n\n      // Reset transition pause flag\n      this.transitionPause = false;\n\n      // Update controls to reflect current parameters\n      this.updateParameterControls();\n    }\n\n    /**\n     * Toggle animation on/off\n     */\n  }, {\n    key: \"toggleAnimation\",\n    value: function toggleAnimation() {\n      var animateBtn = document.getElementById('animateBtn');\n      if (this.isAnimating) {\n        // Add quick visual feedback\n        if (animateBtn) {\n          animateBtn.style.transform = 'scale(0.95)';\n          setTimeout(function () {\n            animateBtn.style.transform = 'scale(1)';\n          }, 100);\n        }\n        this.stopAnimation();\n      } else {\n        // Add quick visual feedback\n        if (animateBtn) {\n          animateBtn.style.transform = 'scale(1.05)';\n          setTimeout(function () {\n            animateBtn.style.transform = 'scale(1)';\n          }, 100);\n        }\n        if (!this.animationState) {\n          this.setupAnimationControls();\n        }\n        this.startAnimation();\n      }\n    }\n\n    /**\n     * Play icon SVG\n     */\n  }, {\n    key: \"getPlayIcon\",\n    value: function getPlayIcon() {\n      return \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"currentColor\\\">\\n      <path d=\\\"M8 5v14l11-7z\\\"/>\\n    </svg>\";\n    }\n\n    /**\n     * Pause icon SVG\n     */\n  }, {\n    key: \"getPauseIcon\",\n    value: function getPauseIcon() {\n      return \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"currentColor\\\">\\n      <path d=\\\"M6 19h4V5H6v14zm8-14v14h4V5h-4z\\\"/>\\n    </svg>\";\n    }\n\n    /**\n     * Clean up on editor close\n     */\n  }, {\n    key: \"cleanupAnimation\",\n    value: function cleanupAnimation() {\n      if (this.isAnimating) {\n        this.stopAnimation();\n      }\n      this.isAnimating = false;\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n        this.animationFrameId = null;\n      }\n\n      // Reset animation state\n      this.animationState = null;\n    }\n\n    /**\n    * Show the shape editor for a specific shape\n    * @param {string} shapeName - The name of the shape to edit\n    * @param {object} initialParams - Optional initial parameters (from hover state)\n    */\n  }, {\n    key: \"showEditor\",\n    value: function showEditor(shapeName) {\n      var _this5 = this;\n      var initialParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      console.log(shapeName);\n      if (!shapeName) return;\n      this.editorOpen = true;\n      this.currentShape = shapeName;\n\n      // Save the current grid state before showing the editor\n      this.controller.saveGridState();\n      var gridContainer = document.getElementById('grid');\n      if (!gridContainer) return;\n\n      // Hide main header (search and zoom controls)\n      var header = document.getElementById('main-header');\n      if (header) header.style.display = 'none';\n\n      // Hide category filters when in editor mode\n      var filterContainer = document.getElementById('category-filters-container');\n      if (filterContainer) {\n        // Store the parent before removing\n        this.filterContainerParent = filterContainer.parentNode;\n        // Save the reference for later restoration\n        this.savedFilterContainer = filterContainer;\n        // Remove from DOM completely\n        filterContainer.parentNode.removeChild(filterContainer);\n      }\n\n      // Clear grid and set class\n      gridContainer.innerHTML = '';\n      gridContainer.className = 'editor';\n      try {\n        // Create editor layout with dark theme\n        var editorLayout = document.createElement('div');\n        editorLayout.className = 'editor-layout';\n        editorLayout.style.backgroundColor = '#000';\n        editorLayout.style.color = '#e0e0e0';\n        editorLayout.style.height = '100vh';\n        editorLayout.style.display = 'flex';\n        editorLayout.style.flexDirection = 'column';\n\n        // Create navigation bar (top)\n        var navBar = document.createElement('div');\n        navBar.className = 'nav-bar';\n        navBar.style.gridArea = 'nav';\n        navBar.style.display = 'flex';\n        navBar.style.alignItems = 'center';\n        var backButton = document.createElement('button');\n        backButton.className = 'back-btn';\n        backButton.title = 'Back to shapes';\n        backButton.style.backgroundColor = 'transparent';\n        backButton.addEventListener('click', this.hideEditor);\n        backButton.style.alignItems = 'center';\n        backButton.style.justifyContent = 'center';\n        backButton.style.width = '30px';\n        backButton.style.height = '30px';\n        backButton.style.fontSize = '14px';\n        backButton.innerHTML = \"\\n<svg width=\\\"30\\\" height=\\\"30\\\" viewBox=\\\"0 0 30 30\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n<path d=\\\"M9 10L20 21\\\" stroke=\\\"#666666\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n<path d=\\\"M20 10L9 21\\\" stroke=\\\"#666666\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n</svg>\\n    \";\n        navBar.appendChild(backButton);\n\n        // Add bookmark button to navigation bar\n        var bookmarkBtn = document.createElement('button');\n        bookmarkBtn.className = 'bookmark-btn'; // Use class instead of ID to avoid conflicts\n        bookmarkBtn.title = 'Saved Shapes';\n        bookmarkBtn.innerHTML = \"\\n      <svg width=\\\"30\\\" height=\\\"30\\\" viewBox=\\\"0 0 30 30\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n<path d=\\\"M10 10V22.7586C10 22.8477 10.1077 22.8923 10.1707 22.8293L14.9293 18.0707C14.9683 18.0317 15.0317 18.0317 15.0707 18.0707L19.8293 22.8293C19.8923 22.8923 20 22.8477 20 22.7586V10C20 9.44772 19.5523 9 19 9H11C10.4477 9 10 9.44772 10 10Z\\\" stroke=\\\"#666666\\\" stroke-width=\\\"1.5\\\"/>\\n</svg>\\n    \";\n        bookmarkBtn.style.backgroundColor = 'transparent';\n        bookmarkBtn.style.color = '#666';\n        bookmarkBtn.style.border = 'none';\n        bookmarkBtn.style.fontSize = '14px';\n        bookmarkBtn.style.cursor = 'pointer';\n        bookmarkBtn.style.marginLeft = 'auto';\n        bookmarkBtn.style.position = 'relative';\n        bookmarkBtn.style.display = 'flex';\n        bookmarkBtn.style.alignItems = 'center';\n        bookmarkBtn.style.justifyContent = 'center';\n        bookmarkBtn.style.width = '30px';\n        bookmarkBtn.style.height = '30px';\n        navBar.appendChild(bookmarkBtn);\n\n        // Reinitialize favorites bookmark button handlers\n        if (this.controller.favorites) {\n          setTimeout(function () {\n            return _this5.controller.favorites.setupBookmarkButtons();\n          }, 100);\n        }\n\n        // Create preview area (full width, takes available space)\n        var previewArea = document.createElement('div');\n        previewArea.className = 'preview-area';\n        previewArea.style.display = 'flex';\n        previewArea.style.justifyContent = 'center';\n        previewArea.style.alignItems = 'center';\n        previewArea.style.flex = '1';\n        previewArea.style.paddingBottom = '32px';\n        previewArea.style.backgroundColor = '#000'; // Darker background for contrast\n        previewArea.style.overflow = 'hidden';\n        previewArea.style.position = 'relative'; // For animation indicator\n\n        // Create parameters area (bottom, above buttons)\n        var paramsArea = document.createElement('div');\n        paramsArea.className = 'params-area';\n\n        // Create parameters container\n        var parametersContainer = document.createElement('div');\n        parametersContainer.id = 'parameters';\n        parametersContainer.style.display = 'flex';\n        parametersContainer.style.flexWrap = 'wrap';\n        parametersContainer.style.gap = '16px';\n        parametersContainer.style.width = '100%';\n        paramsArea.appendChild(parametersContainer);\n\n        // Create controls area (buttons at very bottom)\n        var controlsArea = document.createElement('div');\n        controlsArea.className = 'controls-area';\n        controlsArea.style.padding = '16px';\n        controlsArea.style.paddingBottom = '64px';\n        controlsArea.style.display = 'flex';\n        controlsArea.style.justifyContent = 'center';\n        controlsArea.style.gap = '12px';\n        controlsArea.style.backgroundColor = '#000';\n\n        // Add the control buttons\n        this.createControlButtons(controlsArea);\n\n        // Get shape class and parameters\n        var ShapeClass = this.controller.shapes[shapeName];\n        if (!ShapeClass) throw new Error(\"Shape class not found: \".concat(shapeName));\n        var classParameters = ShapeClass.parameters || {};\n        var allParameters = _objectSpread(_objectSpread({}, this.controller.Shape.parameters), classParameters);\n\n        // Create shape instance with default parameters\n        var shapeInstance = new ShapeClass();\n        this.parameters = {};\n\n        // Set initial parameters from instance\n        Object.keys(allParameters).forEach(function (param) {\n          _this5.parameters[param] = shapeInstance[param];\n        });\n\n        // If we have initial parameters from hover state, use them\n        if (initialParams && Object.keys(initialParams).length > 0) {\n          console.log('Using provided hover parameters in editor');\n\n          // Merge hover parameters with default parameters (ensuring all required parameters exist)\n          Object.keys(initialParams).forEach(function (param) {\n            if (_this5.parameters.hasOwnProperty(param)) {\n              _this5.parameters[param] = initialParams[param];\n            }\n          });\n        }\n\n        // Store original parameters for reset\n        this.originalParameters = _objectSpread({}, this.parameters);\n\n        // Create SVG preview (larger)\n        var previewSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        previewSvg.id = 'preview-svg';\n        previewSvg.setAttribute('width', '100%');\n        previewSvg.setAttribute('height', '100%');\n        previewSvg.setAttribute('viewBox', '-110 -110 220 220');\n        previewSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n\n        // Create wrapper group\n        var wrapperGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        wrapperGroup.id = 'shape';\n        wrapperGroup.setAttribute('transform', 'translate(0,0)');\n        previewSvg.appendChild(wrapperGroup);\n\n        // Initial shape rendering\n        this.updateShape();\n\n        // Create parameter controls\n        this.createControls(allParameters, parametersContainer);\n\n        // Add SVG to preview area\n        previewArea.appendChild(previewSvg);\n\n        // Assemble the editor in the new layout order\n        editorLayout.appendChild(navBar);\n        editorLayout.appendChild(previewArea);\n        editorLayout.appendChild(paramsArea);\n        editorLayout.appendChild(controlsArea);\n\n        // Add to grid container\n        gridContainer.appendChild(editorLayout);\n\n        // Add keyboard handler for ESC to go back\n        document.addEventListener('keydown', this.handleKeyDown);\n\n        // Initialize history for the new shape\n        if (this.controller.history) {\n          this.controller.history.initShapeHistory(shapeName);\n\n          // Save initial state if parameters are available\n          if (Object.keys(this.parameters).length > 0) {\n            this.controller.history.saveState();\n          }\n        }\n\n        // Initialize animation state\n        this.setupAnimationControls();\n      } catch (error) {\n        console.error(\"Error showing shape editor for \".concat(shapeName, \":\"), error);\n        this.showErrorView(gridContainer, shapeName);\n      }\n    }\n\n    //   showEditor(shapeName) {\n    //     console.log(shapeName);\n\n    //     if (!shapeName) return;\n\n    //     this.editorOpen = true;\n    //     this.currentShape = shapeName;\n\n    //     // Save the current grid state before showing the editor\n    //     this.controller.saveGridState();\n\n    //     const gridContainer = document.getElementById('grid');\n    //     if (!gridContainer) return;\n\n    //     // Hide main header (search and zoom controls)\n    //     const header = document.getElementById('main-header');\n    //     if (header) header.style.display = 'none';\n\n    //     // Hide category filters when in editor mode\n    //     const filterContainer = document.getElementById('category-filters-container');\n    //   if (filterContainer) {\n    //     // Store the parent before removing\n    //     this.filterContainerParent = filterContainer.parentNode;\n    //     // Save the reference for later restoration\n    //     this.savedFilterContainer = filterContainer;\n    //     // Remove from DOM completely\n    //     filterContainer.parentNode.removeChild(filterContainer);\n    //   }\n\n    //     // Clear grid and set class\n    //     gridContainer.innerHTML = '';\n    //     gridContainer.className = 'editor';\n\n    //     try {\n    //       // Create editor layout with dark theme\n    //       const editorLayout = document.createElement('div');\n    //       editorLayout.className = 'editor-layout';\n    //       editorLayout.style.backgroundColor = '#000';\n    //       editorLayout.style.color = '#e0e0e0';\n    //       editorLayout.style.height = '100vh';\n    //       editorLayout.style.display = 'flex';\n    //       editorLayout.style.flexDirection = 'column';\n\n    //       // Create navigation bar (top)\n    //       const navBar = document.createElement('div');\n    //       navBar.className = 'nav-bar';\n    //       navBar.style.gridArea = 'nav';\n    //       navBar.style.display = 'flex';\n    //       navBar.style.alignItems = 'center';\n\n    //       const backButton = document.createElement('button');\n    //       backButton.className = 'back-btn';\n    //       backButton.title = 'Back to shapes';\n    //       backButton.style.backgroundColor = 'transparent';\n    //       backButton.addEventListener('click', this.hideEditor);\n    //       backButton.style.alignItems = 'center';\n    //       backButton.style.justifyContent = 'center';\n    //       backButton.style.width = '30px';\n    //       backButton.style.height = '30px';\n    //       backButton.style.fontSize = '14px';\n\n    //       backButton.innerHTML = `\n    // <svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    // <path d=\"M9 10L20 21\" stroke=\"#666666\" stroke-width=\"1.5\" stroke-linecap=\"round\"/>\n    // <path d=\"M20 10L9 21\" stroke=\"#666666\" stroke-width=\"1.5\" stroke-linecap=\"round\"/>\n    // </svg>\n    //       `;\n\n    //       navBar.appendChild(backButton);\n\n    //       // Add bookmark button to navigation bar\n    //       const bookmarkBtn = document.createElement('button');\n    //       bookmarkBtn.className = 'bookmark-btn'; // Use class instead of ID to avoid conflicts\n    //       bookmarkBtn.title = 'Saved Shapes';\n    //       bookmarkBtn.innerHTML = `\n    //         <svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    // <path d=\"M10 10V22.7586C10 22.8477 10.1077 22.8923 10.1707 22.8293L14.9293 18.0707C14.9683 18.0317 15.0317 18.0317 15.0707 18.0707L19.8293 22.8293C19.8923 22.8923 20 22.8477 20 22.7586V10C20 9.44772 19.5523 9 19 9H11C10.4477 9 10 9.44772 10 10Z\" stroke=\"#666666\" stroke-width=\"1.5\"/>\n    // </svg>\n    //       `;\n    //       bookmarkBtn.style.backgroundColor = 'transparent';\n    //       bookmarkBtn.style.color = '#666';\n    //       bookmarkBtn.style.border = 'none';\n    //       bookmarkBtn.style.fontSize = '14px';\n    //       bookmarkBtn.style.cursor = 'pointer';\n    //       bookmarkBtn.style.marginLeft = 'auto';\n    //       bookmarkBtn.style.position = 'relative';\n    //       bookmarkBtn.style.display = 'flex';\n    //       bookmarkBtn.style.alignItems = 'center';\n    //       bookmarkBtn.style.justifyContent = 'center';\n    //       bookmarkBtn.style.width = '30px';\n    //       bookmarkBtn.style.height = '30px';\n\n    //       navBar.appendChild(bookmarkBtn);\n\n    //       // Add at the end of the showEditor method, right after creating the animation state:\n    //       // Reinitialize favorites bookmark button handlers\n    //       if (this.controller.favorites) {\n    //         setTimeout(() => this.controller.favorites.setupBookmarkButtons(), 100);\n    //       }\n\n    //       // Create preview area (full width, takes available space)\n    //       const previewArea = document.createElement('div');\n    //       previewArea.className = 'preview-area';\n    //       previewArea.style.display = 'flex';\n    //       previewArea.style.justifyContent = 'center';\n    //       previewArea.style.alignItems = 'center';\n    //       previewArea.style.flex = '1';\n    //       previewArea.style.paddingBottom = '32px';\n\n    //       previewArea.style.backgroundColor = '#000'; // Darker background for contrast\n    //       previewArea.style.overflow = 'hidden';\n    //       previewArea.style.position = 'relative'; // For animation indicator\n\n    //       // Create parameters area (bottom, above buttons)\n    //       const paramsArea = document.createElement('div');\n    //       paramsArea.className = 'params-area';\n\n    //       // Create parameters container\n    //       const parametersContainer = document.createElement('div');\n    //       parametersContainer.id = 'parameters';\n    //       parametersContainer.style.display = 'flex';\n    //       parametersContainer.style.flexWrap = 'wrap';\n    //       parametersContainer.style.gap = '16px';\n    //       parametersContainer.style.width = '100%';\n    //       paramsArea.appendChild(parametersContainer);\n\n    //       // Create controls area (buttons at very bottom)\n    //       const controlsArea = document.createElement('div');\n    //       controlsArea.className = 'controls-area';\n    //       controlsArea.style.padding = '16px';\n    //       controlsArea.style.paddingBottom = '64px';\n    //       controlsArea.style.display = 'flex';\n    //       controlsArea.style.justifyContent = 'center';\n    //       controlsArea.style.gap = '12px';\n    //       controlsArea.style.backgroundColor = '#000';\n\n    //       // Add the control buttons\n    //       this.createControlButtons(controlsArea);\n\n    //       // Get shape class and parameters\n    //       const ShapeClass = this.controller.shapes[shapeName];\n    //       if (!ShapeClass) throw new Error(`Shape class not found: ${shapeName}`);\n\n    //       const classParameters = ShapeClass.parameters || {};\n    //       const allParameters = { ...this.controller.Shape.parameters, ...classParameters };\n\n    //       // Create shape instance with default parameters\n    //       const shapeInstance = new ShapeClass();\n    //       this.parameters = {};\n\n    //       // Set initial parameters from instance\n    //       Object.keys(allParameters).forEach(param => {\n    //         this.parameters[param] = shapeInstance[param];\n    //       });\n\n    //       // Store original parameters for reset\n    //       this.originalParameters = { ...this.parameters };\n\n    //       // Create SVG preview (larger)\n    //       const previewSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    //       previewSvg.id = 'preview-svg';\n    //       previewSvg.setAttribute('width', '100%');\n    //       previewSvg.setAttribute('height', '100%');\n    //       previewSvg.setAttribute('viewBox', '-110 -110 220 220');\n    //       previewSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n\n    //       // Create wrapper group\n    //       const wrapperGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    //       wrapperGroup.id = 'shape';\n    //       wrapperGroup.setAttribute('transform', 'translate(0,0)');\n    //       previewSvg.appendChild(wrapperGroup);\n\n    //       // Initial shape rendering\n    //       this.updateShape();\n\n    //       // Create parameter controls\n    //       this.createControls(allParameters, parametersContainer);\n\n    //       // Add SVG to preview area\n    //       previewArea.appendChild(previewSvg);\n\n    //       // Assemble the editor in the new layout order\n    //       editorLayout.appendChild(navBar);\n    //       editorLayout.appendChild(previewArea);\n    //       editorLayout.appendChild(paramsArea);\n    //       editorLayout.appendChild(controlsArea);\n\n    //       // Add to grid container\n    //       gridContainer.appendChild(editorLayout);\n\n    //       // Add keyboard handler for ESC to go back\n    //       document.addEventListener('keydown', this.handleKeyDown);\n\n    //       // Initialize history for the new shape\n    //       if (this.controller.history) {\n    //         this.controller.history.initShapeHistory(shapeName);\n\n    //         // Save initial state if parameters are available\n    //         if (Object.keys(this.parameters).length > 0) {\n    //           this.controller.history.saveState();\n    //         }\n    //       }\n\n    //       // Initialize animation state\n    //       this.setupAnimationControls();\n\n    //     } catch (error) {\n    //       console.error(`Error showing shape editor for ${shapeName}:`, error);\n    //       this.showErrorView(gridContainer, shapeName);\n    //     }\n    //   }\n\n    /**\n     * Create the control buttons\n     */\n  }, {\n    key: \"createControlButtons\",\n    value: function createControlButtons(container) {\n      var _this6 = this;\n      var svgIcons = {\n        undo: \"<svg width=\\\"10\\\" height=\\\"10\\\" viewBox=\\\"-2.2 0 10 9\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n<path d=\\\"M3.23077 6.5C2.95463 6.5 2.73077 6.72386 2.73077 7C2.73077 7.27614 2.95463 7.5 3.23077 7.5V6.5ZM2 2.5H4.5V1.5H2V2.5ZM4.5 6.5H3.23077V7.5H4.5V6.5ZM6.5 4.5C6.5 5.60457 5.60457 6.5 4.5 6.5V7.5C6.15685 7.5 7.5 6.15685 7.5 4.5H6.5ZM4.5 2.5C5.60457 2.5 6.5 3.39543 6.5 4.5H7.5C7.5 2.84315 6.15685 1.5 4.5 1.5V2.5Z\\\" fill=\\\"#D9D9D9\\\"/>\\n<path d=\\\"M2.01346 3.58247C2.21007 3.73856 2.5 3.59855 2.5 3.34751V0.620284C2.5 0.369249 2.21007 0.229238 2.01346 0.385331L0.295933 1.74895C0.144652 1.86905 0.144652 2.09874 0.295933 2.21885L2.01346 3.58247Z\\\" fill=\\\"#D9D9D9\\\"/>\\n</svg>\\n\",\n        redo: \"<svg width=\\\"10\\\" height=\\\"10\\\" viewBox=\\\"-2.2 0 10 9\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n<path d=\\\"M4.76923 6.5C5.04537 6.5 5.26923 6.72386 5.26923 7C5.26923 7.27614 5.04537 7.5 4.76923 7.5V6.5ZM6 2.5H3.5V1.5H6V2.5ZM3.5 6.5H4.76923V7.5H3.5V6.5ZM1.5 4.5C1.5 5.60457 2.39543 6.5 3.5 6.5V7.5C1.84315 7.5 0.5 6.15685 0.5 4.5H1.5ZM3.5 2.5C2.39543 2.5 1.5 3.39543 1.5 4.5H0.5C0.5 2.84315 1.84315 1.5 3.5 1.5V2.5Z\\\" fill=\\\"#D9D9D9\\\"/>\\n<path d=\\\"M5.98654 3.58247C5.78993 3.73856 5.5 3.59855 5.5 3.34751V0.620284C5.5 0.369249 5.78993 0.229238 5.98654 0.385331L7.70407 1.74895C7.85535 1.86905 7.85535 2.09874 7.70407 2.21885L5.98654 3.58247Z\\\" fill=\\\"#D9D9D9\\\"/>\\n</svg>\\n\",\n        randomize: \"<svg width=\\\"11\\\" height=\\\"9\\\" viewBox=\\\"0 0 11 9\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n<path d=\\\"M8.48654 8.58247C8.28993 8.73856 8 8.59855 8 8.34751V5.62028C8 5.36925 8.28993 5.22924 8.48654 5.38533L10.2041 6.74895C10.3553 6.86905 10.3553 7.09874 10.2041 7.21885L8.48654 8.58247Z\\\" fill=\\\"#D9D9D9\\\"/>\\n<path d=\\\"M1 1.98438H1.44836C2.26415 1.98438 3.02862 2.3824 3.49644 3.05072L5.50356 5.91803C5.97138 6.58635 6.73585 6.98438 7.55164 6.98438H8\\\" stroke=\\\"#D9D9D9\\\" stroke-linecap=\\\"round\\\"/>\\n<path d=\\\"M8.48654 0.386283C8.28993 0.23019 8 0.370201 8 0.621236V3.34847C8 3.5995 8.28993 3.73951 8.48654 3.58342L10.2041 2.2198C10.3553 2.0997 10.3553 1.87001 10.2041 1.7499L8.48654 0.386283Z\\\" fill=\\\"#D9D9D9\\\"/>\\n<path d=\\\"M1 6.98438H1.44836C2.26415 6.98438 3.02862 6.58635 3.49644 5.91803L5.50356 3.05072C5.97138 2.3824 6.73585 1.98438 7.55164 1.98438H8\\\" stroke=\\\"#D9D9D9\\\" stroke-linecap=\\\"round\\\"/>\\n</svg>\\n\",\n        copy: \"<svg width=\\\"10\\\" height=\\\"9\\\" viewBox=\\\"0 0 10 9\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n<rect x=\\\"1\\\" y=\\\"3\\\" width=\\\"5\\\" height=\\\"5\\\" rx=\\\"1\\\" stroke=\\\"#D9D9D9\\\"/>\\n<path d=\\\"M6 6H8C8.55228 6 9 5.55228 9 5V2C9 1.44772 8.55228 1 8 1H5C4.44772 1 4 1.44772 4 2V3\\\" stroke=\\\"#D9D9D9\\\"/>\\n</svg>\\n\",\n        save: \"<svg width=\\\"8\\\" height=\\\"9\\\" viewBox=\\\"0 0 8 9\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n<path d=\\\"M1 2V7.27068C1 7.358 1.10406 7.40337 1.16804 7.34396L3.43195 5.24176C3.47032 5.20613 3.52968 5.20613 3.56804 5.24176L5.83195 7.34396C5.89594 7.40337 6 7.358 6 7.27068V2C6 1.44772 5.55228 1 5 1H2C1.44772 1 1 1.44772 1 2Z\\\" stroke=\\\"#D9D9D9\\\"/>\\n</svg>\\n\",\n        \"export\": \"<svg width=\\\"8\\\" height=\\\"9\\\" viewBox=\\\"0 0 8 9\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n<path d=\\\"M5.5 2.6L4.24 1.10667C4.12 0.964444 3.88 0.964444 3.76 1.10667L2.5 2.6\\\" stroke=\\\"#D9D9D9\\\" stroke-linecap=\\\"round\\\"/>\\n<path d=\\\"M2.71429 5H2C1.44772 5 1 5.44772 1 6V7C1 7.55228 1.44772 8 2 8H6C6.55228 8 7 7.55228 7 7V6C7 5.44772 6.55228 5 6 5H5.28571\\\" stroke=\\\"#D9D9D9\\\"/>\\n<path d=\\\"M4 5L4 2\\\" stroke=\\\"#D9D9D9\\\" stroke-linecap=\\\"round\\\"/>\\n</svg>\\n\"\n      };\n      var buttons = [{\n        id: 'undoBtn',\n        icon: svgIcons.undo,\n        text: 'Undo',\n        handler: function handler() {\n          return _this6.controller.history.undo();\n        }\n      }, {\n        id: 'redoBtn',\n        icon: svgIcons.redo,\n        text: 'Redo',\n        handler: function handler() {\n          return _this6.controller.history.redo();\n        }\n      }, {\n        id: 'randomizeBtn',\n        icon: svgIcons.randomize,\n        text: 'Random',\n        handler: function handler() {\n          return _this6.randomizeShape();\n        }\n      }, {\n        id: 'animateBtn',\n        icon: this.getPlayIcon(),\n        text: 'Play',\n        handler: function handler() {\n          return _this6.toggleAnimation();\n        }\n      }, {\n        id: 'copyBtn',\n        icon: svgIcons.copy,\n        text: 'Copy',\n        handler: function handler() {\n          return _this6.copySvgToClipboard();\n        }\n      }, {\n        id: 'saveBtn',\n        icon: svgIcons.save,\n        text: 'Save',\n        handler: function handler() {\n          return _this6.saveToFavorites();\n        }\n      }, {\n        id: 'exportBtn',\n        icon: svgIcons[\"export\"],\n        text: 'Export',\n        handler: function handler() {\n          return _this6.showExportModal();\n        }\n      }];\n      buttons.forEach(function (button) {\n        var btn = document.createElement('button');\n        btn.id = button.id;\n        btn.className = 'control-button';\n\n        // Create container for SVG to control its size\n        var iconSpan = document.createElement('span');\n        iconSpan.innerHTML = button.icon;\n        iconSpan.style.display = 'flex';\n        iconSpan.style.alignItems = 'center';\n        iconSpan.style.justifyContent = 'center';\n        iconSpan.style.width = '14px';\n        iconSpan.style.height = '14px';\n\n        // Apply styles to the SVG elements to match design\n        var svgElements = iconSpan.querySelectorAll('svg');\n        svgElements.forEach(function (svg) {\n          svg.style.width = '14px';\n          svg.style.height = '14px';\n        });\n\n        // Clear the button and add the icon span and text separately\n        btn.innerHTML = '';\n        btn.appendChild(iconSpan);\n        var textSpan = document.createElement('span');\n        textSpan.textContent = button.text;\n        btn.appendChild(textSpan);\n\n        // Button styling to match the screenshot\n        btn.style.backgroundColor = '#1A1A1A';\n        btn.style.color = '#D9D9D9';\n        btn.style.border = 'none';\n        btn.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n        btn.style.borderRadius = '30px';\n        btn.style.padding = '8px 16px';\n        btn.style.cursor = 'pointer';\n        btn.style.display = 'flex';\n        btn.style.alignItems = 'center';\n        btn.style.justifyContent = 'center';\n        btn.style.gap = '6px'; // Reduced gap between icon and text\n        btn.style.fontSize = '12px';\n        btn.style.minWidth = '100px';\n        btn.addEventListener('click', button.handler);\n        container.appendChild(btn);\n      });\n      if (this.controller.history) {\n        this.controller.history.updateButtonsState();\n      }\n    }\n  }, {\n    key: \"showExportModal\",\n    value: function showExportModal() {\n      var _this7 = this;\n      // Remove any existing modal\n      var existingModal = document.getElementById('export-modal');\n      if (existingModal) {\n        existingModal.remove();\n      }\n\n      // Create modal container\n      var modal = document.createElement('div');\n      modal.id = 'export-modal';\n      modal.className = 'modal';\n\n      // Create modal content\n      var modalContent = document.createElement('div');\n      modalContent.className = 'modal-content';\n      modalContent.style.backgroundColor = '#000';\n      modalContent.style.borderRadius = '8px';\n      modalContent.style.padding = '24px';\n      modalContent.style.width = '320px';\n      modalContent.style.maxWidth = '90%';\n      modalContent.style.color = '#e0e0e0';\n      modalContent.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n\n      // Create modal header\n      var modalHeader = document.createElement('div');\n      modalHeader.className = 'modal-header';\n      modalHeader.style.display = 'flex';\n      modalHeader.style.justifyContent = 'space-between';\n      modalHeader.style.alignItems = 'center';\n      modalHeader.style.marginBottom = '16px';\n      var modalTitle = document.createElement('h3');\n      modalTitle.textContent = 'Export Shape';\n      modalTitle.style.margin = '0';\n      modalTitle.style.fontSize = '16px';\n      modalTitle.style.fontWeight = 'normal';\n      modalTitle.style.color = '#e0e0e0';\n      var closeButton = document.createElement('button');\n      closeButton.className = 'close-button';\n      closeButton.innerHTML = \"\\n      <svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <path d=\\\"M1 1L13 13M1 13L13 1\\\" stroke=\\\"#e0e0e0\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n      </svg>\\n    \";\n      closeButton.style.backgroundColor = 'transparent';\n      closeButton.style.border = 'none';\n      closeButton.style.cursor = 'pointer';\n      closeButton.style.padding = '4px';\n      closeButton.style.display = 'flex';\n      closeButton.style.alignItems = 'center';\n      closeButton.style.justifyContent = 'center';\n      closeButton.onclick = function () {\n        return modal.remove();\n      };\n      modalHeader.appendChild(modalTitle);\n      modalHeader.appendChild(closeButton);\n\n      // Create form\n      var form = document.createElement('form');\n      form.onsubmit = function (e) {\n        e.preventDefault();\n        _this7.exportWithOptions();\n      };\n\n      // Format selection\n      var formatGroup = this.createFormGroup('Format');\n      var formatSelect = this.createSelect('format', [{\n        value: 'png',\n        label: 'PNG'\n      }, {\n        value: 'svg',\n        label: 'SVG'\n      }]);\n      formatSelect.value = 'png'; // Default to PNG\n      formatGroup.appendChild(formatSelect);\n\n      // Aspect ratio selection\n      var aspectGroup = this.createFormGroup('Aspect Ratio');\n      var aspectSelect = this.createSelect('aspect-ratio', [{\n        value: '1:1',\n        label: '1:1 (Square)'\n      }, {\n        value: '4:3',\n        label: '4:3'\n      }, {\n        value: '16:9',\n        label: '16:9'\n      }, {\n        value: '3:2',\n        label: '3:2'\n      }, {\n        value: '2:1',\n        label: '2:1'\n      }, {\n        value: '9:16',\n        label: '9:16 (Mobile Portrait)'\n      }, {\n        value: '18:9',\n        label: '18:9 (Mobile Landscape)'\n      }]);\n      aspectGroup.appendChild(aspectSelect);\n\n      // Resolution selection\n      var resolutionGroup = this.createFormGroup('Resolution');\n      var resolutionSelect = this.createSelect('resolution', [{\n        value: '800',\n        label: '800800 (Small)'\n      }, {\n        value: '1200',\n        label: '12001200 (Medium)'\n      }, {\n        value: '2400',\n        label: '24002400 (Large)'\n      }, {\n        value: '3600',\n        label: '36003600 (Very Large)'\n      }]);\n      resolutionSelect.value = '1200'; // Default to medium\n      resolutionGroup.appendChild(resolutionSelect);\n\n      // Background color option\n      var bgGroup = this.createFormGroup('Background');\n      var bgSelect = this.createSelect('background', [{\n        value: 'transparent',\n        label: 'Transparent (PNG only)'\n      }, {\n        value: 'black',\n        label: 'Black (Default)'\n      }]);\n\n      // Disable transparent option when SVG is selected\n      formatSelect.addEventListener('change', function (e) {\n        if (e.target.value === 'svg') {\n          if (bgSelect.value === 'transparent') {\n            bgSelect.value = 'black';\n          }\n\n          // Find and disable the transparent option\n          Array.from(bgSelect.options).forEach(function (option) {\n            if (option.value === 'transparent') {\n              option.disabled = true;\n            }\n          });\n        } else {\n          // Re-enable the transparent option\n          Array.from(bgSelect.options).forEach(function (option) {\n            if (option.value === 'transparent') {\n              option.disabled = false;\n            }\n          });\n        }\n      });\n      bgGroup.appendChild(bgSelect);\n\n      // Update resolution label based on aspect ratio\n      aspectSelect.addEventListener('change', function () {\n        _this7.updateResolutionLabels(aspectSelect.value, resolutionSelect);\n      });\n\n      // Create submit button\n      var buttonGroup = document.createElement('div');\n      buttonGroup.style.marginTop = '24px';\n      buttonGroup.style.display = 'flex';\n      buttonGroup.style.justifyContent = 'center';\n      var submitButton = document.createElement('button');\n      submitButton.type = 'submit';\n      submitButton.textContent = 'Export';\n      submitButton.style.backgroundColor = '#333';\n      submitButton.style.color = '#e0e0e0';\n      submitButton.style.border = 'none';\n      submitButton.style.borderRadius = '30px';\n      submitButton.style.padding = '8px 16px';\n      submitButton.style.cursor = 'pointer';\n      submitButton.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      submitButton.style.fontSize = '12px';\n      submitButton.style.width = '100%';\n      submitButton.style.transition = 'background-color 0.2s';\n      submitButton.addEventListener('mouseover', function () {\n        submitButton.style.backgroundColor = '#444';\n      });\n      submitButton.addEventListener('mouseout', function () {\n        submitButton.style.backgroundColor = '#333';\n      });\n      buttonGroup.appendChild(submitButton);\n\n      // Assemble form\n      form.appendChild(formatGroup);\n      form.appendChild(aspectGroup);\n      form.appendChild(resolutionGroup);\n      form.appendChild(bgGroup);\n      form.appendChild(buttonGroup);\n\n      // Assemble modal\n      modalContent.appendChild(modalHeader);\n      modalContent.appendChild(form);\n      modal.appendChild(modalContent);\n\n      // Add modal to document\n      document.body.appendChild(modal);\n\n      // Initialize correct resolution labels\n      this.updateResolutionLabels(aspectSelect.value, resolutionSelect);\n      var _modalEscHandler = function modalEscHandler(e) {\n        if (e.key === 'Escape') {\n          modal.remove();\n          document.removeEventListener('keydown', _modalEscHandler);\n          e.stopPropagation();\n        }\n      };\n      document.addEventListener('keydown', _modalEscHandler);\n    }\n  }, {\n    key: \"createFormGroup\",\n    value: function createFormGroup(label) {\n      var group = document.createElement('div');\n      group.className = 'form-group';\n      group.style.marginBottom = '16px';\n      var labelElement = document.createElement('label');\n      labelElement.textContent = label;\n      labelElement.style.display = 'block';\n      labelElement.style.marginBottom = '8px';\n      labelElement.style.fontSize = '12px';\n      labelElement.style.color = '#999';\n      labelElement.style.textTransform = 'uppercase';\n      labelElement.style.letterSpacing = '0.5px';\n      group.appendChild(labelElement);\n      return group;\n    }\n\n    // Helper method to create select elements\n  }, {\n    key: \"createSelect\",\n    value: function createSelect(id, options) {\n      var select = document.createElement('select');\n      select.id = id;\n      select.style.width = '100%';\n      select.style.backgroundColor = '#000';\n      select.style.color = '#e0e0e0';\n      select.style.border = '1px solid #333';\n      select.style.borderRadius = '4px';\n      select.style.padding = '8px';\n      select.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n      select.style.fontSize = '12px';\n      select.style.appearance = 'none';\n      select.style.backgroundImage = \"url(\\\"data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23999' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e\\\")\";\n      select.style.backgroundRepeat = 'no-repeat';\n      select.style.backgroundPosition = 'right 8px center';\n      select.style.backgroundSize = '16px';\n      options.forEach(function (option) {\n        var optElement = document.createElement('option');\n        optElement.value = option.value;\n        optElement.textContent = option.label;\n        select.appendChild(optElement);\n      });\n      return select;\n    }\n  }, {\n    key: \"updateResolutionLabels\",\n    value: function updateResolutionLabels(aspectRatio, resolutionSelect) {\n      var _this8 = this;\n      var _aspectRatio$split$ma = aspectRatio.split(':').map(Number),\n        _aspectRatio$split$ma2 = _slicedToArray(_aspectRatio$split$ma, 2),\n        width = _aspectRatio$split$ma2[0],\n        height = _aspectRatio$split$ma2[1];\n      var baseResolutions = [800, 1200, 2400, 3600];\n      var labels = ['Small', 'Medium', 'Large', 'Very Large'];\n\n      // Remove existing options\n      while (resolutionSelect.firstChild) {\n        resolutionSelect.removeChild(resolutionSelect.firstChild);\n      }\n\n      // Add new options with updated labels\n      baseResolutions.forEach(function (res, index) {\n        var adjusted = _this8.calculateDimensions(res, width, height);\n        var option = document.createElement('option');\n        option.value = res;\n        option.textContent = \"\".concat(adjusted.width, \"\\xD7\").concat(adjusted.height, \" (\").concat(labels[index], \")\");\n        resolutionSelect.appendChild(option);\n      });\n    }\n\n    // Calculate dimensions based on aspect ratio\n  }, {\n    key: \"calculateDimensions\",\n    value: function calculateDimensions(baseSize, width, height) {\n      if (width === height) {\n        return {\n          width: baseSize,\n          height: baseSize\n        };\n      }\n\n      // Calculate the longer side based on aspect ratio\n      if (width > height) {\n        var h = Math.round(baseSize * (height / width));\n        return {\n          width: baseSize,\n          height: h\n        };\n      } else {\n        var w = Math.round(baseSize * (width / height));\n        return {\n          width: w,\n          height: baseSize\n        };\n      }\n    }\n\n    // Export with the selected options\n  }, {\n    key: \"exportWithOptions\",\n    value: function exportWithOptions() {\n      var formatSelect = document.getElementById('format');\n      var aspectSelect = document.getElementById('aspect-ratio');\n      var resolutionSelect = document.getElementById('resolution');\n      var bgSelect = document.getElementById('background');\n      if (!formatSelect || !aspectSelect || !resolutionSelect || !bgSelect) {\n        console.error('Could not find form elements');\n        return;\n      }\n      var format = formatSelect.value;\n      var aspectRatio = aspectSelect.value;\n      var baseSize = parseInt(resolutionSelect.value);\n      var background = bgSelect.value;\n\n      // Calculate dimensions\n      var _aspectRatio$split$ma3 = aspectRatio.split(':').map(Number),\n        _aspectRatio$split$ma4 = _slicedToArray(_aspectRatio$split$ma3, 2),\n        width = _aspectRatio$split$ma4[0],\n        height = _aspectRatio$split$ma4[1];\n      var dimensions = this.calculateDimensions(baseSize, width, height);\n\n      // Close the modal\n      var modal = document.getElementById('export-modal');\n      if (modal) {\n        modal.remove();\n      }\n\n      // Call export with the selected options\n      this.exportShapeWithOptions(format, dimensions, background);\n    }\n\n    // Enhanced export method with options\n  }, {\n    key: \"exportShapeWithOptions\",\n    value: function exportShapeWithOptions(format, dimensions, background) {\n      var _this9 = this;\n      var svg = document.getElementById('preview-svg');\n      if (!svg) return;\n      var svgClone = svg.cloneNode(true);\n\n      // Create a clean SVG by setting explicit dimensions\n      svgClone.setAttribute('width', dimensions.width);\n      svgClone.setAttribute('height', dimensions.height);\n\n      // Add background if specified and not transparent\n      if (background !== 'transparent' && format !== 'svg') {\n        var bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        bgRect.setAttribute('width', '100%');\n        bgRect.setAttribute('height', '100%');\n        bgRect.setAttribute('fill', background);\n        svgClone.insertBefore(bgRect, svgClone.firstChild);\n      }\n      var svgData = new XMLSerializer().serializeToString(svgClone);\n      if (format === 'svg') {\n        var blob = new Blob([svgData], {\n          type: 'image/svg+xml'\n        });\n        this.downloadFile(blob, \"shape-\".concat(dimensions.width, \"x\").concat(dimensions.height, \".svg\"));\n      } else if (format === 'png') {\n        var canvas = document.createElement('canvas');\n        var ctx = canvas.getContext('2d');\n        canvas.width = dimensions.width;\n        canvas.height = dimensions.height;\n\n        // Set up the canvas\n        if (background === 'transparent') {\n          // For transparent background, we need to clear the canvas\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n        } else {\n          // For colored background\n          ctx.fillStyle = background;\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n\n        // Create SVG image\n        var img = new Image();\n        var svgBlob = new Blob([svgData], {\n          type: 'image/svg+xml'\n        });\n        var url = URL.createObjectURL(svgBlob);\n        img.onload = function () {\n          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n          // Use proper PNG encoding with transparency support\n          var exportOptions = background === 'transparent' ? {\n            type: 'image/png'\n          } : {\n            type: 'image/png',\n            quality: 1.0\n          };\n          canvas.toBlob(function (blob) {\n            _this9.downloadFile(blob, \"shape-\".concat(dimensions.width, \"x\").concat(dimensions.height, \".png\"));\n            URL.revokeObjectURL(url);\n          }, exportOptions.type, exportOptions.quality);\n        };\n        img.src = url;\n      }\n    }\n\n    /**\n     * Create parameter controls with dark theme\n     */\n  }, {\n    key: \"createControls\",\n    value: function createControls(parameters, container) {\n      var _this10 = this;\n      Object.entries(parameters).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          param = _ref4[0],\n          config = _ref4[1];\n        if (param === 'seed') return; // skip seed if needed\n\n        var paramContainer = document.createElement('div');\n        paramContainer.className = 'control-row';\n\n        // For options\n        if (config.options) {\n          // Create a select dropdown\n          var select = document.createElement('select');\n          select.className = 'param-select';\n          select.style.backgroundColor = '#000';\n          select.style.color = '#e0e0e0';\n          select.style.border = '1px solid #333';\n          select.style.borderRadius = '4px';\n          select.style.padding = '4px 8px';\n          select.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n          select.style.fontSize = '10px';\n          select.style.width = '100%';\n          select.style.cursor = 'pointer';\n          select.setAttribute('data-param', param);\n          config.options.forEach(function (option) {\n            var opt = document.createElement('option');\n            opt.value = option;\n            opt.textContent = option;\n            if (option === _this10.parameters[param]) opt.selected = true;\n            select.appendChild(opt);\n          });\n          select.addEventListener('change', function () {\n            _this10.parameters[param] = select.value;\n            _this10.updateShape();\n            if (_this10.controller.history) {\n              _this10.controller.history.saveState();\n            }\n          });\n          paramContainer.appendChild(select);\n        } else if (config.min !== undefined && config.max !== undefined) {\n          // Numeric range (slider) - no value label\n          var slider = document.createElement('input');\n          slider.type = 'range';\n          slider.min = config.min;\n          slider.max = config.max;\n          slider.step = Number.isInteger(config[\"default\"]) ? '1' : '0.1';\n          slider.value = _this10.parameters[param];\n          slider.className = 'param-slider';\n          slider.setAttribute('data-param', param);\n          slider.style.width = '100%';\n\n          // Slider input with debounce for performance\n          var debounceTimer = null;\n          slider.addEventListener('input', function (e) {\n            var value = e.target.value;\n            var floatVal = parseFloat(value);\n            var processed = isNaN(floatVal) ? config[\"default\"] : Number.isInteger(config[\"default\"]) ? Math.round(floatVal) : parseFloat(floatVal.toFixed(2));\n            _this10.parameters[param] = processed;\n            _this10.updateShape();\n\n            // Debounce state saves during sliding\n            clearTimeout(debounceTimer);\n            debounceTimer = setTimeout(function () {\n              if (_this10.controller.history) {\n                _this10.controller.history.saveState();\n              }\n            }, 300);\n          });\n          paramContainer.appendChild(slider);\n        } else if (typeof _this10.parameters[param] === 'boolean') {\n          // Boolean parameter -> checkbox\n          var checkbox = document.createElement('input');\n          checkbox.type = 'checkbox';\n          checkbox.checked = _this10.parameters[param];\n          checkbox.style.color = '#333';\n          checkbox.style.accentColor = '#333';\n          checkbox.style.cursor = 'pointer';\n          checkbox.addEventListener('change', function () {\n            _this10.parameters[param] = checkbox.checked;\n            _this10.updateShape();\n            if (_this10.controller.history) {\n              _this10.controller.history.saveState();\n            }\n          });\n          paramContainer.appendChild(checkbox);\n        } else {\n          // Generic text input\n          var input = document.createElement('input');\n          input.type = 'text';\n          input.className = 'param-text';\n          input.setAttribute('data-param', param);\n          input.value = _this10.parameters[param];\n          input.style.backgroundColor = '#444';\n          input.style.color = '#e0e0e0';\n          input.style.border = '1px solid #555';\n          input.style.borderRadius = '3px';\n          input.style.padding = '4px 8px';\n          input.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n          input.style.fontSize = '12px';\n          input.style.width = '100%';\n          input.addEventListener('change', function () {\n            var numValue = parseFloat(input.value);\n            _this10.parameters[param] = isNaN(numValue) ? input.value : numValue;\n            _this10.updateShape();\n            if (_this10.controller.history) {\n              _this10.controller.history.saveState();\n            }\n          });\n          paramContainer.appendChild(input);\n        }\n\n        // Add parameter name label - positioned above control\n        var nameLabel = document.createElement('span');\n        nameLabel.className = 'param-name';\n        nameLabel.textContent = param.charAt(0).toUpperCase() + param.slice(1);\n        paramContainer.insertBefore(nameLabel, paramContainer.firstChild);\n        container.appendChild(paramContainer);\n      });\n    }\n\n    /**\n     * Update the shape display\n     */\n  }, {\n    key: \"updateShape\",\n    value: function updateShape() {\n      if (!this.currentShape) return;\n      try {\n        var ShapeClass = this.controller.shapes[this.currentShape];\n        if (!ShapeClass) return;\n\n        // Keep controller's parameters in sync with editor's\n        if (this.controller.parameters) {\n          this.controller.parameters = _objectSpread({}, this.parameters);\n        }\n\n        // Create a new shape with current parameters\n        var shape = new ShapeClass(this.parameters);\n        var group = document.getElementById('shape');\n        if (group) {\n          var shapeContent = shape.generateShape();\n          if (shapeContent) {\n            group.innerHTML = shapeContent;\n          }\n        }\n      } catch (err) {\n        console.error('Error updating shape:', err);\n      }\n    }\n\n    /**\n     * Show error view when editor fails to load\n     */\n  }, {\n    key: \"showErrorView\",\n    value: function showErrorView(container, shapeName) {\n      var errorLayout = document.createElement('div');\n      errorLayout.className = 'editor-layout error';\n      errorLayout.style.backgroundColor = '#111';\n      errorLayout.style.color = '#e0e0e0';\n      errorLayout.style.height = '100vh';\n      errorLayout.style.display = 'flex';\n      errorLayout.style.flexDirection = 'column';\n      errorLayout.style.alignItems = 'center';\n      errorLayout.style.justifyContent = 'center';\n      errorLayout.style.padding = '20px';\n      var errorMessage = document.createElement('div');\n      errorMessage.textContent = \"Error loading shape editor for: \".concat(shapeName);\n      errorMessage.style.color = '#ff5555';\n      errorMessage.style.marginBottom = '20px';\n      var backButton = document.createElement('button');\n      backButton.textContent = 'Back to Grid';\n      backButton.style.padding = '8px 16px';\n      backButton.style.backgroundColor = '#333';\n      backButton.style.color = '#fff';\n      backButton.style.border = 'none';\n      backButton.style.borderRadius = '4px';\n      backButton.style.cursor = 'pointer';\n      backButton.addEventListener('click', this.hideEditor);\n      errorLayout.appendChild(errorMessage);\n      errorLayout.appendChild(backButton);\n      container.appendChild(errorLayout);\n      document.addEventListener('keydown', this.handleKeyDown);\n    }\n\n    /**\n     * Hide the editor and return to the grid\n     */\n  }, {\n    key: \"hideEditor\",\n    value: function hideEditor() {\n      // Clean up animation if running\n      this.cleanupAnimation();\n      this.editorOpen = false;\n      this.currentShape = null;\n      document.removeEventListener('keydown', this.handleKeyDown);\n      this.parameters = {};\n      this.controller.returnToGrid();\n    }\n\n    /**\n     * Handle key down events in the editor\n     */\n  }, {\n    key: \"handleKeyDown\",\n    value: function handleKeyDown(e) {\n      // Check if export modal is open\n      var exportModal = document.getElementById('export-modal');\n      if (e.key === 'Escape' && !exportModal) {\n        // Only close the editor if the modal is not open\n        this.hideEditor();\n      } else if (e.key === ' ' || e.code === 'Space') {\n        // Toggle animation with space bar\n        e.preventDefault(); // Prevent page scrolling\n        this.toggleAnimation();\n      }\n    }\n\n    /**\n     * Randomize the current shape\n     */\n  }, {\n    key: \"randomizeShape\",\n    value: function randomizeShape() {\n      var _this11 = this;\n      if (!this.currentShape) return;\n      var shapeName = this.currentShape;\n      var ShapeClass = this.controller.shapes[shapeName];\n      if (!ShapeClass) return;\n      var classParameters = ShapeClass.parameters || {};\n      var allParameters = _objectSpread(_objectSpread({}, this.controller.Shape.parameters), classParameters);\n      Object.entries(allParameters).forEach(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n          param = _ref6[0],\n          config = _ref6[1];\n        if (config.options) {\n          var randomIndex = Math.floor(Math.random() * config.options.length);\n          _this11.parameters[param] = config.options[randomIndex];\n        } else if (config.min !== undefined && config.max !== undefined) {\n          var randomValue = config.min + Math.random() * (config.max - config.min);\n          _this11.parameters[param] = Number.isInteger(config[\"default\"]) ? Math.round(randomValue) : parseFloat(randomValue.toFixed(2));\n        }\n      });\n      this.updateShape();\n      if (this.controller.history) {\n        this.controller.history.saveState();\n      }\n      this.updateParameterControls();\n    }\n\n    /**\n     * Update parameter controls to reflect current values\n     */\n  }, {\n    key: \"updateParameterControls\",\n    value: function updateParameterControls() {\n      var _this12 = this;\n      // For every input with a data-param attribute, update its value\n      document.querySelectorAll('[data-param]').forEach(function (input) {\n        var param = input.getAttribute('data-param');\n        if (_this12.parameters.hasOwnProperty(param)) {\n          if (input.type === 'range' || input.type === 'text') {\n            input.value = _this12.parameters[param];\n          } else if (input.tagName === 'SELECT') {\n            Array.from(input.options).forEach(function (option) {\n              option.selected = option.value === _this12.parameters[param];\n            });\n          }\n        }\n      });\n    }\n\n    /**\n     * Save to favorites\n     */\n  }, {\n    key: \"saveToFavorites\",\n    value: function saveToFavorites() {\n      if (!this.currentShape) return;\n      if (this.controller.favorites) {\n        this.controller.favorites.saveCurrentShape(this.currentShape, this.parameters);\n      }\n      var saveBtn = document.getElementById('saveBtn');\n      if (saveBtn) {\n        var originalHTML = saveBtn.innerHTML;\n        saveBtn.innerHTML = \"Saved\";\n        setTimeout(function () {\n          saveBtn.innerHTML = originalHTML;\n        }, 1500);\n      }\n    }\n\n    /**\n     * Copy SVG to clipboard\n     */\n  }, {\n    key: \"copySvgToClipboard\",\n    value: function copySvgToClipboard() {\n      var svg = document.getElementById('preview-svg');\n      if (!svg) return;\n      var svgData = new XMLSerializer().serializeToString(svg);\n      navigator.clipboard.writeText(svgData).then(function () {\n        var copyBtn = document.getElementById('copyBtn');\n        if (copyBtn) {\n          var originalHTML = copyBtn.innerHTML;\n          copyBtn.innerHTML = \"Copied\";\n          setTimeout(function () {\n            copyBtn.innerHTML = originalHTML;\n          }, 1500);\n        }\n      })[\"catch\"](function (err) {\n        console.error('Error copying SVG to clipboard:', err);\n      });\n    }\n\n    /**\n     * Download file helper\n     */\n  }, {\n    key: \"downloadFile\",\n    value: function downloadFile(blob, filename) {\n      var url = URL.createObjectURL(blob);\n      var a = document.createElement('a');\n      a.href = url;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShapeEditor);\n\n//# sourceURL=webpack://generative-shapes/./src/ShapeEditor.js?");

/***/ }),

/***/ "./src/ShapeFavorites.js":
/*!*******************************!*\
  !*** ./src/ShapeFavorites.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar ShapeFavorites = /*#__PURE__*/function () {\n  function ShapeFavorites(controller) {\n    _classCallCheck(this, ShapeFavorites);\n    // Store controller reference\n    this.controller = controller;\n\n    // Initialize empty favorites array - we'll load them in init()\n    this.favorites = [];\n  }\n\n  // Initialize the favorites component\n  return _createClass(ShapeFavorites, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n      // console.log('Initializing favorites manager...');\n\n      // Load saved favorites from localStorage\n      this.loadFavoritesFromStorage();\n\n      // Create the overlay\n      this.createFavoritesOverlay();\n\n      // Setup bookmark buttons\n      this.setupBookmarkButtons();\n\n      // Global document handler for dynamically added bookmark buttons\n      document.addEventListener('click', function (e) {\n        var button = e.target.closest('.bookmark-btn');\n        if (button) {\n          e.preventDefault();\n          e.stopPropagation();\n          _this.toggleFavoritesOverlay();\n        }\n      });\n\n      // Add initialization styles\n      this.addStyles();\n\n      // Add global keydown event listener (moved from createFavoritesOverlay)\n      document.addEventListener('keydown', function (e) {\n        if (e.key === 'Escape') {\n          var overlay = document.querySelector('.favorites-overlay');\n          if (overlay && window.getComputedStyle(overlay).display !== 'none') {\n            _this.toggleFavoritesOverlay();\n          }\n        }\n      });\n    }\n\n    // Add custom CSS styles for favorites\n  }, {\n    key: \"addStyles\",\n    value: function addStyles() {\n      var styleId = 'favorites-custom-styles';\n      var existingStyles = document.getElementById(styleId);\n      if (existingStyles) {\n        existingStyles.remove();\n      }\n      var style = document.createElement('style');\n      style.id = styleId;\n      style.textContent = \"\\n            .favorites-overlay {\\n                position: fixed;\\n                top: 0;\\n                left: 0;\\n                right: 0;\\n                bottom: 0;\\n                background-color: #000000 !important;\\n                z-index: 1000;\\n                display: none;\\n                justify-content: center;\\n                align-items: center;\\n                padding: 24px;\\n            }\\n            .favorites-content {\\n                background-color: #00000;\\n                border-radius: 8px;\\n                width: 95%;\\n                max-width: 1200px;\\n                max-height: 90vh;\\n                display: flex;\\n                flex-direction: column;\\n                overflow: hidden;\\n            }\\n            .favorites-header {\\n                display: flex;\\n                justify-content: space-between;\\n                align-items: center;\\n                padding: 16px 20px;\\n            }\\n            #favoritesGrid {\\n                display: grid;\\n                grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));\\n                gap: 16px;\\n                padding: 24px;\\n                overflow-y: auto;\\n                max-height: calc(90vh - 70px);\\n                background-color: #000000;\\n            }\\n            .shape-thumbnail {\\n                aspect-ratio: 1;\\n                background-color: #111111;\\n                border-radius: 4px;\\n                cursor: pointer;\\n                position: relative;\\n                transition: background-color 0.2s;\\n                overflow: hidden;\\n                border: 1px solid #222;\\n            }\\n            .shape-thumbnail:hover {\\n                background-color: #1A1A1A;\\n                border-color: #333;\\n            }\\n            .shape-preview {\\n                width: 100%;\\n                height: 100%;\\n                display: flex;\\n                justify-content: center;\\n                align-items: center;\\n                background-color: #000000;\\n            }\\n            .shape-title {\\n                position: absolute;\\n                bottom: 0;\\n                left: 0;\\n                right: 0;\\n                padding: 8px;\\n                font-size: 11px;\\n                background: rgba(0,0,0,0.8);\\n                color: #aaa;\\n                text-align: center;\\n                white-space: nowrap;\\n                overflow: hidden;\\n                text-overflow: ellipsis;\\n            }\\n            .remove-favorite {\\n                position: absolute;\\n                top: 8px;\\n                right: 8px;\\n                width: 24px;\\n                height: 24px;\\n                background-color: rgba(0, 0, 0, 0.8);\\n                border: 1px solid #333;\\n                border-radius: 50%;\\n                color: #ccc;\\n                font-size: 14px;\\n                cursor: pointer;\\n                display: flex;\\n                justify-content: center;\\n                align-items: center;\\n                opacity: 0;\\n                transition: opacity 0.2s;\\n            }\\n            .shape-thumbnail:hover .remove-favorite {\\n                opacity: 1;\\n            }\\n            .remove-favorite:hover {\\n                background-color: #333;\\n                color: #fff;\\n            }\\n            .empty-favorites {\\n                padding: 60px;\\n                text-align: center;\\n                color: #444;\\n                font-size: 14px;\\n                grid-column: 1 / -1;\\n            }\\n            #closeFavorites {\\n                background-color: #000;\\n                color: #666;\\n                border: none;\\n                border-radius: 50%;\\n                width: 30px;\\n                height: 30px;\\n                display: flex;\\n                align-items: center;\\n                justify-content: center;\\n                cursor: pointer;\\n                transition: background-color 0.2s;\\n            }\\n            #closeFavorites:hover {\\n                background-color: #000;\\n                color: #fff;\\n            }\\n        \";\n      document.head.appendChild(style);\n    }\n\n    // Load favorites from localStorage\n  }, {\n    key: \"loadFavoritesFromStorage\",\n    value: function loadFavoritesFromStorage() {\n      try {\n        var stored = localStorage.getItem('shapeFavorites');\n        this.favorites = stored ? JSON.parse(stored) : [];\n        // console.log(`Loaded ${this.favorites.length} favorites from storage`);\n      } catch (error) {\n        console.error('Error loading favorites from storage:', error);\n        this.favorites = [];\n      }\n    }\n\n    // Save favorites to localStorage\n  }, {\n    key: \"saveFavoritesToStorage\",\n    value: function saveFavoritesToStorage() {\n      try {\n        localStorage.setItem('shapeFavorites', JSON.stringify(this.favorites));\n        console.log(\"Saved \".concat(this.favorites.length, \" favorites to storage\"));\n      } catch (error) {\n        console.error('Error saving favorites to storage:', error);\n      }\n    }\n\n    // Set up event handlers for bookmark buttons\n  }, {\n    key: \"setupBookmarkButtons\",\n    value: function setupBookmarkButtons() {\n      var _this2 = this;\n      var bookmarkBtns = document.querySelectorAll('.bookmark-btn');\n      if (bookmarkBtns.length > 0) {\n        // console.log(`Found ${bookmarkBtns.length} bookmark button(s)`);\n        bookmarkBtns.forEach(function (btn) {\n          // Remove existing listeners by cloning the element\n          var newBtn = btn.cloneNode(true);\n          btn.parentNode.replaceChild(newBtn, btn);\n          newBtn.addEventListener('click', function (event) {\n            event.preventDefault();\n            event.stopPropagation();\n            _this2.toggleFavoritesOverlay();\n          });\n        });\n      } else {\n        console.log('No bookmark buttons found');\n      }\n    }\n\n    // Create the favorites overlay\n  }, {\n    key: \"createFavoritesOverlay\",\n    value: function createFavoritesOverlay() {\n      var _this3 = this;\n      // Remove existing overlay if present\n      var existingOverlay = document.querySelector('.favorites-overlay');\n      if (existingOverlay) {\n        existingOverlay.remove();\n      }\n\n      // console.log('Creating favorites overlay');\n      var favoritesOverlay = document.createElement('div');\n      favoritesOverlay.className = 'favorites-overlay';\n      var favoritesContent = document.createElement('div');\n      favoritesContent.className = 'favorites-content';\n      var header = document.createElement('div');\n      header.className = 'favorites-header';\n\n      // Close button with icon\n      var closeBtn = document.createElement('button');\n      closeBtn.id = 'closeFavorites';\n      closeBtn.className = 'icon-button';\n      closeBtn.innerHTML = \"\\n            <svg width=\\\"30\\\" height=\\\"30\\\" viewBox=\\\"0 0 30 30\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n            <path d=\\\"M9 10L20 21\\\" stroke=\\\"#666666\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n            <path d=\\\"M20 10L9 21\\\" stroke=\\\"#666666\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n            </svg>\\n\\n        \";\n      header.appendChild(closeBtn);\n      var favoritesGrid = document.createElement('div');\n      favoritesGrid.id = 'favoritesGrid';\n      favoritesContent.appendChild(header);\n      favoritesContent.appendChild(favoritesGrid);\n      favoritesOverlay.appendChild(favoritesContent);\n      document.body.appendChild(favoritesOverlay);\n\n      // Add event listeners for closing overlay\n      closeBtn.addEventListener('click', function () {\n        return _this3.toggleFavoritesOverlay();\n      });\n      favoritesOverlay.addEventListener('click', function (e) {\n        if (e.target === favoritesOverlay) {\n          _this3.toggleFavoritesOverlay();\n        }\n      });\n\n      // Render initial favorites\n      this.renderFavorites();\n\n      // Store reference to overlay\n      this.overlay = favoritesOverlay;\n    }\n\n    // Save the current shape to favorites\n  }, {\n    key: \"saveCurrentShape\",\n    value: function saveCurrentShape(shapeName, params) {\n      console.log('Saving current shape...');\n      var favorite;\n      if (shapeName && params) {\n        favorite = {\n          id: Date.now(),\n          shapeName: shapeName,\n          parameters: _objectSpread({}, params),\n          dateAdded: new Date().toISOString()\n        };\n      } else if (this.controller.selectedShape) {\n        favorite = {\n          id: Date.now(),\n          shapeName: this.controller.selectedShape,\n          parameters: _objectSpread({}, this.controller.parameters),\n          dateAdded: new Date().toISOString()\n        };\n      } else {\n        console.log('No shape selected to save');\n        return;\n      }\n      console.log('Saving shape:', favorite);\n      this.favorites.push(favorite);\n      this.saveFavoritesToStorage();\n      this.renderFavorites();\n    }\n\n    // Render favorites grid\n  }, {\n    key: \"renderFavorites\",\n    value: function renderFavorites() {\n      var _this4 = this;\n      var grid = document.getElementById('favoritesGrid');\n      if (!grid) {\n        console.error('Favorites grid not found');\n        return;\n      }\n      grid.innerHTML = '';\n      // console.log('Rendering favorites:', this.favorites.length);\n\n      if (this.favorites.length === 0) {\n        var emptyState = document.createElement('div');\n        emptyState.className = 'empty-favorites';\n        emptyState.innerHTML = \"\\n                <svg width=\\\"60\\\" height=\\\"60\\\" viewBox=\\\"0 0 24 24\\\" stroke=\\\"#333\\\" fill=\\\"none\\\" stroke-width=\\\"1.5\\\" style=\\\"margin-bottom: 24px\\\">\\n                    <path d=\\\"M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z\\\"></path>\\n                </svg>\\n                <p>No shapes saved yet</p>\\n                <p style=\\\"margin-top:12px; font-size: 12px; color: #333;\\\">Use the \\\"Save\\\" button in the shape editor view</p>\\n            \";\n        grid.appendChild(emptyState);\n      } else {\n        this.favorites.forEach(function (favorite) {\n          var thumbnail = document.createElement('div');\n          thumbnail.className = 'shape-thumbnail';\n          var preview = document.createElement('div');\n          preview.className = 'shape-preview';\n          var svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n          svg.setAttribute('viewBox', '-150 -150 300 300');\n          svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n          svg.style.maxWidth = '80%';\n          svg.style.maxHeight = '80%';\n          var group = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n          svg.appendChild(group);\n\n          // const shapeTitle = document.createElement('div');\n          // shapeTitle.className = 'shape-title';\n          // shapeTitle.textContent = favorite.shapeName;\n\n          var ShapeClass = _this4.controller.shapes[favorite.shapeName];\n          if (ShapeClass) {\n            try {\n              var shape = new ShapeClass(favorite.parameters);\n              var shapeContent = shape.generateShape();\n              if (shapeContent) {\n                group.innerHTML = shapeContent;\n              }\n            } catch (error) {\n              console.error(\"Error rendering favorite \".concat(favorite.shapeName, \":\"), error);\n              group.innerHTML = \"<text x=\\\"0\\\" y=\\\"0\\\" fill=\\\"#ff0000\\\" text-anchor=\\\"middle\\\" font-size=\\\"12\\\">Error</text>\";\n            }\n          } else {\n            console.error(\"Shape class not found: \".concat(favorite.shapeName));\n            group.innerHTML = \"<text x=\\\"0\\\" y=\\\"0\\\" fill=\\\"#ff0000\\\" text-anchor=\\\"middle\\\" font-size=\\\"12\\\">Class not found</text>\";\n          }\n          preview.appendChild(svg);\n          thumbnail.appendChild(preview);\n          // thumbnail.appendChild(shapeTitle);\n\n          var removeBtn = document.createElement('button');\n          removeBtn.className = 'remove-favorite';\n          removeBtn.innerHTML = '';\n          removeBtn.addEventListener('click', function (e) {\n            e.stopPropagation();\n            _this4.removeFavorite(favorite.id);\n          });\n          thumbnail.appendChild(removeBtn);\n          thumbnail.addEventListener('click', function () {\n            _this4.loadFavorite(favorite);\n            _this4.toggleFavoritesOverlay();\n          });\n          grid.appendChild(thumbnail);\n        });\n      }\n    }\n\n    // Load a favorite shape\n  }, {\n    key: \"loadFavorite\",\n    value: function loadFavorite(favorite) {\n      var _this5 = this;\n      console.log('Loading favorite shape:', favorite.shapeName);\n      if (!this.controller.editor || !this.controller.editor.showEditor) {\n        console.error('Editor not available');\n        return;\n      }\n      this.controller.selectedShape = favorite.shapeName;\n      this.controller.parameters = JSON.parse(JSON.stringify(favorite.parameters));\n      if (this.controller.editor.editorOpen) {\n        console.log('Editor is open, closing before reopening with new shape');\n        this.controller.editor.hideEditor();\n        setTimeout(function () {\n          _this5.controller.editor.showEditor(favorite.shapeName);\n          _this5.controller.editor.parameters = JSON.parse(JSON.stringify(favorite.parameters));\n          _this5.controller.editor.updateShape();\n          if (_this5.controller.history) {\n            _this5.controller.history.saveState();\n          }\n        }, 100);\n      } else {\n        console.log('Opening editor with shape:', favorite.shapeName);\n        this.controller.editor.showEditor(favorite.shapeName);\n        setTimeout(function () {\n          _this5.controller.editor.parameters = JSON.parse(JSON.stringify(favorite.parameters));\n          _this5.controller.editor.updateShape();\n          if (_this5.controller.history) {\n            _this5.controller.history.saveState();\n          }\n        }, 50);\n      }\n    }\n\n    // Remove a favorite\n  }, {\n    key: \"removeFavorite\",\n    value: function removeFavorite(id) {\n      this.favorites = this.favorites.filter(function (fav) {\n        return fav.id !== id;\n      });\n      this.saveFavoritesToStorage();\n      this.renderFavorites();\n    }\n\n    // Toggle the visibility of the favorites overlay\n  }, {\n    key: \"toggleFavoritesOverlay\",\n    value: function toggleFavoritesOverlay() {\n      var _this6 = this;\n      console.log('Toggling favorites overlay');\n      var favoritesOverlay = document.querySelector('.favorites-overlay');\n      if (!favoritesOverlay) {\n        console.error('Favorites overlay not found, creating it');\n        this.createFavoritesOverlay();\n        setTimeout(function () {\n          return _this6.toggleFavoritesOverlay();\n        }, 50);\n        return;\n      }\n      var isHidden = window.getComputedStyle(favoritesOverlay).display === 'none';\n      if (isHidden) {\n        favoritesOverlay.style.display = 'flex';\n        document.body.style.overflow = 'hidden';\n        this.renderFavorites();\n      } else {\n        favoritesOverlay.style.display = 'none';\n        document.body.style.overflow = '';\n      }\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShapeFavorites);\n\n//# sourceURL=webpack://generative-shapes/./src/ShapeFavorites.js?");

/***/ }),

/***/ "./src/ShapeHistory.js":
/*!*****************************!*\
  !*** ./src/ShapeHistory.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar ShapeHistory = /*#__PURE__*/function () {\n  function ShapeHistory(controller) {\n    _classCallCheck(this, ShapeHistory);\n    this.controller = controller;\n    // Store history separately for each shape\n    this.historyByShape = {};\n    this.currentShapeName = null;\n    this.maxHistorySize = 50;\n    this.isRestoring = false;\n  }\n  return _createClass(ShapeHistory, [{\n    key: \"initShapeHistory\",\n    value: function initShapeHistory(shapeName) {\n      if (!shapeName) return;\n\n      // Initialize history for this shape if it doesn't exist\n      if (!this.historyByShape[shapeName]) {\n        this.historyByShape[shapeName] = {\n          states: [],\n          currentIndex: -1\n        };\n      }\n      this.currentShapeName = shapeName;\n    }\n  }, {\n    key: \"saveState\",\n    value: function saveState() {\n      if (this.isRestoring || !this.currentShapeName) return;\n      var shapeHistory = this.historyByShape[this.currentShapeName];\n      if (!shapeHistory) return;\n\n      // Determine which parameters to save\n      var parameters = {};\n\n      // If editor is open, use its parameters\n      if (this.controller.editor && this.controller.editor.editorOpen) {\n        parameters = _objectSpread({}, this.controller.editor.parameters);\n      }\n      // Otherwise use controller parameters\n      else if (this.controller.parameters) {\n        parameters = _objectSpread({}, this.controller.parameters);\n      }\n      var state = {\n        parameters: parameters\n      };\n\n      // If we're not at the end of history, remove future states\n      if (shapeHistory.currentIndex < shapeHistory.states.length - 1) {\n        shapeHistory.states = shapeHistory.states.slice(0, shapeHistory.currentIndex + 1);\n      }\n\n      // Add new state\n      shapeHistory.states.push(state);\n      shapeHistory.currentIndex++;\n\n      // Remove oldest state if exceeding max size\n      if (shapeHistory.states.length > this.maxHistorySize) {\n        shapeHistory.states.shift();\n        shapeHistory.currentIndex--;\n      }\n      this.updateButtonsState();\n    }\n  }, {\n    key: \"restoreState\",\n    value: function restoreState(state) {\n      if (!state) return;\n      try {\n        this.isRestoring = true;\n\n        // Only restore parameters, not the shape selection\n        this.controller.parameters = _objectSpread({}, state.parameters);\n\n        // Check if we should update through editor or controller\n        if (this.controller.editor && this.controller.editor.editorOpen) {\n          // If editor is open, update through editor\n          this.controller.editor.parameters = _objectSpread({}, state.parameters);\n          this.controller.editor.updateShape();\n        } else {\n          // Otherwise use controller's method\n          this.controller.updateShape();\n        }\n      } finally {\n        this.isRestoring = false;\n      }\n    }\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      if (!this.currentShapeName) return;\n      var shapeHistory = this.historyByShape[this.currentShapeName];\n      if (!shapeHistory || shapeHistory.currentIndex <= 0) return;\n      shapeHistory.currentIndex--;\n      this.restoreState(shapeHistory.states[shapeHistory.currentIndex]);\n      this.updateButtonsState();\n    }\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      if (!this.currentShapeName) return;\n      var shapeHistory = this.historyByShape[this.currentShapeName];\n      if (!shapeHistory || shapeHistory.currentIndex >= shapeHistory.states.length - 1) return;\n      shapeHistory.currentIndex++;\n      this.restoreState(shapeHistory.states[shapeHistory.currentIndex]);\n      this.updateButtonsState();\n    }\n  }, {\n    key: \"updateButtonsState\",\n    value: function updateButtonsState() {\n      var undoBtn = document.getElementById('undoBtn');\n      var redoBtn = document.getElementById('redoBtn');\n      if (!this.currentShapeName) {\n        if (undoBtn) undoBtn.disabled = true;\n        if (redoBtn) redoBtn.disabled = true;\n        return;\n      }\n      var shapeHistory = this.historyByShape[this.currentShapeName];\n      if (undoBtn) {\n        undoBtn.disabled = !shapeHistory || shapeHistory.currentIndex <= 0;\n      }\n      if (redoBtn) {\n        redoBtn.disabled = !shapeHistory || shapeHistory.currentIndex >= shapeHistory.states.length - 1;\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.currentShapeName) {\n        this.historyByShape[this.currentShapeName] = {\n          states: [],\n          currentIndex: -1\n        };\n        this.updateButtonsState();\n      }\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShapeHistory);\n\n//# sourceURL=webpack://generative-shapes/./src/ShapeHistory.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\n/* harmony import */ var _shapesRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shapesRegistry */ \"./src/shapesRegistry.js\");\n/* harmony import */ var _shapes_Shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shapes/Shape */ \"./src/shapes/Shape.js\");\n/* harmony import */ var _ShapeEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ShapeEditor */ \"./src/ShapeEditor.js\");\n/* harmony import */ var _ShapeHistory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ShapeHistory */ \"./src/ShapeHistory.js\");\n/* harmony import */ var _ShapeFavorites__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShapeFavorites */ \"./src/ShapeFavorites.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n\nvar ShapeApp = /*#__PURE__*/function () {\n  function ShapeApp() {\n    _classCallCheck(this, ShapeApp);\n    // State variables\n    this.selectedShape = null;\n    this.currentCategory = 'all'; // Currently selected category\n    this.currentSearchTerm = '';\n    this.gridColumns = 5; // Default grid size (columns)\n    this.lastSelectedShapeId = null; // To remember which shape was selected\n    this.gridState = {\n      scrollY: 0,\n      shapesVisible: [] // Will store IDs of visible shapes before editor opens\n    };\n    this.lastClickedShapeIndex = -1; // Track position in the grid\n    this.lastClickedRow = -1; // Approximate row in the grid\n    this.lastClickedColumn = -1; // Approximate column in the grid\n\n    this.parameters = {}; // Initialize parameters object\n\n    // Animation state\n    this.animationState = {};\n    this.animationFrameId = null;\n    this.currentlyHoveredId = null;\n    this.globalAnimationTime = 0;\n    this.ANIMATION_DENSITY = 0.1; // Only ~10% of shapes animate at once\n    this.animationEnabled = true;\n\n    // Make Shape class available to the editor\n    this.Shape = _shapes_Shape__WEBPACK_IMPORTED_MODULE_2__.Shape;\n    this.shapes = _shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n\n    // Initialize modules\n    this.history = new _ShapeHistory__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this);\n    this.favorites = new _ShapeFavorites__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this);\n    this.editor = new _ShapeEditor__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n\n    // Bind methods\n    this.renderShapeGrid = this.renderShapeGrid.bind(this);\n    this.saveGridState = this.saveGridState.bind(this);\n    this.returnToGrid = this.returnToGrid.bind(this);\n    this.showShapeEditor = this.showShapeEditor.bind(this);\n    this.updateShape = this.updateShape.bind(this);\n  }\n\n  /**\n   * Initialize the application when DOM is loaded\n   */\n  return _createClass(ShapeApp, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n      // Create UI controls\n      this.createMinimalHeader();\n      this.createCategoryFilters();\n      this.scrollSelectedCategoryIntoView();\n\n      // Render initial grid\n      this.renderShapeGrid();\n\n      // Initialize favorites\n      this.favorites.init();\n\n      // Handle window resize in a simple way\n      window.addEventListener('resize', function () {\n        if (!_this.selectedShape) {\n          _this.renderShapeGrid(true, true); // Keep scroll, refresh grid only\n        }\n      });\n\n      // Start the animation loop\n      if (this.animationEnabled) {\n        this.startAnimationLoop();\n      }\n\n      // Add global click handler as a fallback\n      document.addEventListener('click', this.handleGlobalClick.bind(this), true);\n    }\n\n    /**\n     * Update the shape display\n     * This method is used by ShapeHistory when restoring states\n     */\n  }, {\n    key: \"updateShape\",\n    value: function updateShape() {\n      if (this.editor && this.editor.updateShape) {\n        // Make sure we transfer the parameters to the editor\n        if (this.parameters && Object.keys(this.parameters).length > 0) {\n          this.editor.parameters = _objectSpread({}, this.parameters);\n        }\n        this.editor.updateShape();\n      }\n    }\n\n    // 1. Create the category filter pills\n  }, {\n    key: \"createCategoryFilters\",\n    value: function createCategoryFilters() {\n      var _this2 = this;\n      // Define categories array with all categories\n      var categories = [{\n        id: 'all',\n        name: 'All Shapes'\n      }, {\n        id: 'basic',\n        name: 'Basic Shapes'\n      }, {\n        id: 'stars',\n        name: 'Stars & Bursts'\n      }, {\n        id: 'grids',\n        name: 'Grids & Patterns'\n      }, {\n        id: 'curved',\n        name: 'Curved & Waves'\n      }, {\n        id: 'circles',\n        name: 'Circles & Ellipses'\n      }, {\n        id: 'layered',\n        name: 'Layered & Nested'\n      }, {\n        id: 'nature',\n        name: 'Nature-Inspired'\n      }, {\n        id: 'rounded',\n        name: 'Rounded Forms'\n      }];\n\n      // Try to get saved category selection\n      var initialSelectedCategory = 'all';\n      this.currentCategory = null;\n      try {\n        var savedCategory = localStorage.getItem('selectedCategory');\n        if (savedCategory) {\n          initialSelectedCategory = savedCategory;\n        }\n\n        // Set the current category immediately based on what was loaded from localStorage\n        this.currentCategory = initialSelectedCategory === 'all' ? null : initialSelectedCategory;\n        console.log(\"Loaded from localStorage: \".concat(initialSelectedCategory, \", set currentCategory to \").concat(this.currentCategory));\n      } catch (e) {\n        console.warn('Could not retrieve saved category from localStorage', e);\n      }\n\n      // Create a container for all category pills\n      var filterContainer = document.createElement('div');\n      filterContainer.className = 'category-pills-container';\n      filterContainer.id = 'category-filters-container'; // Add ID for easy reference\n\n      // Add styles to hide scrollbar\n      filterContainer.style.scrollbarWidth = 'none'; // Firefox\n      filterContainer.style.msOverflowStyle = 'none'; // IE and Edge\n\n      // Generate SVG icons for each category\n      var categoryIcons = {\n        'all': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <rect x=\\\"3\\\" y=\\\"3\\\" width=\\\"4\\\" height=\\\"4\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n        <rect x=\\\"9\\\" y=\\\"3\\\" width=\\\"4\\\" height=\\\"4\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n        <rect x=\\\"3\\\" y=\\\"9\\\" width=\\\"4\\\" height=\\\"4\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n        <rect x=\\\"9\\\" y=\\\"9\\\" width=\\\"4\\\" height=\\\"4\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n      </svg>\",\n        'basic': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <rect x=\\\"3\\\" y=\\\"3\\\" width=\\\"10\\\" height=\\\"10\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n      </svg>\",\n        'stars': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <path d=\\\"M8 2L9.5 5.5L13.5 6L10.75 8.75L11.5 13L8 11L4.5 13L5.25 8.75L2.5 6L6.5 5.5L8 2Z\\\" stroke=\\\"currentColor\\\"/>\\n      </svg>\",\n        'grids': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <line x1=\\\"5.5\\\" y1=\\\"3\\\" x2=\\\"5.5\\\" y2=\\\"13\\\" stroke=\\\"currentColor\\\"/>\\n        <line x1=\\\"10.5\\\" y1=\\\"3\\\" x2=\\\"10.5\\\" y2=\\\"13\\\" stroke=\\\"currentColor\\\"/>\\n        <line x1=\\\"3\\\" y1=\\\"5.5\\\" x2=\\\"13\\\" y2=\\\"5.5\\\" stroke=\\\"currentColor\\\"/>\\n        <line x1=\\\"3\\\" y1=\\\"10.5\\\" x2=\\\"13\\\" y2=\\\"10.5\\\" stroke=\\\"currentColor\\\"/>\\n      </svg>\",\n        'curved': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <path d=\\\"M3 12C6 12 10 4 13 4\\\" stroke=\\\"currentColor\\\" stroke-width=\\\"1.5\\\" stroke-linecap=\\\"round\\\"/>\\n      </svg>\",\n        'circles': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <circle cx=\\\"8\\\" cy=\\\"8\\\" r=\\\"5\\\" stroke=\\\"currentColor\\\"/>\\n      </svg>\",\n        'layered': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <rect x=\\\"4\\\" y=\\\"4\\\" width=\\\"8\\\" height=\\\"8\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n        <rect x=\\\"6\\\" y=\\\"6\\\" width=\\\"8\\\" height=\\\"8\\\" rx=\\\"1\\\" stroke=\\\"currentColor\\\"/>\\n      </svg>\",\n        'nature': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <path d=\\\"M8 13V5M8 5C6.5 3.5 4 3 4 5C4 7 8 8 8 5Z M8 5C9.5 3.5 12 3 12 5C12 7 8 8 8 5Z\\\" stroke=\\\"currentColor\\\" stroke-linecap=\\\"round\\\"/>\\n      </svg>\",\n        'polygons': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <path d=\\\"M8 3L12.5 5.5L12.5 10.5L8 13L3.5 10.5L3.5 5.5L8 3Z\\\" stroke=\\\"currentColor\\\"/>\\n      </svg>\",\n        'rounded': \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <rect x=\\\"3\\\" y=\\\"3\\\" width=\\\"10\\\" height=\\\"10\\\" rx=\\\"3\\\" stroke=\\\"currentColor\\\"/>\\n      </svg>\"\n      };\n\n      // Create all category pills\n      categories.forEach(function (category) {\n        var pillBtn = document.createElement('button');\n        pillBtn.className = 'category-pill';\n        pillBtn.dataset.categoryId = category.id;\n\n        // Determine if this pill should be selected initially - FIXED to use initialSelectedCategory\n        var isSelected = category.id === initialSelectedCategory;\n\n        // Set inline styles for the pill\n        pillBtn.style.display = 'flex';\n        pillBtn.style.alignItems = 'center';\n        pillBtn.style.gap = '6px';\n        pillBtn.style.flex = '0 0 auto'; // Don't allow growth or shrink\n        pillBtn.style.whiteSpace = 'nowrap'; // Prevent text wrapping\n        pillBtn.style.backgroundColor = isSelected ? 'white' : 'rgb(26, 26, 26)';\n        pillBtn.style.color = isSelected ? '#000' : '#D9D9D9';\n        pillBtn.style.border = 'none';\n        pillBtn.style.borderRadius = '50px';\n        pillBtn.style.padding = '8px 16px';\n        pillBtn.style.fontSize = '14px';\n        pillBtn.style.fontWeight = '500';\n        pillBtn.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n        pillBtn.style.cursor = 'pointer';\n        pillBtn.style.minWidth = 'fit-content';\n\n        // Add category icon\n        var iconSpan = document.createElement('span');\n        iconSpan.style.display = 'flex';\n        iconSpan.style.alignItems = 'center';\n        iconSpan.style.justifyContent = 'center';\n        iconSpan.style.width = '16px';\n        iconSpan.style.height = '16px';\n\n        // Set icon from our map or use default\n        iconSpan.innerHTML = categoryIcons[category.id] || categoryIcons['all'];\n\n        // Set color for the SVG\n        iconSpan.style.color = isSelected ? '#000' : '#D9D9D9';\n        pillBtn.appendChild(iconSpan);\n\n        // Add category name\n        var textSpan = document.createElement('span');\n        textSpan.textContent = category.name;\n        textSpan.style.fontFamily = \"'Menlo', 'Monaco', 'Courier New', monospace\";\n        pillBtn.appendChild(textSpan);\n\n        // Add selection state data attribute\n        pillBtn.dataset.selected = isSelected ? 'true' : 'false';\n        if (isSelected) {\n          pillBtn.classList.add('selected');\n        }\n\n        // Add click handler\n        pillBtn.addEventListener('click', function (e) {\n          // Get the category ID directly from the button's dataset\n          var clickedCategoryId = pillBtn.dataset.categoryId;\n          console.log(\"Pill clicked: \".concat(clickedCategoryId));\n\n          // First manually reset all pills to ensure clean state\n          document.querySelectorAll('.category-pill').forEach(function (p) {\n            p.style.setProperty('background-color', 'rgb(26, 26, 26)', 'important');\n            p.style.setProperty('color', '#D9D9D9', 'important');\n            p.dataset.selected = 'false'; // Mark as not selected\n            var pIconSpan = p.querySelector('span:first-child');\n            if (pIconSpan) pIconSpan.style.setProperty('color', '#D9D9D9', 'important');\n          });\n\n          // Then set only this pill to white\n          console.log(\"Setting \".concat(clickedCategoryId, \" to white\"));\n          pillBtn.style.setProperty('background-color', 'white', 'important');\n          pillBtn.style.setProperty('color', '#000', 'important');\n          pillBtn.dataset.selected = 'true'; // Mark as selected\n          var iconSpan = pillBtn.querySelector('span:first-child');\n          if (iconSpan) iconSpan.style.setProperty('color', '#000', 'important');\n\n          // Finally update the app state and filter\n          _this2.currentCategory = clickedCategoryId === 'all' ? null : clickedCategoryId;\n\n          // Save selection\n          try {\n            localStorage.setItem('selectedCategory', clickedCategoryId);\n          } catch (e) {\n            console.warn('Could not save category selection to localStorage', e);\n          }\n\n          // Re-render the grid\n          _this2.renderShapeGrid(true);\n          return false;\n        });\n\n        // Hover effects (only for non-selected pills)\n        pillBtn.addEventListener('mouseover', function () {\n          // Only apply hover effects if not selected\n          if (pillBtn.dataset.selected !== 'true') {\n            pillBtn.style.backgroundColor = 'rgb(32, 32, 32)';\n          }\n        });\n        pillBtn.addEventListener('mouseout', function () {\n          // Only reset styles if not selected\n          if (pillBtn.dataset.selected !== 'true') {\n            pillBtn.style.backgroundColor = 'rgb(26, 26, 26)';\n            pillBtn.style.transform = 'translateY(0)';\n            pillBtn.style.boxShadow = '0 1px 2px rgba(0,0,0,0.15)';\n          } else {\n            // Ensure selected pill keeps its selected style after hover\n            pillBtn.style.backgroundColor = 'white';\n            pillBtn.style.color = '#000';\n            pillBtn.style.transform = 'translateY(0)';\n            pillBtn.style.boxShadow = '0 1px 3px rgba(0,0,0,0.2)';\n\n            // Also ensure the icon maintains correct color\n            var _iconSpan = pillBtn.querySelector('span:first-child');\n            if (_iconSpan) {\n              _iconSpan.style.color = '#000';\n            }\n          }\n        });\n        filterContainer.appendChild(pillBtn);\n      });\n\n      // Insert the filter container after the header\n      var header = document.getElementById('main-header');\n      if (header && header.nextSibling) {\n        document.body.insertBefore(filterContainer, header.nextSibling);\n      } else {\n        var grid = document.getElementById('grid');\n        if (grid) {\n          document.body.insertBefore(filterContainer, grid);\n        } else {\n          document.body.appendChild(filterContainer);\n        }\n      }\n    }\n\n    // Handle category selection with updated styling for SVG icons\n    /**\n    * Fixed selectCategoryPill function to properly handle selection styling\n    */\n  }, {\n    key: \"selectCategoryPill\",\n    value:\n    // 4. Handle category selection\n    function selectCategoryPill(categoryId) {\n      // Update UI to show selected category\n      var allPills = document.querySelectorAll('.category-pill');\n      allPills.forEach(function (pill) {\n        if (pill.dataset.categoryId === categoryId) {\n          // Selected state\n          pill.classList.add('selected');\n          pill.style.backgroundColor = 'white';\n          pill.style.color = '#333';\n          pill.style.transform = 'translateY(0)';\n          pill.style.boxShadow = '0 2px 4px rgba(0,0,0,0.15)';\n        } else {\n          // Unselected state\n          pill.classList.remove('selected');\n          pill.style.backgroundColor = '#eaeaea';\n          pill.style.color = '#555';\n          pill.style.transform = 'translateY(0)';\n          pill.style.boxShadow = '0 1px 2px rgba(0,0,0,0.1)';\n        }\n      });\n\n      // Update the currently selected category\n      this.currentCategory = categoryId === 'all' ? null : categoryId;\n\n      // Re-render the grid with the new filter\n      this.renderShapeGrid(true); // Keep scroll position\n    }\n\n    /**\n     * Handle global click events (fallback)\n     */\n  }, {\n    key: \"createCategoryPill\",\n    value:\n    // 2. Create a single category pill button\n    function createCategoryPill(category) {\n      var _this3 = this;\n      var pillBtn = document.createElement('button');\n      pillBtn.className = 'category-pill';\n      pillBtn.dataset.categoryId = category.id;\n\n      // Set inline styles for the pill\n      pillBtn.style.display = 'flex';\n      pillBtn.style.alignItems = 'center';\n      pillBtn.style.gap = '6px';\n      pillBtn.style.backgroundColor = category.id === 'all' ? 'white' : '#eaeaea';\n      pillBtn.style.color = category.id === 'all' ? '#333' : '#555';\n      pillBtn.style.border = 'none';\n      pillBtn.style.borderRadius = '50px';\n      pillBtn.style.padding = '8px 16px';\n      pillBtn.style.fontSize = '14px';\n      pillBtn.style.fontWeight = '500';\n      pillBtn.style.cursor = 'pointer';\n      pillBtn.style.transition = 'all 0.2s ease';\n      pillBtn.style.minWidth = 'fit-content';\n      pillBtn.style.boxShadow = '0 1px 2px rgba(0,0,0,0.1)';\n\n      // Create icon span if an icon is provided\n      if (category.icon) {\n        var iconSpan = document.createElement('span');\n        iconSpan.innerHTML = category.icon;\n        iconSpan.style.display = 'flex';\n        iconSpan.style.alignItems = 'center';\n        iconSpan.style.justifyContent = 'center';\n        pillBtn.appendChild(iconSpan);\n      } else {\n        // Generate a simple icon based on category name\n        var _iconSpan2 = this.generateCategoryIcon(category);\n        if (_iconSpan2) {\n          pillBtn.appendChild(_iconSpan2);\n        }\n      }\n\n      // Add category name\n      var textSpan = document.createElement('span');\n      textSpan.textContent = category.name;\n      pillBtn.appendChild(textSpan);\n\n      // Add click handler\n      pillBtn.addEventListener('click', function () {\n        _this3.selectCategoryPill(category.id);\n      });\n\n      // Hover effects\n      pillBtn.addEventListener('mouseover', function () {\n        if (!pillBtn.classList.contains('selected')) {\n          pillBtn.style.backgroundColor = '#f0f0f0';\n        }\n      });\n      pillBtn.addEventListener('mouseout', function () {\n        if (!pillBtn.classList.contains('selected')) {\n          pillBtn.style.backgroundColor = '#eaeaea';\n        }\n      });\n      return pillBtn;\n    }\n  }, {\n    key: \"handleGlobalClick\",\n    value: function handleGlobalClick(e) {\n      var _this4 = this;\n      // Check if the click was on or inside a shape-container\n      var target = e.target;\n      while (target != null) {\n        if (target.classList && target.classList.contains('shape-container')) {\n          var shapeName = target.dataset.shapeName;\n          var shapeId = target.id;\n          if (shapeName && shapeId) {\n            // Find the index in the filtered shapes\n            var shapeNames = Object.keys(_shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n            var filteredShapes = shapeNames.filter(function (name) {\n              if (!_this4.currentSearchTerm) return true;\n              return name.toLowerCase().includes(_this4.currentSearchTerm);\n            });\n            this.lastClickedShapeIndex = filteredShapes.indexOf(shapeName);\n            this.selectedShape = shapeName;\n            this.lastSelectedShapeId = shapeId;\n            this.saveGridState(shapeId);\n            this.showShapeEditor(shapeName);\n\n            // Stop event propagation\n            e.stopPropagation();\n            return;\n          }\n          break;\n        }\n        target = target.parentElement;\n      }\n    }\n\n    /**\n     * Create ultra-minimal header with search and zoom controls\n     */\n  }, {\n    key: \"createMinimalHeader\",\n    value: function createMinimalHeader() {\n      var _this5 = this;\n      var header = document.createElement('header');\n      header.className = 'header';\n      header.id = 'main-header';\n\n      // Create search input (minimalist)\n      var searchInput = document.createElement('input');\n      searchInput.type = 'text';\n      searchInput.placeholder = 'Search';\n      searchInput.className = 'search-input';\n      searchInput.addEventListener('input', function (e) {\n        _this5.currentSearchTerm = e.target.value.toLowerCase();\n        _this5.renderShapeGrid(true); // Keep scroll position\n      });\n\n      // Create minimal zoom controls\n      var zoomControls = document.createElement('div');\n      zoomControls.className = 'zoom-controls';\n      var zoomOutBtn = document.createElement('button');\n      zoomOutBtn.textContent = '';\n      zoomOutBtn.className = 'zoom-btn';\n      zoomOutBtn.title = 'Zoom out';\n      zoomOutBtn.addEventListener('click', function () {\n        // Only change grid size if we're in the grid view\n        if (!_this5.selectedShape) {\n          if (_this5.gridColumns < 8) {\n            _this5.gridColumns++;\n            _this5.renderShapeGrid(true); // Keep scroll\n          }\n        }\n      });\n      var zoomInBtn = document.createElement('button');\n      zoomInBtn.textContent = '+';\n      zoomInBtn.className = 'zoom-btn';\n      zoomInBtn.title = 'Zoom in';\n      zoomInBtn.addEventListener('click', function () {\n        // Only change grid size if we're in the grid view\n        if (!_this5.selectedShape) {\n          if (_this5.gridColumns > 1) {\n            _this5.gridColumns--;\n            _this5.renderShapeGrid(true); // Keep scroll\n          }\n        }\n      });\n\n      // Add to zoom controls\n      zoomControls.appendChild(zoomOutBtn);\n      zoomControls.appendChild(zoomInBtn);\n\n      // Create bookmarks button - FIX: Keep className as bookmark-btn\n      var bookmarkBtn = document.createElement('button');\n      bookmarkBtn.id = 'bookmarkBtn';\n      bookmarkBtn.className = 'bookmark-btn'; // Don't overwrite this with zoom-btn\n      bookmarkBtn.title = 'Saved Shapes';\n      bookmarkBtn.innerHTML = \"\\n             <svg width=\\\"30\\\" height=\\\"30\\\" viewBox=\\\"0 0 30 30\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n<path d=\\\"M10 10V22.7586C10 22.8477 10.1077 22.8923 10.1707 22.8293L14.9293 18.0707C14.9683 18.0317 15.0317 18.0317 15.0707 18.0707L19.8293 22.8293C19.8923 22.8923 20 22.8477 20 22.7586V10C20 9.44772 19.5523 9 19 9H11C10.4477 9 10 9.44772 10 10Z\\\" stroke=\\\"#666666\\\" stroke-width=\\\"1.5\\\"/>\\n</svg>\\n\\n    \";\n      // Apply styles directly\n      bookmarkBtn.style.background = 'transparent';\n      bookmarkBtn.style.border = 'none';\n      bookmarkBtn.style.borderRadius = '50%';\n      bookmarkBtn.style.width = '25px';\n      bookmarkBtn.style.height = '25px';\n      bookmarkBtn.style.display = 'flex';\n      bookmarkBtn.style.alignItems = 'center';\n      bookmarkBtn.style.justifyContent = 'center';\n      bookmarkBtn.style.cursor = 'pointer';\n      bookmarkBtn.style.color = '#666666';\n\n      // Add elements to header\n      header.appendChild(searchInput);\n\n      // Add bookmark button between search and zoom controls\n      var actionsContainer = document.createElement('div');\n      actionsContainer.className = 'header-actions';\n      actionsContainer.style.display = 'flex';\n      actionsContainer.style.gap = '8px';\n      actionsContainer.appendChild(bookmarkBtn);\n      actionsContainer.appendChild(zoomControls);\n      header.appendChild(actionsContainer);\n\n      // Add to document\n      document.body.insertBefore(header, document.getElementById('grid'));\n      return header;\n    }\n\n    /**\n     * Get all currently visible shapes\n     */\n  }, {\n    key: \"getVisibleShapes\",\n    value: function getVisibleShapes() {\n      var shapes = Array.from(document.querySelectorAll('.shape-container'));\n      return shapes.filter(function (shape) {\n        var rect = shape.getBoundingClientRect();\n        return rect.top < window.innerHeight && rect.bottom > 0;\n      });\n    }\n\n    /**\n     * Start the animation loop for interpolation\n     */\n  }, {\n    key: \"startAnimationLoop\",\n    value: function startAnimationLoop() {\n      var _this6 = this;\n      if (!this.animationEnabled) return;\n\n      // Cancel any existing animation frame\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n      }\n\n      // Keep track of the last time for smooth animation\n      var lastTime = performance.now();\n\n      // The animation loop\n      var _animate = function animate(currentTime) {\n        // Exit if animation was disabled\n        if (!_this6.animationEnabled) return;\n\n        // Calculate time delta in seconds\n        var deltaTime = (currentTime - lastTime) / 1000;\n        lastTime = currentTime;\n\n        // Update global animation time (useful for wave-like effects)\n        _this6.globalAnimationTime += deltaTime;\n\n        // Skip if in editor mode\n        if (!_this6.selectedShape) {\n          try {\n            // Get visible shapes\n            var visibleShapes = _this6.getVisibleShapes();\n\n            // Update each visible shape's animation state\n            visibleShapes.forEach(function (shape) {\n              try {\n                var shapeId = shape.id;\n                var shapeName = shape.dataset.shapeName;\n\n                // Then update the shape animation\n                _this6.updateShapeAnimation(shape, deltaTime);\n              } catch (error) {\n                console.error(\"Error animating shape:\", error);\n                // Don't disable all animation for one shape's error\n              }\n            });\n          } catch (error) {\n            console.error(\"Animation loop error:\", error);\n          }\n        }\n\n        // Continue the animation loop\n        _this6.animationFrameId = requestAnimationFrame(_animate);\n      };\n\n      // Start the animation\n      this.animationFrameId = requestAnimationFrame(_animate);\n    }\n\n    /**\n     * Initialize animation state for a shape\n     */\n  }, {\n    key: \"initAnimationState\",\n    value: function initAnimationState(shapeName, shapeId) {\n      if (!this.animationEnabled) return null;\n\n      // Get the shape class\n      var ShapeClass = _shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"][shapeName];\n      if (!ShapeClass) return null;\n      try {\n        // Create a shape instance to get default parameters\n        var shapeInstance = new ShapeClass();\n\n        // Get parameters for this shape type\n        var classParameters = ShapeClass.parameters || {};\n        var allParameters = _objectSpread(_objectSpread({}, _shapes_Shape__WEBPACK_IMPORTED_MODULE_2__.Shape.parameters), classParameters);\n\n        // Create animation state object\n        var state = {\n          shapeName: shapeName,\n          isAnimating: false,\n          shouldAnimate: false,\n          transitionTime: 3.0,\n          progress: 0,\n          hovering: false,\n          returningToDefault: false,\n          stopAfterDefault: false,\n          currentParams: {},\n          targetParams: {},\n          initialParams: {},\n          defaultParams: {}\n        };\n\n        // Set up parameters\n        Object.entries(allParameters).forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            param = _ref2[0],\n            config = _ref2[1];\n          if (typeof shapeInstance[param] === 'number' || config.options) {\n            state.currentParams[param] = shapeInstance[param];\n            state.targetParams[param] = shapeInstance[param];\n            state.initialParams[param] = shapeInstance[param];\n            state.defaultParams[param] = shapeInstance[param];\n          }\n        });\n        return state;\n      } catch (error) {\n        console.error(\"Error initializing animation state for shape \".concat(shapeName, \":\"), error);\n        return null;\n      }\n    }\n\n    /**\n     * Check if a parameter should not be interpolated on hover\n     */\n  }, {\n    key: \"isNonInterpolatedParam\",\n    value: function isNonInterpolatedParam(param) {\n      // Convert parameter name to lowercase for case-insensitive matching\n      var paramLower = param.toLowerCase();\n\n      // Exact matches for parameters that should never be interpolated during hover\n      // These are structural parameters that would cause layout shifts\n      var exactNoInterpolateParams = ['rows', 'columns', 'randomlayout', 'count', 'resolution', 'value'];\n      if (exactNoInterpolateParams.includes(paramLower) || paramLower.includes('linecount')) {\n        return true;\n      }\n\n      // Special case: these parameters should be interpolated despite containing excluded keywords\n      // This allows BrickWall's cornerRadius and gapSize to animate\n      var specialInterpolateParams = ['cornerradius', 'gapsize'];\n      if (specialInterpolateParams.includes(paramLower)) {\n        return false;\n      }\n\n      // General exclusions (keeping the original logic for other parameters)\n      return paramLower.includes('radius') || paramLower.includes('size') || paramLower.includes('thickness') || paramLower.includes('segments');\n    }\n\n    /**\n     * Set a new target state for shape interpolation\n     */\n  }, {\n    key: \"setNewTargetState\",\n    value: function setNewTargetState(shapeName, shapeId) {\n      var _this7 = this;\n      var moreRandomness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (!this.animationEnabled) return;\n\n      // Initialize animation state if it doesn't exist\n      if (!this.animationState[shapeId]) {\n        this.animationState[shapeId] = this.initAnimationState(shapeName, shapeId);\n        if (!this.animationState[shapeId]) return;\n      }\n      var state = this.animationState[shapeId];\n\n      // IMPORTANT: If we were returning to default and now we're hovering again,\n      // cancel the return animation completely\n      if (state.returningToDefault && state.hovering) {\n        state.returningToDefault = false;\n        state.stopAfterDefault = false;\n      }\n\n      // Get the shape class\n      var ShapeClass = _shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"][shapeName];\n      if (!ShapeClass) return;\n      try {\n        // Get parameters for this shape type\n        var classParameters = ShapeClass.parameters || {};\n        var allParameters = _objectSpread(_objectSpread({}, _shapes_Shape__WEBPACK_IMPORTED_MODULE_2__.Shape.parameters), classParameters);\n\n        // Save current params as initial for smooth transition\n        Object.keys(state.currentParams).forEach(function (param) {\n          state.initialParams[param] = state.currentParams[param];\n        });\n\n        // Set new random target values for each parameter\n        Object.entries(allParameters).forEach(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n            param = _ref4[0],\n            config = _ref4[1];\n          // Special handling for boolean parameters or parameters with options\n          if (config.options) {\n            // Keep options parameters stable during animation to prevent structure changes\n            state.targetParams[param] = state.currentParams[param];\n          }\n          // Only animate numeric parameters with min/max\n          else if (typeof state.currentParams[param] === 'number' && config.min !== undefined && config.max !== undefined) {\n            if (state.hovering && _this7.isNonInterpolatedParam(param)) {\n              // Keep the current value for these parameters during hover\n              state.targetParams[param] = state.currentParams[param];\n            } else {\n              // For other parameters or non-hover animations, generate a new random target value\n              var min = config.min;\n              var max = config.max;\n\n              // More dramatic changes for hover animations if requested\n              if (moreRandomness && state.hovering) {\n                // Generate a more extreme value - closer to min or max\n                var extremeness = 0.7; // How close to push toward min/max\n                var randomChoice = Math.random();\n                if (randomChoice < 0.5) {\n                  // Push toward min\n                  state.targetParams[param] = min + (max - min) * (1 - extremeness) * Math.random();\n                } else {\n                  // Push toward max\n                  state.targetParams[param] = max - (max - min) * (1 - extremeness) * Math.random();\n                }\n              } else {\n                // Normal random value\n                state.targetParams[param] = min + Math.random() * (max - min);\n              }\n            }\n          }\n        });\n\n        // Reset progress and mark as animating\n        state.progress = 0;\n        state.isAnimating = true;\n\n        // Set transition time - faster for hovered shapes\n        state.transitionTime = state.hovering ? 0.3 : 2.0; // FAST: Changed from 0.6 to 0.3 for hover\n\n        // Store animation type for easing selection\n        state.animationType = state.hovering ? 'hoverIn' : state.returningToDefault ? 'hoverOut' : 'randomAnimation';\n      } catch (error) {\n        console.error(\"Error setting target state for shape \".concat(shapeName, \":\"), error);\n        if (this.animationState[shapeId]) {\n          this.animationState[shapeId].isAnimating = false;\n          this.animationState[shapeId].shouldAnimate = false;\n        }\n      }\n    }\n\n    /**\n     * Update animation state and render the shape\n     */\n  }, {\n    key: \"updateShapeAnimation\",\n    value: function updateShapeAnimation(shapeContainer, deltaTime) {\n      var _this8 = this;\n      if (!this.animationEnabled) return;\n      var shapeId = shapeContainer.id;\n      var shapeName = shapeContainer.dataset.shapeName;\n\n      // Skip if no animation state\n      if (!this.animationState[shapeId]) {\n        // Initialize state on first update\n        this.animationState[shapeId] = this.initAnimationState(shapeName, shapeId);\n        if (!this.animationState[shapeId]) return;\n      }\n      var state = this.animationState[shapeId];\n\n      // Skip if not animating or shouldn't be animating\n      if (!state.isAnimating || !state.shouldAnimate && !state.hovering && !state.returningToDefault) return;\n\n      // Get the shape class\n      var ShapeClass = _shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"][shapeName];\n      if (!ShapeClass) return;\n      try {\n        // Update progress\n        state.progress += deltaTime / state.transitionTime;\n\n        // When animation completes\n        if (state.progress >= 1) {\n          // Set current parameters to target\n          Object.keys(state.targetParams).forEach(function (param) {\n            state.currentParams[param] = state.targetParams[param];\n          });\n\n          // Check if we were returning to default state\n          if (state.returningToDefault) {\n            // Clear the returning flag\n            state.returningToDefault = false;\n\n            // If we should stop animation after returning to default\n            if (state.stopAfterDefault) {\n              state.isAnimating = false;\n              state.stopAfterDefault = false;\n            } else {\n              state.isAnimating = false; // Always stop after returning to default\n            }\n          }\n          // Single hover animation complete - stop animating\n          else if (state.hovering && state.singleHoverAnimation) {\n            state.isAnimating = false; // Stop after one transition\n          }\n          // Normal animation completion\n          else if (state.hovering || state.shouldAnimate) {\n            // Only start new animation if it's not a single hover animation\n            if (!state.singleHoverAnimation) {\n              this.setNewTargetState(shapeName, shapeId);\n            } else {\n              state.isAnimating = false; // Stop after one hover animation\n            }\n          } else {\n            // Otherwise, stop animating\n            state.isAnimating = false;\n          }\n        } else {\n          // Calculate interpolated values for each parameter\n          Object.keys(state.targetParams).forEach(function (param) {\n            // Get parameter configuration\n            var classParameters = ShapeClass.parameters || {};\n            var allParameters = _objectSpread(_objectSpread({}, _shapes_Shape__WEBPACK_IMPORTED_MODULE_2__.Shape.parameters), classParameters);\n            var paramConfig = allParameters[param];\n\n            // Special handling based on parameter type and animation state\n            if (paramConfig && paramConfig.options) {\n              // Don't interpolate options parameters, switch immediately\n              state.currentParams[param] = state.initialParams[param];\n            }\n            // Special handling for structural parameters during hover\n            else if (!state.returningToDefault && _this8.isNonInterpolatedParam(param) && state.hovering) {\n              // Keep structural parameters fixed during hover\n              if (param.toLowerCase().includes('rows') || param.toLowerCase().includes('columns') || param.toLowerCase().includes('count')) {\n                state.currentParams[param] = Math.round(state.initialParams[param]);\n              } else {\n                state.currentParams[param] = state.initialParams[param];\n              }\n            }\n            // Allow all parameters to interpolate when returning to default\n            else {\n              // Use smooth interpolation curve for natural movement\n              var t = _this8.smoothStep(state.progress, state.animationType || 'default');\n\n              // For integer parameters, round the result\n              if (param.toLowerCase().includes('rows') || param.toLowerCase().includes('columns') || param.toLowerCase().includes('count')) {\n                state.currentParams[param] = Math.round(_this8.lerp(state.initialParams[param], state.targetParams[param], t));\n              } else {\n                // Normal interpolation for other params\n                state.currentParams[param] = _this8.lerp(state.initialParams[param], state.targetParams[param], t);\n              }\n            }\n          });\n        }\n\n        // Update the shape in the DOM with the current parameters\n        this.renderInterpolatedShape(shapeName, shapeId, state.currentParams);\n      } catch (error) {\n        console.error(\"Error updating animation for shape \".concat(shapeName, \":\"), error);\n        // Mark animation as failed so we stop trying\n        state.isAnimating = false;\n        state.shouldAnimate = false;\n        state.returningToDefault = false; // Clear this flag if we had an error\n\n        // Try to render the shape with default parameters\n        try {\n          var _ShapeClass = _shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"][shapeName];\n          var shapeInstance = new _ShapeClass();\n          var shapeContent = shapeInstance.generateShape();\n          var svg = shapeContainer.querySelector('svg');\n          if (svg) {\n            var wrapperGroup = svg.querySelector('g');\n            if (wrapperGroup) {\n              wrapperGroup.innerHTML = shapeContent;\n            }\n          }\n        } catch (fallbackError) {\n          console.error(\"Fallback rendering also failed for \".concat(shapeName, \":\"), fallbackError);\n        }\n      }\n    }\n\n    /**\n     * Render a shape with interpolated parameters\n     */\n  }, {\n    key: \"renderInterpolatedShape\",\n    value: function renderInterpolatedShape(shapeName, shapeId, params) {\n      if (!this.animationEnabled) return;\n      try {\n        var ShapeClass = _shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"][shapeName];\n        if (!ShapeClass) return;\n\n        // Create new shape instance with interpolated parameters\n        var interpolatedParams = _objectSpread(_objectSpread({}, params), {}, {\n          seed: 42\n        });\n\n        // For BrickWall and similar shapes with structure-dependent params, ensure integer values\n        if (shapeName === ' ' || shapeName.includes('Grid') || shapeName.includes('Pattern')) {\n          // Ensure rows and columns are integers\n          if (interpolatedParams.rows !== undefined) {\n            interpolatedParams.rows = Math.round(interpolatedParams.rows);\n          }\n          if (interpolatedParams.columns !== undefined) {\n            interpolatedParams.columns = Math.round(interpolatedParams.columns);\n          }\n\n          // Handle any count parameters\n          Object.keys(interpolatedParams).forEach(function (param) {\n            if (param.toLowerCase().includes('count')) {\n              interpolatedParams[param] = Math.round(interpolatedParams[param]);\n            }\n          });\n        }\n        var shapeInstance = new ShapeClass(interpolatedParams);\n\n        // Generate shape content\n        var shapeContent = shapeInstance.generateShape();\n\n        // Find shape container and SVG wrapper group\n        var shapeContainer = document.getElementById(shapeId);\n        if (!shapeContainer) return;\n        var svg = shapeContainer.querySelector('svg');\n        if (!svg) return;\n        var wrapperGroup = svg.querySelector('g');\n        if (!wrapperGroup) return;\n\n        // Update content\n        wrapperGroup.innerHTML = shapeContent;\n      } catch (error) {\n        console.error(\"Error rendering interpolated shape \".concat(shapeName, \":\"), error);\n        try {\n          // Fallback to default shape if animation fails\n          var _ShapeClass2 = _shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"][shapeName];\n          if (!_ShapeClass2) return;\n          var _shapeInstance = new _ShapeClass2();\n          var _shapeContent = _shapeInstance.generateShape();\n          var _shapeContainer = document.getElementById(shapeId);\n          if (!_shapeContainer) return;\n          var _svg = _shapeContainer.querySelector('svg');\n          if (!_svg) return;\n          var _wrapperGroup = _svg.querySelector('g');\n          if (!_wrapperGroup) return;\n\n          // Update with default content\n          _wrapperGroup.innerHTML = _shapeContent;\n        } catch (fallbackError) {\n          console.error(\"Fallback rendering also failed for \".concat(shapeName, \":\"), fallbackError);\n        }\n      }\n    }\n\n    /**\n     * Linear interpolation function\n     */\n  }, {\n    key: \"lerp\",\n    value: function lerp(a, b, t) {\n      return a + (b - a) * t;\n    }\n  }, {\n    key: \"easeOutQuad\",\n    value: function easeOutQuad(t) {\n      return t * (2 - t);\n    }\n  }, {\n    key: \"easeInQuad\",\n    value: function easeInQuad(t) {\n      return t * t;\n    }\n  }, {\n    key: \"easeInOutQuad\",\n    value: function easeInOutQuad(t) {\n      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n    }\n  }, {\n    key: \"easeInOutCubic\",\n    value: function easeInOutCubic(t) {\n      return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n    }\n  }, {\n    key: \"easeOutBack\",\n    value: function easeOutBack(t) {\n      var c1 = 1.70158;\n      var c3 = c1 + 1;\n      return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);\n    }\n\n    /**\n     * Smooth step function for more natural animation\n     */\n  }, {\n    key: \"smoothStep\",\n    value: function smoothStep(t) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n      // Clamp t to 0...1 range\n      t = Math.min(Math.max(t, 0), 1);\n\n      // Select easing based on animation type\n      switch (type) {\n        case 'hoverIn':\n          // FAST: Use faster easing for hover in\n          return 1 - Math.pow(1 - t, 4);\n        case 'hoverOut':\n          return 1 - Math.pow(1 - t, 4);\n        case 'randomAnimation':\n          return this.easeInOutCubic(t);\n        default:\n          return this.easeOutQuad(t);\n      }\n    }\n\n    /**\n     * Setup hover events for a shape\n     */\n  }, {\n    key: \"setupShapeHoverEvents\",\n    value: function setupShapeHoverEvents(shapeContainer, shapeName, shapeId) {\n      var _this9 = this;\n      if (!this.animationEnabled) return;\n      shapeContainer.addEventListener('mouseenter', function () {\n        // Mark as currently hovered\n        _this9.currentlyHoveredId = shapeId;\n\n        // Initialize animation state if needed\n        if (!_this9.animationState[shapeId]) {\n          _this9.animationState[shapeId] = _this9.initAnimationState(shapeName, shapeId);\n        }\n        var state = _this9.animationState[shapeId];\n        if (!state) return;\n\n        // Important: Cancel any ongoing return-to-default animation\n        if (state.returningToDefault) {\n          state.returningToDefault = false;\n          state.stopAfterDefault = false;\n        }\n\n        // Set hover state\n        state.hovering = true;\n\n        // FAST: Much faster hover transition (2x faster than before)\n        state.transitionTime = 0.3; // Was 0.6\n\n        // Important: Set a flag to ensure we only do ONE animation\n        state.singleHoverAnimation = true;\n\n        // Save current params as initial for smooth transition\n        Object.keys(state.currentParams).forEach(function (param) {\n          state.initialParams[param] = state.currentParams[param];\n        });\n\n        // Start a single animation with more dramatic parameter changes\n        _this9.setNewTargetState(shapeName, shapeId, true); // Pass true for more dramatic changes\n      });\n      shapeContainer.addEventListener('mouseleave', function () {\n        // Clear current hover state\n        if (_this9.currentlyHoveredId === shapeId) {\n          _this9.currentlyHoveredId = null;\n        }\n        var state = _this9.animationState[shapeId];\n        if (!state) return;\n\n        // Update animation state\n        state.hovering = false;\n\n        // Clear the single hover animation flag\n        state.singleHoverAnimation = false;\n\n        // Save current params as initial for smooth transition back\n        Object.keys(state.currentParams).forEach(function (param) {\n          state.initialParams[param] = state.currentParams[param];\n        });\n\n        // When mouse leaves, set target parameters to default values\n        Object.keys(state.defaultParams).forEach(function (param) {\n          state.targetParams[param] = state.defaultParams[param];\n        });\n\n        // Reset progress to start the transition back to default\n        state.progress = 0;\n        state.isAnimating = true;\n\n        // Special flag to indicate we're returning to default state\n        state.returningToDefault = true;\n\n        // FAST: Make return transition much faster (2x faster)\n        state.transitionTime = 0.25; // Was 0.5\n\n        // Always stop after returning to default\n        state.stopAfterDefault = true;\n      });\n    }\n\n    /**\n     * Render grid of shapes - simplified approach for stability\n     */\n  }, {\n    key: \"renderShapeGrid\",\n    value: function renderShapeGrid() {\n      var _this10 = this;\n      var keepScroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var isResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      console.log(\"Rendering grid with currentCategory: \".concat(this.currentCategory));\n      var gridContainer = document.getElementById('grid');\n      if (!gridContainer) return;\n\n      // Show main header (search and zoom controls)\n      var header = document.getElementById('main-header');\n      if (header) header.style.display = 'flex';\n\n      // Show category filters if they were hidden\n      var filterContainer = document.getElementById('category-filters-container');\n      if (filterContainer) {\n        filterContainer.style.display = 'flex';\n      }\n\n      // Only clear HTML if this is not just a resize\n      if (!isResize) {\n        // Clear existing content\n        gridContainer.innerHTML = '';\n      }\n\n      // Set class and columns\n      gridContainer.className = 'grid';\n      gridContainer.style.gridTemplateColumns = \"repeat(\".concat(this.gridColumns, \", 1fr)\");\n      gridContainer.style.gap = '20px'; // Increased gap for better spacing\n      gridContainer.style.padding = '20px'; // Add padding around the grid\n      gridContainer.style.backgroundColor = '#000000';\n\n      // Get shapes that match both search and category\n      var shapeNames = Object.keys(_shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n      var filteredShapes = shapeNames.filter(function (name) {\n        // Search term filter\n        var matchesSearch = !_this10.currentSearchTerm || name.toLowerCase().includes(_this10.currentSearchTerm.toLowerCase());\n\n        // Category filter\n        var matchesCategory = true;\n        if (_this10.currentCategory && _this10.currentCategory !== 'all') {\n          // Check if this shape belongs to the selected category\n          // First try using the JSON data if available\n          if (window.shapeCategories && window.shapeCategories.shapesMetadata) {\n            var metadata = window.shapeCategories.shapesMetadata[name];\n            if (metadata && metadata.categories) {\n              matchesCategory = metadata.categories.includes(_this10.currentCategory);\n            }\n          } else {\n            // Fallback to checking if shape name contains category hints\n            var categoryHints = {\n              'basic': ['Box', 'Simple', 'Square', 'Rounded', 'Column'],\n              'stars': ['Star', 'Asterisk', 'Burst', 'Sun', 'Ray', 'Radial'],\n              'grids': ['Grid', 'Pattern', 'Stripe', 'Checker'],\n              'curved': ['Curve', 'Wave', 'Spline', 'Spiral', 'Rhythm'],\n              'circles': ['Circle', 'Ellipse', 'Orbital', 'Ring', 'Sphere', 'Torus'],\n              'layered': ['Layer', 'Nested', 'Stack', 'Concentric'],\n              'nature': ['Leaf', 'Flower', 'Plant', 'Tree', 'Nature', 'Petal', 'Atom', 'Molecule'],\n              'polygons': ['Polygon', 'Triangle', 'Diamond', 'Hexagon', 'Octagon'],\n              'symbols': ['Symbol', 'Icon', 'Sign', 'Arrow', 'Bookmark'],\n              'rounded': ['Rounded', 'Pill', 'Smooth', 'Blob']\n            };\n            var hints = categoryHints[_this10.currentCategory] || [];\n            matchesCategory = hints.some(function (hint) {\n              return name.includes(hint);\n            });\n          }\n        }\n        return matchesSearch && matchesCategory;\n      });\n\n      // Variables to track the shape we need to scroll to\n      var targetShapeElement = null;\n      var targetIndex = -1;\n      var currentRow = 0;\n      var currentColumn = 0;\n\n      // Only render shapes if this is not just a resize\n      if (!isResize) {\n        // Render filtered shapes\n        filteredShapes.forEach(function (shapeName, index) {\n          try {\n            var currentIndex = index;\n            var ShapeClass = _shapesRegistry__WEBPACK_IMPORTED_MODULE_1__[\"default\"][shapeName];\n            var shapeInstance = new ShapeClass();\n\n            // Create container for shape - ultra minimal, just the shape\n            var shapeContainer = document.createElement('div');\n            shapeContainer.className = 'shape-container';\n            shapeContainer.dataset.shapeName = shapeName;\n            shapeContainer.dataset.index = currentIndex;\n\n            // Also store grid position info\n            currentColumn = index % _this10.gridColumns;\n            if (currentColumn === 0 && index > 0) {\n              currentRow++;\n            }\n            shapeContainer.dataset.row = currentRow;\n            shapeContainer.dataset.column = currentColumn;\n\n            // Make the container have high z-index and explicit cursor\n            shapeContainer.style.cursor = 'pointer';\n            shapeContainer.style.position = 'relative';\n            shapeContainer.style.aspectRatio = '1 / 1'; // Keep shapes square\n            shapeContainer.style.marginBottom = '10px'; // Add vertical spacing\n            shapeContainer.style.backgroundColor = '#000000';\n\n            // Add an invisible overlay to capture clicks more reliably\n            var clickOverlay = document.createElement('div');\n            clickOverlay.className = 'click-overlay';\n            clickOverlay.style.position = 'absolute';\n            clickOverlay.style.top = '0';\n            clickOverlay.style.left = '0';\n            clickOverlay.style.width = '100%';\n            clickOverlay.style.height = '100%';\n            clickOverlay.style.zIndex = '10';\n            clickOverlay.style.cursor = 'pointer';\n\n            // Add ID to find later\n            var shapeId = \"shape-\".concat(shapeName.replace(/[^a-z0-9]/gi, ''));\n            shapeContainer.id = shapeId;\n\n            // If this is the shape we previously clicked, mark it for scrolling\n            if (index === _this10.lastClickedShapeIndex) {\n              targetShapeElement = shapeContainer;\n              targetIndex = index;\n              console.log(\"Found target shape at index \".concat(index, \", row \").concat(currentRow, \", column \").concat(currentColumn));\n            }\n\n            // Create SVG element\n            var shapeSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n            shapeSvg.setAttribute('width', '100%');\n            shapeSvg.setAttribute('height', '100%');\n            shapeSvg.setAttribute('viewBox', '-110 -110 220 220');\n            shapeSvg.style.pointerEvents = 'none'; // Don't let SVG intercept clicks\n\n            // Create wrapper group\n            var wrapperGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n            wrapperGroup.setAttribute('transform', 'translate(0,0)');\n            wrapperGroup.style.pointerEvents = 'none'; // Don't let SVG elements intercept clicks\n            shapeSvg.appendChild(wrapperGroup);\n\n            // Generate shape content\n            var shapeContent = shapeInstance.generateShape();\n\n            // Add shape content to wrapper group\n            wrapperGroup.innerHTML = shapeContent;\n\n            // Add SVG to container\n            shapeContainer.appendChild(shapeSvg);\n\n            // Add click overlay AFTER the SVG\n            shapeContainer.appendChild(clickOverlay);\n\n            // Add hover events for shape\n            if (_this10.animationEnabled) {\n              _this10.setupShapeHoverEvents(shapeContainer, shapeName, shapeId);\n            }\n\n            // Direct click handler for better reliability - on the overlay\n            clickOverlay.onclick = function (e) {\n              e.stopPropagation();\n              e.preventDefault();\n              _this10.lastClickedShapeIndex = currentIndex;\n              _this10.lastClickedRow = parseInt(shapeContainer.dataset.row);\n              _this10.lastClickedColumn = parseInt(shapeContainer.dataset.column);\n              console.log(\"Clicked shape at index \".concat(currentIndex, \", row \").concat(_this10.lastClickedRow, \", column \").concat(_this10.lastClickedColumn));\n              _this10.selectedShape = shapeName;\n              _this10.lastSelectedShapeId = shapeId;\n              _this10.saveGridState(shapeId);\n              _this10.showShapeEditor(shapeName);\n              return false;\n            };\n\n            // Redundant click handler on the container itself\n            shapeContainer.onclick = function (e) {\n              e.stopPropagation();\n              e.preventDefault();\n              _this10.lastClickedShapeIndex = currentIndex;\n              _this10.lastClickedRow = parseInt(shapeContainer.dataset.row);\n              _this10.lastClickedColumn = parseInt(shapeContainer.dataset.column);\n              console.log(\"Clicked shape container at index \".concat(currentIndex, \", row \").concat(_this10.lastClickedRow, \", column \").concat(_this10.lastClickedColumn));\n              _this10.selectedShape = shapeName;\n              _this10.lastSelectedShapeId = shapeId;\n              _this10.saveGridState(shapeId);\n              _this10.showShapeEditor(shapeName);\n              return false;\n            };\n\n            // Add to grid\n            gridContainer.appendChild(shapeContainer);\n          } catch (error) {\n            console.error(\"Error rendering shape \".concat(shapeName, \":\"), error);\n\n            // Create error placeholder with same spacing\n            var errorContainer = document.createElement('div');\n            errorContainer.className = 'shape-container error';\n            errorContainer.style.cursor = 'pointer';\n            errorContainer.style.aspectRatio = '1 / 1';\n            errorContainer.style.marginBottom = '10px';\n            errorContainer.style.backgroundColor = '#000000';\n            gridContainer.appendChild(errorContainer);\n          }\n        });\n      }\n\n      // After rendering, handle scroll to the appropriate shape\n      if (!keepScroll && !this.selectedShape && this.lastClickedShapeIndex >= 0) {\n        if (targetShapeElement) {\n          targetShapeElement.scrollIntoView({\n            block: 'center',\n            behavior: 'auto'\n          });\n          console.log(\"Scrolled to target element at index \".concat(targetIndex));\n        }\n      }\n    }\n  }, {\n    key: \"scrollSelectedCategoryIntoView\",\n    value: function scrollSelectedCategoryIntoView() {\n      // Find the selected pill\n      var selectedPill = document.querySelector('.category-pill[data-selected=\"true\"]');\n      if (selectedPill) {\n        // Get the container\n        var filterContainer = document.getElementById('category-filters-container');\n        if (filterContainer) {\n          // Scroll the selected pill into view with a smooth animation\n          selectedPill.scrollIntoView({\n            block: 'nearest',\n            inline: 'center'\n          });\n        }\n      }\n    }\n\n    /**\n     * Save the current grid state before editing\n     */\n  }, {\n    key: \"saveGridState\",\n    value: function saveGridState(selectedShapeId) {\n      var _this11 = this;\n      // Save scroll position\n      this.gridState = {\n        scrollY: window.scrollY,\n        shapesVisible: [],\n        selectedShapeId: selectedShapeId\n      };\n\n      // Store the selected shape's position in the viewport for better restoration\n      if (selectedShapeId) {\n        var selectedElement = document.getElementById(selectedShapeId);\n        if (selectedElement) {\n          var rect = selectedElement.getBoundingClientRect();\n          this.gridState.shapePosition = {\n            elementY: rect.top,\n            viewportHeight: window.innerHeight\n          };\n        }\n      }\n\n      // Optionally gather visible shapes for more complex restoration\n      var shapes = document.querySelectorAll('.shape-container');\n      shapes.forEach(function (shape) {\n        var rect = shape.getBoundingClientRect();\n        // Check if shape is visible in viewport\n        if (rect.top >= 0 && rect.bottom <= window.innerHeight) {\n          _this11.gridState.shapesVisible.push(shape.id);\n        }\n      });\n      console.log(\"Saved grid state with scrollY: \".concat(this.gridState.scrollY));\n    }\n\n    /**\n     * Show shape editor with better scroll position saving\n     */\n  }, {\n    key: \"showShapeEditor\",\n    value: function showShapeEditor(shapeName) {\n      var _this12 = this;\n      // Set selected shape\n      this.selectedShape = shapeName;\n\n      // Explicitly capture current scroll position\n      var currentScroll = window.scrollY;\n      this.lastScrollPosition = currentScroll;\n      console.log(\"Captured current scroll position: \".concat(currentScroll));\n\n      // Save grid state with this position\n      if (!this.gridState || typeof this.gridState.scrollY !== 'number' || this.gridState.scrollY !== currentScroll) {\n        // Force an update to gridState with the current scroll position\n        this.saveGridState();\n      }\n\n      // Hide category filters when in editor mode\n      var filterContainer = document.getElementById('category-filters-container');\n      if (filterContainer) {\n        filterContainer.style.display = 'none';\n      }\n\n      // Initialize parameters if needed\n      if (Object.keys(this.parameters).length === 0) {\n        // Create a default shape instance to get parameters\n        var ShapeClass = this.shapes[shapeName];\n        if (ShapeClass) {\n          var shapeInstance = new ShapeClass();\n\n          // Get parameter definitions\n          var classParameters = ShapeClass.parameters || {};\n          var allParameters = _objectSpread(_objectSpread({}, this.Shape.parameters), classParameters);\n\n          // Initialize parameters from instance\n          Object.keys(allParameters).forEach(function (param) {\n            _this12.parameters[param] = shapeInstance[param];\n          });\n        }\n      }\n\n      // Use ShapeEditor module to show editor\n      this.editor.showEditor(shapeName);\n      this.updateShape();\n    }\n\n    /**\n     * Return to grid handler with proper category pill selection and scroll position restoration\n     */\n  }, {\n    key: \"returnToGrid\",\n    value: function returnToGrid() {\n      // Clear selected shape first\n      this.selectedShape = null;\n\n      // Load category from localStorage\n      var categoryToSelect = 'all';\n      try {\n        var savedCategory = localStorage.getItem('selectedCategory');\n        if (savedCategory) {\n          categoryToSelect = savedCategory;\n          console.log(\"Returning to grid with saved category: \".concat(categoryToSelect));\n        }\n      } catch (e) {\n        console.warn('Could not retrieve saved category from localStorage', e);\n      }\n\n      // Ensure the currentCategory is set correctly\n      this.currentCategory = categoryToSelect === 'all' ? null : categoryToSelect;\n\n      // Render grid with the correct category filter\n      // Important: Don't restore scroll yet - we need to render first\n      this.renderShapeGrid(false);\n\n      // Show category filters when returning to grid\n      var filterContainer = document.getElementById('category-filters-container');\n      if (filterContainer) {\n        // Show the filter container\n        filterContainer.style.display = 'flex';\n\n        // Explicitly select the correct pill\n        var pills = filterContainer.querySelectorAll('.category-pill');\n        pills.forEach(function (pill) {\n          var pillCategoryId = pill.dataset.categoryId;\n          var isSelected = pillCategoryId === categoryToSelect;\n\n          // Reset all attributes\n          pill.dataset.selected = isSelected ? 'true' : 'false';\n          if (isSelected) {\n            pill.classList.add('selected');\n            pill.style.setProperty('background-color', 'white', 'important');\n            pill.style.setProperty('color', '#000', 'important');\n\n            // Set icon color\n            var iconSpan = pill.querySelector('span:first-child');\n            if (iconSpan) {\n              iconSpan.style.setProperty('color', '#000', 'important');\n            }\n          } else {\n            pill.classList.remove('selected');\n            pill.style.setProperty('background-color', 'rgb(26, 26, 26)', 'important');\n            pill.style.setProperty('color', '#D9D9D9', 'important');\n\n            // Set icon color\n            var _iconSpan3 = pill.querySelector('span:first-child');\n            if (_iconSpan3) {\n              _iconSpan3.style.setProperty('color', '#D9D9D9', 'important');\n            }\n          }\n        });\n      } else {\n        // If filter container doesn't exist, recreate it\n        console.log(\"Filter container not found, recreating...\");\n        this.createCategoryFilters();\n      }\n    }\n  }]);\n}(); // Initialize when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', function () {\n  var app = new ShapeApp();\n  app.init();\n\n  // Make app available globally for debugging\n  window.shapeApp = app;\n});\n\n//# sourceURL=webpack://generative-shapes/./src/main.js?");

/***/ }),

/***/ "./src/perlin.js":
/*!***********************!*\
  !*** ./src/perlin.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// perlin.js\nvar perlin = function () {\n  function Grad(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  Grad.prototype.dot2 = function (x, y) {\n    return this.x * x + this.y * y;\n  };\n  var grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\n  var p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];\n\n  // To remove the need for index wrapping, double the permutation table length\n  var perm = new Array(512);\n  var gradP = new Array(512);\n\n  // This isn't a very good seeding function, but it works ok. It supports 2^16\n  // different seed values. Write something better if you need more seeds.\n  function seed(seed) {\n    if (seed > 0 && seed < 1) {\n      // Scale the seed out\n      seed *= 65536;\n    }\n    seed = Math.floor(seed);\n    if (seed < 256) {\n      seed |= seed << 8;\n    }\n    for (var i = 0; i < 256; i++) {\n      var v = void 0;\n      if (i & 1) {\n        v = p[i] ^ seed & 255;\n      } else {\n        v = p[i] ^ seed >> 8 & 255;\n      }\n      perm[i] = perm[i + 256] = v;\n      gradP[i] = gradP[i + 256] = grad3[v % 12];\n    }\n  }\n  seed(0);\n\n  // Skewing and unskewing factors for 2 dimensions\n  var F2 = 0.5 * (Math.sqrt(3) - 1);\n  var G2 = (3 - Math.sqrt(3)) / 6;\n  function fade(t) {\n    return t * t * t * (t * (t * 6 - 15) + 10);\n  }\n  function lerp(a, b, t) {\n    return (1 - t) * a + t * b;\n  }\n\n  // 2D Perlin Noise\n  function perlin2(x, y) {\n    // Find unit grid cell containing point\n    var X = Math.floor(x),\n      Y = Math.floor(y);\n    // Get relative xy coordinates of point within that cell\n    x = x - X;\n    y = y - Y;\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n    var XX = X & 255,\n      YY = Y & 255;\n\n    // Calculate noise contributions from each of the four corners\n    var n00 = gradP[XX + perm[YY]].dot2(x, y);\n    var n01 = gradP[XX + perm[YY + 1]].dot2(x, y - 1);\n    var n10 = gradP[XX + 1 + perm[YY]].dot2(x - 1, y);\n    var n11 = gradP[XX + 1 + perm[YY + 1]].dot2(x - 1, y - 1);\n\n    // Compute the fade curve value for x\n    var u = fade(x);\n\n    // Interpolate the four results\n    return lerp(lerp(n00, n10, u), lerp(n01, n11, u), fade(y));\n  }\n\n  // The noise function that will be used in your OrganicNoiseShape class\n  function noise(x, y) {\n    return perlin2(x, y);\n  }\n  return {\n    seed: seed,\n    perlin2: perlin2,\n    noise: noise // This is the function your class is looking for\n  };\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (perlin);\n\n//# sourceURL=webpack://generative-shapes/./src/perlin.js?");

/***/ }),

/***/ "./src/shapes sync ^\\.\\/(?%21Shape).*\\.js$":
/*!***************************************************************!*\
  !*** ./src/shapes/ sync nonrecursive ^\.\/(?%21Shape).*\.js$ ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./AlternatingSquaresPattern.js\": \"./src/shapes/AlternatingSquaresPattern.js\",\n\t\"./ArcConnectorShape.js\": \"./src/shapes/ArcConnectorShape.js\",\n\t\"./ArchShape.js\": \"./src/shapes/ArchShape.js\",\n\t\"./ArrowShape.js\": \"./src/shapes/ArrowShape.js\",\n\t\"./AsteriskShape.js\": \"./src/shapes/AsteriskShape.js\",\n\t\"./AtomShape.js\": \"./src/shapes/AtomShape.js\",\n\t\"./BarcodeShape.js\": \"./src/shapes/BarcodeShape.js\",\n\t\"./BlobShape.js\": \"./src/shapes/BlobShape.js\",\n\t\"./BookmarkShape.js\": \"./src/shapes/BookmarkShape.js\",\n\t\"./BowTieShape.js\": \"./src/shapes/BowTieShape.js\",\n\t\"./BrickWall.js\": \"./src/shapes/BrickWall.js\",\n\t\"./ChaliceShape.js\": \"./src/shapes/ChaliceShape.js\",\n\t\"./CheckerPattern.js\": \"./src/shapes/CheckerPattern.js\",\n\t\"./CircleComposition.js\": \"./src/shapes/CircleComposition.js\",\n\t\"./CirclePacking.js\": \"./src/shapes/CirclePacking.js\",\n\t\"./CircleStack.js\": \"./src/shapes/CircleStack.js\",\n\t\"./CirclesComposition.js\": \"./src/shapes/CirclesComposition.js\",\n\t\"./ClassicSmileyShape.js\": \"./src/shapes/ClassicSmileyShape.js\",\n\t\"./CloverCross.js\": \"./src/shapes/CloverCross.js\",\n\t\"./ConcaveStarShape.js\": \"./src/shapes/ConcaveStarShape.js\",\n\t\"./ConcentricEllipses.js\": \"./src/shapes/ConcentricEllipses.js\",\n\t\"./ConcentricFlow.js\": \"./src/shapes/ConcentricFlow.js\",\n\t\"./ConcentricRectangles.js\": \"./src/shapes/ConcentricRectangles.js\",\n\t\"./ConcentricSphereShape.js\": \"./src/shapes/ConcentricSphereShape.js\",\n\t\"./ConcentricTarget.js\": \"./src/shapes/ConcentricTarget.js\",\n\t\"./ConnectedPillsShape.js\": \"./src/shapes/ConnectedPillsShape.js\",\n\t\"./CrescentShape.js\": \"./src/shapes/CrescentShape.js\",\n\t\"./CrossShape.js\": \"./src/shapes/CrossShape.js\",\n\t\"./CrossSqrdShape.js\": \"./src/shapes/CrossSqrdShape.js\",\n\t\"./CrosshairShape.js\": \"./src/shapes/CrosshairShape.js\",\n\t\"./CrystalShard.js\": \"./src/shapes/CrystalShard.js\",\n\t\"./CubeShape.js\": \"./src/shapes/CubeShape.js\",\n\t\"./CurvedHourglass.js\": \"./src/shapes/CurvedHourglass.js\",\n\t\"./CurvedPetalFlower.js\": \"./src/shapes/CurvedPetalFlower.js\",\n\t\"./CurvedSplit.js\": \"./src/shapes/CurvedSplit.js\",\n\t\"./CutoutPill.js\": \"./src/shapes/CutoutPill.js\",\n\t\"./DNASpiral.js\": \"./src/shapes/DNASpiral.js\",\n\t\"./DandelionShape.js\": \"./src/shapes/DandelionShape.js\",\n\t\"./DendriteShape.js\": \"./src/shapes/DendriteShape.js\",\n\t\"./DiagonalCircleShape.js\": \"./src/shapes/DiagonalCircleShape.js\",\n\t\"./DiagonalGrid.js\": \"./src/shapes/DiagonalGrid.js\",\n\t\"./DiagonalStripes.js\": \"./src/shapes/DiagonalStripes.js\",\n\t\"./DiagonalTechShape.js\": \"./src/shapes/DiagonalTechShape.js\",\n\t\"./DiamondArrowShape.js\": \"./src/shapes/DiamondArrowShape.js\",\n\t\"./DiamondHexShape.js\": \"./src/shapes/DiamondHexShape.js\",\n\t\"./DiamondPairShape.js\": \"./src/shapes/DiamondPairShape.js\",\n\t\"./DiamondStarShape.js\": \"./src/shapes/DiamondStarShape.js\",\n\t\"./Dice.js\": \"./src/shapes/Dice.js\",\n\t\"./DotSpiral.js\": \"./src/shapes/DotSpiral.js\",\n\t\"./DoubleChevronShape.js\": \"./src/shapes/DoubleChevronShape.js\",\n\t\"./DoubleXShape.js\": \"./src/shapes/DoubleXShape.js\",\n\t\"./DualLensShape.js\": \"./src/shapes/DualLensShape.js\",\n\t\"./EllipseGrid.js\": \"./src/shapes/EllipseGrid.js\",\n\t\"./EllipsePacking.js\": \"./src/shapes/EllipsePacking.js\",\n\t\"./EllipsesStackShape.js\": \"./src/shapes/EllipsesStackShape.js\",\n\t\"./ExpandArrowsShape.js\": \"./src/shapes/ExpandArrowsShape.js\",\n\t\"./EyeShape.js\": \"./src/shapes/EyeShape.js\",\n\t\"./FingerprintShape.js\": \"./src/shapes/FingerprintShape.js\",\n\t\"./FlatWave.js\": \"./src/shapes/FlatWave.js\",\n\t\"./FloralSprayShape.js\": \"./src/shapes/FloralSprayShape.js\",\n\t\"./FlowField.js\": \"./src/shapes/FlowField.js\",\n\t\"./FlowFieldShape.js\": \"./src/shapes/FlowFieldShape.js\",\n\t\"./FlowerMandala.js\": \"./src/shapes/FlowerMandala.js\",\n\t\"./FlowerPetalsShape.js\": \"./src/shapes/FlowerPetalsShape.js\",\n\t\"./FractalFlowerShape.js\": \"./src/shapes/FractalFlowerShape.js\",\n\t\"./FractalTreeShape.js\": \"./src/shapes/FractalTreeShape.js\",\n\t\"./FrostRaysShape.js\": \"./src/shapes/FrostRaysShape.js\",\n\t\"./FunnelShape.js\": \"./src/shapes/FunnelShape.js\",\n\t\"./GeometricEmblem.js\": \"./src/shapes/GeometricEmblem.js\",\n\t\"./GeometricLogo.js\": \"./src/shapes/GeometricLogo.js\",\n\t\"./GeometricPetalFlower.js\": \"./src/shapes/GeometricPetalFlower.js\",\n\t\"./GlitchPattern.js\": \"./src/shapes/GlitchPattern.js\",\n\t\"./Globe.js\": \"./src/shapes/Globe.js\",\n\t\"./Goblet.js\": \"./src/shapes/Goblet.js\",\n\t\"./HexagonalCluster.js\": \"./src/shapes/HexagonalCluster.js\",\n\t\"./HollowEllipse.js\": \"./src/shapes/HollowEllipse.js\",\n\t\"./HorizontalRects.js\": \"./src/shapes/HorizontalRects.js\",\n\t\"./Hourglass.js\": \"./src/shapes/Hourglass.js\",\n\t\"./HourglassEllipse.js\": \"./src/shapes/HourglassEllipse.js\",\n\t\"./IncreasingRadialShape.js\": \"./src/shapes/IncreasingRadialShape.js\",\n\t\"./Keyhole.js\": \"./src/shapes/Keyhole.js\",\n\t\"./KochCurve.js\": \"./src/shapes/KochCurve.js\",\n\t\"./LanternShape.js\": \"./src/shapes/LanternShape.js\",\n\t\"./LayeredBlob.js\": \"./src/shapes/LayeredBlob.js\",\n\t\"./LayeredBlobsMaskShape.js\": \"./src/shapes/LayeredBlobsMaskShape.js\",\n\t\"./LayeredChevron.js\": \"./src/shapes/LayeredChevron.js\",\n\t\"./LayeredCubeShape.js\": \"./src/shapes/LayeredCubeShape.js\",\n\t\"./LayeredFlowShape.js\": \"./src/shapes/LayeredFlowShape.js\",\n\t\"./LayeredMountains.js\": \"./src/shapes/LayeredMountains.js\",\n\t\"./LayeredPolygon.js\": \"./src/shapes/LayeredPolygon.js\",\n\t\"./LeafVeinsShape.js\": \"./src/shapes/LeafVeinsShape.js\",\n\t\"./LineGrid.js\": \"./src/shapes/LineGrid.js\",\n\t\"./LinesBurst.js\": \"./src/shapes/LinesBurst.js\",\n\t\"./LissajousCurve.js\": \"./src/shapes/LissajousCurve.js\",\n\t\"./LogarithmicDots.js\": \"./src/shapes/LogarithmicDots.js\",\n\t\"./LotusShape.js\": \"./src/shapes/LotusShape.js\",\n\t\"./MazeShape.js\": \"./src/shapes/MazeShape.js\",\n\t\"./MeepleShape.js\": \"./src/shapes/MeepleShape.js\",\n\t\"./MeshGridShape.js\": \"./src/shapes/MeshGridShape.js\",\n\t\"./MessageBubble.js\": \"./src/shapes/MessageBubble.js\",\n\t\"./MetaBall.js\": \"./src/shapes/MetaBall.js\",\n\t\"./MetaBalls.js\": \"./src/shapes/MetaBalls.js\",\n\t\"./Meteor.js\": \"./src/shapes/Meteor.js\",\n\t\"./MirroredCurveShape.js\": \"./src/shapes/MirroredCurveShape.js\",\n\t\"./ModulatedGridShape.js\": \"./src/shapes/ModulatedGridShape.js\",\n\t\"./MoleculeShape.js\": \"./src/shapes/MoleculeShape.js\",\n\t\"./MondrianShape.js\": \"./src/shapes/MondrianShape.js\",\n\t\"./MultiRadialLinesShape.js\": \"./src/shapes/MultiRadialLinesShape.js\",\n\t\"./NestedCrossShape.js\": \"./src/shapes/NestedCrossShape.js\",\n\t\"./NestedSquares.js\": \"./src/shapes/NestedSquares.js\",\n\t\"./NestedTriangles.js\": \"./src/shapes/NestedTriangles.js\",\n\t\"./NodedRect.js\": \"./src/shapes/NodedRect.js\",\n\t\"./NodesNetworkShape.js\": \"./src/shapes/NodesNetworkShape.js\",\n\t\"./NotchForm.js\": \"./src/shapes/NotchForm.js\",\n\t\"./OctagonalFrame.js\": \"./src/shapes/OctagonalFrame.js\",\n\t\"./OrbitalShape.js\": \"./src/shapes/OrbitalShape.js\",\n\t\"./ParallelStripesCircle.js\": \"./src/shapes/ParallelStripesCircle.js\",\n\t\"./PedestalShape.js\": \"./src/shapes/PedestalShape.js\",\n\t\"./PerspectiveGridShape.js\": \"./src/shapes/PerspectiveGridShape.js\",\n\t\"./PieSegments.js\": \"./src/shapes/PieSegments.js\",\n\t\"./PinwheelShape.js\": \"./src/shapes/PinwheelShape.js\",\n\t\"./PixelPattern.js\": \"./src/shapes/PixelPattern.js\",\n\t\"./Plant.js\": \"./src/shapes/Plant.js\",\n\t\"./PlugShape.js\": \"./src/shapes/PlugShape.js\",\n\t\"./PolarLineBurst.js\": \"./src/shapes/PolarLineBurst.js\",\n\t\"./PolygonalBang.js\": \"./src/shapes/PolygonalBang.js\",\n\t\"./PrismaShape.js\": \"./src/shapes/PrismaShape.js\",\n\t\"./PuzzlePieceShape.js\": \"./src/shapes/PuzzlePieceShape.js\",\n\t\"./QuantumWavesShape.js\": \"./src/shapes/QuantumWavesShape.js\",\n\t\"./RadialGridShape.js\": \"./src/shapes/RadialGridShape.js\",\n\t\"./RadialLines.js\": \"./src/shapes/RadialLines.js\",\n\t\"./RadialTriangles.js\": \"./src/shapes/RadialTriangles.js\",\n\t\"./RainbowArcs.js\": \"./src/shapes/RainbowArcs.js\",\n\t\"./RectangleGrid.js\": \"./src/shapes/RectangleGrid.js\",\n\t\"./RecursiveCrescent.js\": \"./src/shapes/RecursiveCrescent.js\",\n\t\"./RecursiveSqrdCircles.js\": \"./src/shapes/RecursiveSqrdCircles.js\",\n\t\"./RhombusPattern.js\": \"./src/shapes/RhombusPattern.js\",\n\t\"./RhythmicWaves.js\": \"./src/shapes/RhythmicWaves.js\",\n\t\"./RibbonShape.js\": \"./src/shapes/RibbonShape.js\",\n\t\"./RoundedInnerStarShape.js\": \"./src/shapes/RoundedInnerStarShape.js\",\n\t\"./RoundedPolygon.js\": \"./src/shapes/RoundedPolygon.js\",\n\t\"./RoundedRect.js\": \"./src/shapes/RoundedRect.js\",\n\t\"./RoundedRectangles.js\": \"./src/shapes/RoundedRectangles.js\",\n\t\"./RoundedStar.js\": \"./src/shapes/RoundedStar.js\",\n\t\"./RoundedTriangle.js\": \"./src/shapes/RoundedTriangle.js\",\n\t\"./RoundedTrianglesGrid.js\": \"./src/shapes/RoundedTrianglesGrid.js\",\n\t\"./RoundedTruchet.js\": \"./src/shapes/RoundedTruchet.js\",\n\t\"./SemicirclePattern.js\": \"./src/shapes/SemicirclePattern.js\",\n\t\"./SerratedFrame.js\": \"./src/shapes/SerratedFrame.js\",\n\t\"./SierpinskiTriangle.js\": \"./src/shapes/SierpinskiTriangle.js\",\n\t\"./SignalShape.js\": \"./src/shapes/SignalShape.js\",\n\t\"./Spikes.js\": \"./src/shapes/Spikes.js\",\n\t\"./Spiral.js\": \"./src/shapes/Spiral.js\",\n\t\"./SpiralWave.js\": \"./src/shapes/SpiralWave.js\",\n\t\"./SpiroPetal.js\": \"./src/shapes/SpiroPetal.js\",\n\t\"./SprocketShape.js\": \"./src/shapes/SprocketShape.js\",\n\t\"./SquareBoxShape.js\": \"./src/shapes/SquareBoxShape.js\",\n\t\"./SquaresPyramid.js\": \"./src/shapes/SquaresPyramid.js\",\n\t\"./SquiggleShape.js\": \"./src/shapes/SquiggleShape.js\",\n\t\"./Squircle.js\": \"./src/shapes/Squircle.js\",\n\t\"./StackedCircles.js\": \"./src/shapes/StackedCircles.js\",\n\t\"./StampShape.js\": \"./src/shapes/StampShape.js\",\n\t\"./Star.js\": \"./src/shapes/Star.js\",\n\t\"./StarCircle.js\": \"./src/shapes/StarCircle.js\",\n\t\"./StarCluster.js\": \"./src/shapes/StarCluster.js\",\n\t\"./StarburstRingsShape.js\": \"./src/shapes/StarburstRingsShape.js\",\n\t\"./StarburstShape.js\": \"./src/shapes/StarburstShape.js\",\n\t\"./StitchPattern.js\": \"./src/shapes/StitchPattern.js\",\n\t\"./StitchedFrame.js\": \"./src/shapes/StitchedFrame.js\",\n\t\"./StylizedOShape.js\": \"./src/shapes/StylizedOShape.js\",\n\t\"./Sun.js\": \"./src/shapes/Sun.js\",\n\t\"./SwirlingVortex.js\": \"./src/shapes/SwirlingVortex.js\",\n\t\"./SymmetricGridPattern.js\": \"./src/shapes/SymmetricGridPattern.js\",\n\t\"./SymmetricLines.js\": \"./src/shapes/SymmetricLines.js\",\n\t\"./SymmetricTotem.js\": \"./src/shapes/SymmetricTotem.js\",\n\t\"./SymmetricalPattern.js\": \"./src/shapes/SymmetricalPattern.js\",\n\t\"./ThreadedShape.js\": \"./src/shapes/ThreadedShape.js\",\n\t\"./Tornado.js\": \"./src/shapes/Tornado.js\",\n\t\"./TorusShape.js\": \"./src/shapes/TorusShape.js\",\n\t\"./TriangleRays.js\": \"./src/shapes/TriangleRays.js\",\n\t\"./TriangularPortal.js\": \"./src/shapes/TriangularPortal.js\",\n\t\"./TribalArrow.js\": \"./src/shapes/TribalArrow.js\",\n\t\"./TribalPattern.js\": \"./src/shapes/TribalPattern.js\",\n\t\"./TripleRoundedShape.js\": \"./src/shapes/TripleRoundedShape.js\",\n\t\"./TruchetPattern.js\": \"./src/shapes/TruchetPattern.js\",\n\t\"./TwistedStems.js\": \"./src/shapes/TwistedStems.js\",\n\t\"./Vase.js\": \"./src/shapes/Vase.js\",\n\t\"./VoronoiShape.js\": \"./src/shapes/VoronoiShape.js\",\n\t\"./Wave.js\": \"./src/shapes/Wave.js\",\n\t\"./WaveField.js\": \"./src/shapes/WaveField.js\",\n\t\"./WaveFlower.js\": \"./src/shapes/WaveFlower.js\",\n\t\"./WaveFrame.js\": \"./src/shapes/WaveFrame.js\",\n\t\"./WavePattern.js\": \"./src/shapes/WavePattern.js\",\n\t\"./WavyLine.js\": \"./src/shapes/WavyLine.js\",\n\t\"./WavyLine3D.js\": \"./src/shapes/WavyLine3D.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/shapes sync ^\\\\.\\\\/(?%21Shape).*\\\\.js$\";\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/_sync_nonrecursive_^\\.\\/(?");

/***/ }),

/***/ "./src/shapes/AlternatingSquaresPattern.js":
/*!*************************************************!*\
  !*** ./src/shapes/AlternatingSquaresPattern.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar AlternatingSquaresPattern = /*#__PURE__*/function (_Shape) {\n  function AlternatingSquaresPattern() {\n    _classCallCheck(this, AlternatingSquaresPattern);\n    return _callSuper(this, AlternatingSquaresPattern, arguments);\n  }\n  _inherits(AlternatingSquaresPattern, _Shape);\n  return _createClass(AlternatingSquaresPattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Convert parameters to numbers to ensure proper calculations\n      var gridSize = Math.round(this.gridSize);\n      var spacing = Number(this.spacing);\n      var cornerRadius = Number(this.cornerRadius);\n      var viewBoxSize = 300;\n      var squareSize = Math.min(viewBoxSize / (gridSize * 2 + (gridSize - 1) * (spacing / 100)));\n\n      // Calculate total width and height\n      var totalWidth = gridSize * squareSize + (gridSize - 1) * spacing;\n      var totalHeight = totalWidth; // Square grid\n\n      // Calculate starting point to center the pattern\n      var startX = -totalWidth / 2;\n      var startY = -totalHeight / 2;\n      var squares = [];\n\n      // Create the checkerboard pattern\n      for (var row = 0; row < gridSize; row++) {\n        for (var col = 0; col < gridSize; col++) {\n          // Only draw squares in alternating positions\n          if ((row + col) % 2 === 0) {\n            var x = startX + col * (squareSize + spacing);\n            var y = startY + row * (squareSize + spacing);\n            if (cornerRadius > 0) {\n              // Create rounded rectangle using SVG path\n              var path = this.createRoundedRectPath(x, y, squareSize, squareSize, cornerRadius);\n              squares.push(\"<path d=\\\"\".concat(path, \"\\\" fill=\\\"white\\\"/>\"));\n            } else {\n              // Create regular rectangle\n              squares.push(\"<rect \\n                            x=\\\"\".concat(x, \"\\\" \\n                            y=\\\"\").concat(y, \"\\\" \\n                            width=\\\"\").concat(squareSize, \"\\\" \\n                            height=\\\"\").concat(squareSize, \"\\\"\\n                            fill=\\\"white\\\"\\n                        />\"));\n            }\n          }\n        }\n      }\n      return squares.join('');\n    }\n  }, {\n    key: \"createRoundedRectPath\",\n    value: function createRoundedRectPath(x, y, width, height, radius) {\n      // Ensure radius isn't too large for the rectangle\n      var r = Math.min(radius, Math.min(width, height) / 2);\n\n      // Create rounded rectangle path\n      return \"\\n            M \".concat(x + r, \" \").concat(y, \"\\n            L \").concat(x + width - r, \" \").concat(y, \"\\n            Q \").concat(x + width, \" \").concat(y, \" \").concat(x + width, \" \").concat(y + r, \"\\n            L \").concat(x + width, \" \").concat(y + height - r, \"\\n            Q \").concat(x + width, \" \").concat(y + height, \" \").concat(x + width - r, \" \").concat(y + height, \"\\n            L \").concat(x + r, \" \").concat(y + height, \"\\n            Q \").concat(x, \" \").concat(y + height, \" \").concat(x, \" \").concat(y + height - r, \"\\n            L \").concat(x, \" \").concat(y + r, \"\\n            Q \").concat(x, \" \").concat(y, \" \").concat(x + r, \" \").concat(y, \"\\n            Z\\n        \").trim().replace(/\\s+/g, ' ');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AlternatingSquaresPattern, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 6,\n    \"default\": 3\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  },\n  cornerRadius: {\n    min: 0,\n    max: 30,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AlternatingSquaresPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AlternatingSquaresPattern.js?");

/***/ }),

/***/ "./src/shapes/ArcConnectorShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/ArcConnectorShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ArcConnectorShape = /*#__PURE__*/function (_Shape) {\n  function ArcConnectorShape() {\n    _classCallCheck(this, ArcConnectorShape);\n    return _callSuper(this, ArcConnectorShape, arguments);\n  }\n  _inherits(ArcConnectorShape, _Shape);\n  return _createClass(ArcConnectorShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.arcCount = Math.round(this.arcCount);\n      var elements = [];\n      var angleStep = 2 * Math.PI / this.arcCount;\n      var arcSpanRad = this.arcSpan * Math.PI / 180;\n      var rotationRad = this.rotation * Math.PI / 180;\n      for (var i = 0; i < this.arcCount; i++) {\n        var centerAngle = i * angleStep + rotationRad;\n\n        // Calculate arc endpoints\n        var arcStartAngle = centerAngle - arcSpanRad / 2;\n        var arcEndAngle = centerAngle + arcSpanRad / 2;\n\n        // Calculate arc path\n        var startX = this.radius * Math.cos(arcStartAngle);\n        var startY = this.radius * Math.sin(arcStartAngle);\n        var endX = this.radius * Math.cos(arcEndAngle);\n        var endY = this.radius * Math.sin(arcEndAngle);\n\n        // Create arc path\n        var largeArcFlag = this.arcSpan > 180 ? 1 : 0;\n        var arcPath = \"M \".concat(startX, \" \").concat(startY, \" A \").concat(this.radius, \" \").concat(this.radius, \" 0 \").concat(largeArcFlag, \" 1 \").concat(endX, \" \").concat(endY);\n\n        // Add arc\n        elements.push(\"<path \\n                d=\\\"\".concat(arcPath, \"\\\"\\n                fill=\\\"white\\\"\\n            />\"));\n\n        // Add connector to next arc if connectorLength > 0\n        if (this.connectorLength > 0) {\n          var nextCenterAngle = (i + 1) % this.arcCount * angleStep + rotationRad;\n          var nextArcStartAngle = nextCenterAngle - arcSpanRad / 2;\n          var nextStartX = this.radius * Math.cos(nextArcStartAngle);\n          var nextStartY = this.radius * Math.sin(nextArcStartAngle);\n          var connectorPath = \"M \".concat(endX, \" \").concat(endY, \" Q \").concat(this.connectorLength * Math.cos(centerAngle), \" \").concat(this.connectorLength * Math.sin(centerAngle), \" \").concat(nextStartX, \" \").concat(nextStartY);\n          elements.push(\"<path \\n                    d=\\\"\".concat(connectorPath, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ArcConnectorShape, \"parameters\", {\n  radius: {\n    min: 20,\n    max: 150,\n    \"default\": 100\n  },\n  arcCount: {\n    min: 3,\n    max: 24,\n    \"default\": 8\n  },\n  arcSpan: {\n    min: 0,\n    max: 120,\n    \"default\": 5\n  },\n  connectorLength: {\n    min: 1,\n    max: 100,\n    \"default\": 1\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ArcConnectorShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ArcConnectorShape.js?");

/***/ }),

/***/ "./src/shapes/ArchShape.js":
/*!*********************************!*\
  !*** ./src/shapes/ArchShape.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ArchShape = /*#__PURE__*/function (_Shape) {\n  function ArchShape() {\n    _classCallCheck(this, ArchShape);\n    return _callSuper(this, ArchShape, arguments);\n  }\n  _inherits(ArchShape, _Shape);\n  return _createClass(ArchShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Normalize parameters\n      var width = this.width;\n      var height = this.height;\n      var archWidth = Math.min(this.archWidth, width * 0.8);\n      var archHeight = Math.min(this.archHeight, height * 0.9);\n      var cornerRadius = this.cornerRadius;\n\n      // Calculate positions\n      var halfWidth = width / 2;\n      var halfArchWidth = archWidth / 2;\n      var leftEdge = -halfWidth;\n      var rightEdge = halfWidth;\n      var topEdge = -height / 2;\n      var bottomEdge = height / 2;\n      var archLeft = -halfArchWidth;\n      var archRight = halfArchWidth;\n\n      // Start with a path for the shape\n      // The path draws clockwise from the bottom-left corner\n      var pathData = '';\n      if (cornerRadius > 0) {\n        // Start at bottom-left with rounded corner\n        pathData = \"M \".concat(leftEdge + cornerRadius, \",\").concat(bottomEdge);\n\n        // Draw bottom edge\n        pathData += \" L \".concat(archLeft - cornerRadius, \",\").concat(bottomEdge);\n\n        // Draw bottom-left arch corner\n        pathData += \" Q \".concat(archLeft, \",\").concat(bottomEdge, \" \").concat(archLeft, \",\").concat(bottomEdge - cornerRadius);\n\n        // Draw left side of arch\n        pathData += \" L \".concat(archLeft, \",\").concat(bottomEdge - archHeight + cornerRadius);\n\n        // Use the dedicated parameter for arch top radius\n        var archRadius = Math.min(this.archTopRadius, archWidth / 2, archHeight / 2);\n\n        // Create a rounded top arch using a curved path\n        pathData += \" L \".concat(archLeft, \",\").concat(bottomEdge - archHeight + archRadius);\n        pathData += \" Q \".concat(archLeft, \",\").concat(bottomEdge - archHeight, \" \").concat(archLeft + archRadius, \",\").concat(bottomEdge - archHeight);\n        pathData += \" L \".concat(archRight - archRadius, \",\").concat(bottomEdge - archHeight);\n        pathData += \" Q \".concat(archRight, \",\").concat(bottomEdge - archHeight, \" \").concat(archRight, \",\").concat(bottomEdge - archHeight + archRadius);\n\n        // Draw right side of arch\n        pathData += \" L \".concat(archRight, \",\").concat(bottomEdge - cornerRadius);\n\n        // Draw bottom-right arch corner\n        pathData += \" Q \".concat(archRight, \",\").concat(bottomEdge, \" \").concat(archRight + cornerRadius, \",\").concat(bottomEdge);\n\n        // Draw remainder of bottom edge\n        pathData += \" L \".concat(rightEdge - cornerRadius, \",\").concat(bottomEdge);\n\n        // Draw bottom-right corner\n        pathData += \" Q \".concat(rightEdge, \",\").concat(bottomEdge, \" \").concat(rightEdge, \",\").concat(bottomEdge - cornerRadius);\n\n        // Draw right edge\n        pathData += \" L \".concat(rightEdge, \",\").concat(topEdge + cornerRadius);\n\n        // Draw top-right corner\n        pathData += \" Q \".concat(rightEdge, \",\").concat(topEdge, \" \").concat(rightEdge - cornerRadius, \",\").concat(topEdge);\n\n        // Draw top edge\n        pathData += \" L \".concat(leftEdge + cornerRadius, \",\").concat(topEdge);\n\n        // Draw top-left corner\n        pathData += \" Q \".concat(leftEdge, \",\").concat(topEdge, \" \").concat(leftEdge, \",\").concat(topEdge + cornerRadius);\n\n        // Draw left edge and close\n        pathData += \" L \".concat(leftEdge, \",\").concat(bottomEdge - cornerRadius);\n        pathData += \" Q \".concat(leftEdge, \",\").concat(bottomEdge, \" \").concat(leftEdge + cornerRadius, \",\").concat(bottomEdge);\n      } else {\n        // No rounded corners on outer shape but rounded top on the inner arch\n        pathData = \"M \".concat(leftEdge, \",\").concat(bottomEdge);\n        pathData += \" L \".concat(archLeft, \",\").concat(bottomEdge);\n\n        // Calculate arch radius for the top inner arch\n        var _archRadius = Math.min(archWidth / 2, archHeight / 2);\n\n        // Create a rounded top arch using a curved path\n        pathData += \" L \".concat(archLeft, \",\").concat(bottomEdge - archHeight + _archRadius);\n        pathData += \" Q \".concat(archLeft, \",\").concat(bottomEdge - archHeight, \" \").concat(archLeft + _archRadius, \",\").concat(bottomEdge - archHeight);\n        pathData += \" L \".concat(archRight - _archRadius, \",\").concat(bottomEdge - archHeight);\n        pathData += \" Q \".concat(archRight, \",\").concat(bottomEdge - archHeight, \" \").concat(archRight, \",\").concat(bottomEdge - archHeight + _archRadius);\n        pathData += \" L \".concat(archRight, \",\").concat(bottomEdge);\n        pathData += \" L \".concat(rightEdge, \",\").concat(bottomEdge);\n        pathData += \" L \".concat(rightEdge, \",\").concat(topEdge);\n        pathData += \" L \".concat(leftEdge, \",\").concat(topEdge);\n        pathData += \" Z\";\n      }\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ArchShape, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  archWidth: {\n    min: 30,\n    max: 120,\n    \"default\": 60\n  },\n  archHeight: {\n    min: 30,\n    max: 150,\n    \"default\": 90\n  },\n  cornerRadius: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  },\n  archTopRadius: {\n    min: 0,\n    max: 60,\n    \"default\": 30\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ArchShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ArchShape.js?");

/***/ }),

/***/ "./src/shapes/ArrowShape.js":
/*!**********************************!*\
  !*** ./src/shapes/ArrowShape.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ArrowShape = /*#__PURE__*/function (_Shape) {\n  function ArrowShape() {\n    var _this;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ArrowShape);\n    _this = _callSuper(this, ArrowShape, [options]);\n    _this.validateAndAdjustParameters();\n    return _this;\n  }\n  _inherits(ArrowShape, _Shape);\n  return _createClass(ArrowShape, [{\n    key: \"validateAndAdjustParameters\",\n    value: function validateAndAdjustParameters() {\n      // Ensure head width is proportional to length\n      var maxHeadWidth = this.length * 0.8;\n      this.headWidth = Math.min(this.headWidth, maxHeadWidth);\n\n      // Always ensure head width is greater than shaft width\n      var minHeadWidthDiff = Math.max(10, this.length * 0.1);\n      if (this.headWidth < this.shaftWidth + minHeadWidthDiff) {\n        this.headWidth = this.shaftWidth + minHeadWidthDiff;\n      }\n\n      // Ensure head length is proportional to total length\n      var maxHeadLength = this.length * 0.5;\n      this.headLength = Math.min(this.headLength, maxHeadLength);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Apply validations to ensure proper dimensions\n      this.validateAndAdjustParameters();\n\n      // Calculate dimensions\n      var headHeight = this.headLength;\n      var shaftHeight = this.length - headHeight;\n      var halfHeadWidth = this.headWidth / 2;\n      var halfShaftWidth = this.shaftWidth / 2;\n\n      // Base Y positions\n      var baseY = -this.length / 2;\n      var shaftTopY = baseY + shaftHeight;\n      var tipY = this.length / 2;\n      var points;\n\n      // Apply different filled styles\n      switch (Math.floor(this.style)) {\n        case 1:\n          // Bold - wider shaft\n          var boldHalfShaftWidth = halfShaftWidth * 1.2;\n          points = [[-boldHalfShaftWidth, baseY], [boldHalfShaftWidth, baseY], [boldHalfShaftWidth, shaftTopY], [halfHeadWidth, shaftTopY], [0, tipY], [-halfHeadWidth, shaftTopY], [-boldHalfShaftWidth, shaftTopY]];\n          break;\n        case 2:\n          // Thin - slimmer shaft\n          var thinHalfShaftWidth = halfShaftWidth * 0.7;\n          points = [[-thinHalfShaftWidth, baseY], [thinHalfShaftWidth, baseY], [thinHalfShaftWidth, shaftTopY], [halfHeadWidth, shaftTopY], [0, tipY], [-halfHeadWidth, shaftTopY], [-thinHalfShaftWidth, shaftTopY]];\n          break;\n        case 3:\n          // Flat - shorter head\n          var flatHeadHeight = headHeight * 0.7;\n          var flatShaftTopY = baseY + (this.length - flatHeadHeight);\n          points = [[-halfShaftWidth, baseY], [halfShaftWidth, baseY], [halfShaftWidth, flatShaftTopY], [halfHeadWidth, flatShaftTopY], [0, tipY], [-halfHeadWidth, flatShaftTopY], [-halfShaftWidth, flatShaftTopY]];\n          break;\n        case 4:\n          // Sharp - longer, more pointed head\n          var sharpHeadHeight = headHeight * 1.2;\n          var sharpShaftTopY = baseY + (this.length - sharpHeadHeight);\n          var sharpHeadWidth = halfHeadWidth * 0.9; // Slightly narrower for sharper look\n          points = [[-halfShaftWidth, baseY], [halfShaftWidth, baseY], [halfShaftWidth, sharpShaftTopY], [sharpHeadWidth, sharpShaftTopY], [0, tipY], [-sharpHeadWidth, sharpShaftTopY], [-halfShaftWidth, sharpShaftTopY]];\n          break;\n        case 0: // Standard (default)\n        default:\n          points = [[-halfShaftWidth, baseY], [halfShaftWidth, baseY], [halfShaftWidth, shaftTopY], [halfHeadWidth, shaftTopY], [0, tipY], [-halfHeadWidth, shaftTopY], [-halfShaftWidth, shaftTopY]];\n          break;\n      }\n\n      // Create polygon points string\n      var pointsString = points.map(function (p) {\n        return \"\".concat(p[0], \",\").concat(p[1]);\n      }).join(' ');\n\n      // Return a filled polygon - no strokes\n      return \"\\n            <g transform=\\\"rotate(\".concat(this.rotation, \")\\\">\\n                <polygon \\n                    points=\\\"\").concat(pointsString, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\\n            </g>\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ArrowShape, \"parameters\", {\n  // Basic dimensions\n  length: {\n    min: 50,\n    max: 150,\n    \"default\": 150\n  },\n  shaftWidth: {\n    min: 10,\n    max: 100,\n    \"default\": 30\n  },\n  headWidth: {\n    min: 20,\n    max: 200,\n    \"default\": 80\n  },\n  headLength: {\n    min: 20,\n    max: 100,\n    \"default\": 50\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 180,\n    step: 45\n  },\n  // Visual style parameter (all filled styles)\n  // 0=standard, 1=bold, 2=thin, 3=flat, 4=sharp\n  style: {\n    min: 0,\n    max: 4,\n    \"default\": 0,\n    step: 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ArrowShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ArrowShape.js?");

/***/ }),

/***/ "./src/shapes/AsteriskShape.js":
/*!*************************************!*\
  !*** ./src/shapes/AsteriskShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar AsteriskShape = /*#__PURE__*/function (_Shape) {\n  function AsteriskShape() {\n    _classCallCheck(this, AsteriskShape);\n    return _callSuper(this, AsteriskShape, arguments);\n  }\n  _inherits(AsteriskShape, _Shape);\n  return _createClass(AsteriskShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.arms = Math.round(this.arms);\n      var paths = [];\n      var angleIncrement = 2 * Math.PI / this.arms;\n\n      // Generate each arm\n      for (var arm = 0; arm < this.arms; arm++) {\n        var angle = arm * angleIncrement;\n\n        // Calculate perpendicular angle for arm width\n        var perpAngle = angle + Math.PI / 2;\n        var halfWidth = this.armWidth / 2;\n\n        // Calculate start point (inner radius)\n        var startX = this.innerRadius * Math.cos(angle);\n        var startY = this.innerRadius * Math.sin(angle);\n\n        // Calculate end point (full length)\n        var endX = this.armLength * Math.cos(angle);\n        var endY = this.armLength * Math.sin(angle);\n\n        // Calculate the four corners of the rectangular arm\n        var p1 = {\n          x: startX + halfWidth * Math.cos(perpAngle),\n          y: startY + halfWidth * Math.sin(perpAngle)\n        };\n        var p2 = {\n          x: startX - halfWidth * Math.cos(perpAngle),\n          y: startY - halfWidth * Math.sin(perpAngle)\n        };\n        var p3 = {\n          x: endX - halfWidth * Math.cos(perpAngle),\n          y: endY - halfWidth * Math.sin(perpAngle)\n        };\n        var p4 = {\n          x: endX + halfWidth * Math.cos(perpAngle),\n          y: endY + halfWidth * Math.sin(perpAngle)\n        };\n\n        // Create path for this arm\n        var path = \"<path d=\\\"M \".concat(p1.x, \" \").concat(p1.y, \" \\n                L \").concat(p2.x, \" \").concat(p2.y, \" \\n                L \").concat(p3.x, \" \").concat(p3.y, \" \\n                L \").concat(p4.x, \" \").concat(p4.y, \" Z\\\"\\n                fill=\\\"white\\\"\\n            />\");\n        paths.push(path);\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AsteriskShape, \"parameters\", {\n  arms: {\n    min: 4,\n    max: 12,\n    \"default\": 8\n  },\n  armLength: {\n    min: 20,\n    max: 120,\n    \"default\": 100\n  },\n  armWidth: {\n    min: 5,\n    max: 30,\n    \"default\": 30\n  },\n  innerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AsteriskShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AsteriskShape.js?");

/***/ }),

/***/ "./src/shapes/AtomShape.js":
/*!*********************************!*\
  !*** ./src/shapes/AtomShape.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar AtomShape = /*#__PURE__*/function (_Shape) {\n  function AtomShape() {\n    _classCallCheck(this, AtomShape);\n    return _callSuper(this, AtomShape, arguments);\n  }\n  _inherits(AtomShape, _Shape);\n  return _createClass(AtomShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.orbitCount = Math.round(this.orbitCount);\n      var elements = [];\n\n      // Generate nucleus\n      elements.push(\"<circle\\n      cx=\\\"0\\\"\\n      cy=\\\"0\\\"\\n      r=\\\"\".concat(this.nucleusRadius, \"\\\"\\n      fill=\\\"white\\\"\\n    />\"));\n\n      // Calculate rotation angles for perfect symmetry\n      var angleStep = 180 / this.orbitCount;\n\n      // Generate orbits - perfectly symmetrical\n      for (var i = 0; i < this.orbitCount; i++) {\n        var rotation = i * angleStep;\n        elements.push(\"<ellipse\\n        cx=\\\"0\\\"\\n        cy=\\\"0\\\"\\n        rx=\\\"\".concat(this.orbitRadius, \"\\\"\\n        ry=\\\"\").concat(this.orbitRadius * this.orbitEccentricity, \"\\\"\\n        transform=\\\"rotate(\").concat(rotation, \")\\\"\\n        fill=\\\"none\\\"\\n        stroke=\\\"white\\\"\\n        stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n      />\"));\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(AtomShape, \"parameters\", {\n  nucleusRadius: {\n    min: 5,\n    max: 30,\n    \"default\": 18\n  },\n  orbitCount: {\n    min: 2,\n    max: 4,\n    \"default\": 3\n  },\n  orbitRadius: {\n    min: 40,\n    max: 120,\n    \"default\": 80\n  },\n  orbitEccentricity: {\n    min: 0.2,\n    max: 0.6,\n    \"default\": 0.4\n  },\n  strokeWidth: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  symmetryAngle: {\n    min: 15,\n    max: 60,\n    \"default\": 40\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AtomShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/AtomShape.js?");

/***/ }),

/***/ "./src/shapes/BarcodeShape.js":
/*!************************************!*\
  !*** ./src/shapes/BarcodeShape.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LineGridShape = /*#__PURE__*/function (_Shape) {\n  function LineGridShape() {\n    _classCallCheck(this, LineGridShape);\n    return _callSuper(this, LineGridShape, arguments);\n  }\n  _inherits(LineGridShape, _Shape);\n  return _createClass(LineGridShape, [{\n    key: \"getThickness\",\n    value:\n    // The random() method is now inherited from Shape class\n\n    function getThickness(index) {\n      switch (this.pattern) {\n        case 'random':\n          return this.minThickness + (this.maxThickness - this.minThickness) * this.random();\n        case 'alternating':\n          return index % 2 === 0 ? this.minThickness : this.maxThickness;\n        case 'increasing':\n          var step = (this.maxThickness - this.minThickness) / (this.linesCount - 1 || 1);\n          return this.minThickness + index * step;\n        case 'fibonacci':\n          {\n            // Simplified Fibonacci-based thickness\n            var fibValue = 0;\n            var a = 0,\n              b = 1;\n            for (var i = 0; i <= index % 10; i++) {\n              fibValue = a;\n              var temp = a + b;\n              a = b;\n              b = temp;\n            }\n            // Scale fibonacci number to our thickness range\n            var normalizedValue = fibValue % 21 / 20;\n            return this.minThickness + normalizedValue * (this.maxThickness - this.minThickness);\n          }\n        default:\n          return this.minThickness;\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG for consistent generation with same parameters\n      this.resetRNG();\n      var lines = [];\n      var totalWidth = this.linesCount * this.spacing;\n      var startX = -totalWidth / 2;\n      for (var i = 0; i < this.linesCount; i++) {\n        var x = startX + i * this.spacing;\n        var thickness = this.getThickness(i);\n        lines.push(\"<line \\n                x1=\\\"\".concat(x, \"\\\" \\n                y1=\\\"\").concat(-this.height / 2, \"\\\" \\n                x2=\\\"\").concat(x, \"\\\" \\n                y2=\\\"\").concat(this.height / 2, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LineGridShape, \"parameters\", {\n  linesCount: {\n    min: 4,\n    max: 16,\n    \"default\": 12\n  },\n  minThickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  maxThickness: {\n    min: 1,\n    max: 30,\n    \"default\": 12\n  },\n  spacing: {\n    min: 1,\n    max: 25,\n    \"default\": 12\n  },\n  height: {\n    min: 50,\n    max: 150,\n    \"default\": 200\n  },\n  // Remove randomSeed and use inherited seed\n  pattern: {\n    options: ['random', 'alternating', 'increasing', 'fibonacci'],\n    \"default\": 'random'\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'butt'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LineGridShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BarcodeShape.js?");

/***/ }),

/***/ "./src/shapes/BlobShape.js":
/*!*********************************!*\
  !*** ./src/shapes/BlobShape.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar BlobShape = /*#__PURE__*/function (_Shape) {\n  function BlobShape() {\n    _classCallCheck(this, BlobShape);\n    return _callSuper(this, BlobShape, arguments);\n  }\n  _inherits(BlobShape, _Shape);\n  return _createClass(BlobShape, [{\n    key: \"toRad\",\n    value: function toRad(deg) {\n      return deg * (Math.PI / 180.0);\n    }\n  }, {\n    key: \"divide\",\n    value: function divide(count) {\n      var deg = 360.0 / count;\n      return Array.from({\n        length: count\n      }, function (_, i) {\n        return i * deg;\n      });\n    }\n  }, {\n    key: \"randomDouble\",\n    value: function randomDouble(seed) {\n      var mask = 0xffffffff;\n      var m_w = 123456789 + seed & mask;\n      var m_z = 987654321 - seed & mask;\n      return function () {\n        m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;\n        m_w = 18000 * (m_w & 65535) + (m_w >> 16) & mask;\n        var result = (m_z << 16) + (m_w & 65535) >> 0;\n        return result / 0xffffffff;\n      };\n    }\n  }, {\n    key: \"magicPoint\",\n    value: function magicPoint(value, min, max) {\n      // Base radius calculation\n      var radius = min + value * (max - min);\n      if (this.amplitude > 0) {\n        // Calculate wave effects\n        var range = max - min;\n        var safeAmplitude = Math.min(this.amplitude, 4.5); // Cap amplitude to prevent extreme values\n\n        var primaryWave = Math.sin(this.currentAngle * this.frequency) * safeAmplitude * range * 0.4;\n        var secondaryWave = Math.sin(this.currentAngle * this.frequency * 2.7) * safeAmplitude * range * 0.15;\n        var tertiaryWave = Math.sin(this.currentAngle * this.frequency * 0.5) * safeAmplitude * range * 0.1;\n\n        // Add waves to radius with safety factor\n        radius += primaryWave + secondaryWave + tertiaryWave;\n      }\n\n      // Proper bounds handling - ensure radius stays within valid range\n      if (radius > max) {\n        radius = max; // Simply cap at maximum\n      } else if (radius < min) {\n        radius = min; // Simply cap at minimum\n      }\n      return radius;\n    }\n  }, {\n    key: \"point\",\n    value: function point(centerX, centerY, radius, degree) {\n      var skewRad = this.toRad(this.skew);\n      var angle = this.toRad(degree) + skewRad;\n      var x = centerX + radius * Math.cos(angle);\n      var y = centerY + radius * Math.sin(angle);\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"createPoints\",\n    value: function createPoints(size, minGrowth, edgesCount, seed) {\n      var _this = this;\n      var outerRad = size / 2;\n      var innerRad = minGrowth * (outerRad / 10);\n      var centerX = 0;\n      var centerY = 0;\n      var slices = this.divide(edgesCount);\n      var randVal = this.randomDouble(seed);\n      return slices.map(function (degree) {\n        _this.currentAngle = _this.toRad(degree);\n        var radius = _this.magicPoint(randVal(), innerRad, outerRad);\n        return _this.point(centerX, centerY, radius, degree);\n      });\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var baseSize = 250;\n      var points = this.createPoints(baseSize, this.growth, this.edges, this.seed);\n      if (points.length < 3) {\n        // Ensure we have enough points for a valid shape\n        return '<circle cx=\"0\" cy=\"0\" r=\"100\" fill=\"white\" />';\n      }\n      try {\n        // Generate path with proper error handling\n        var pathCommands = [];\n\n        // Calculate first midpoint safely\n        var start = {\n          x: (points[0].x + points[1].x) / 2,\n          y: (points[0].y + points[1].y) / 2\n        };\n        pathCommands.push(\"M\".concat(start.x.toFixed(2), \",\").concat(start.y.toFixed(2)));\n        for (var i = 0; i < points.length; i++) {\n          var p1 = points[(i + 1) % points.length];\n          var p2 = points[(i + 2) % points.length];\n\n          // Ensure all points are valid\n          if (isNaN(p1.x) || isNaN(p1.y) || isNaN(p2.x) || isNaN(p2.y)) {\n            continue;\n          }\n          var mid = {\n            x: (p1.x + p2.x) / 2,\n            y: (p1.y + p2.y) / 2\n          };\n\n          // Use toFixed to prevent very long decimal numbers\n          pathCommands.push(\"Q\".concat(p1.x.toFixed(2), \",\").concat(p1.y.toFixed(2), \",\").concat(mid.x.toFixed(2), \",\").concat(mid.y.toFixed(2)));\n        }\n        pathCommands.push('Z');\n        return \"<path \\n                d=\\\"\".concat(pathCommands.join(''), \"\\\"\\n                fill=\\\"white\\\"\\n            />\");\n      } catch (error) {\n        // Fallback to a circle if path generation fails\n        return '<circle cx=\"0\" cy=\"0\" r=\"100\" fill=\"white\" />';\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BlobShape, \"parameters\", {\n  edges: {\n    min: 4,\n    max: 16,\n    \"default\": 10\n  },\n  growth: {\n    min: 3,\n    max: 6,\n    \"default\": 5\n  },\n  skew: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  },\n  amplitude: {\n    min: 0,\n    max: 5,\n    \"default\": 5\n  },\n  frequency: {\n    min: 0.5,\n    max: 4,\n    \"default\": 6.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BlobShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BlobShape.js?");

/***/ }),

/***/ "./src/shapes/BookmarkShape.js":
/*!*************************************!*\
  !*** ./src/shapes/BookmarkShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar BookmarkShape = /*#__PURE__*/function (_Shape) {\n  function BookmarkShape() {\n    _classCallCheck(this, BookmarkShape);\n    return _callSuper(this, BookmarkShape, arguments);\n  }\n  _inherits(BookmarkShape, _Shape);\n  return _createClass(BookmarkShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.width = this.width / 100;\n      this.height = this.height / 100;\n      this.cutDepth = this.cutDepth / 100;\n      this.cutStart = this.cutStart / 100;\n      this.rounding = this.rounding / 100;\n      var size = 100;\n      var halfSize = size / 2;\n      var halfHeight = halfSize * this.height;\n      var cutStartY = -halfHeight + this.height * size * this.cutStart;\n      var halfWidth = halfSize * this.width;\n\n      // Base points for the bookmark shape\n      var points = [{\n        x: -halfWidth,\n        y: -halfHeight\n      },\n      // Top left\n      {\n        x: halfWidth,\n        y: -halfHeight\n      },\n      // Top right\n      {\n        x: halfWidth,\n        y: halfHeight\n      },\n      // Bottom right\n      {\n        x: halfWidth,\n        y: cutStartY\n      },\n      // Right triangle start\n      {\n        x: 0,\n        y: halfHeight - this.height * size * this.cutDepth\n      },\n      // Triangle point\n      {\n        x: -halfWidth,\n        y: cutStartY\n      },\n      // Left triangle start\n      {\n        x: -halfWidth,\n        y: halfHeight\n      } // Bottom left\n      ];\n\n      // If no rounding, return straight path\n      if (this.rounding === 0) {\n        return \"<path d=\\\"\".concat(points.map(function (p, i) {\n          return (i === 0 ? 'M' : 'L') + \" \".concat(p.x, \" \").concat(p.y);\n        }).join(''), \" Z\\\" fill=\\\"white\\\" />\");\n      }\n\n      // Calculate maximum allowed corner radius\n      var minSegmentLength = Math.min(halfWidth * 2, Math.abs(points[0].y - points[6].y));\n      var maxRadius = minSegmentLength * 0.2; // Limit to 20% of smallest segment\n      var cornerRadius = maxRadius * this.rounding;\n\n      // Generate rounded corners path\n      var path = \"M \".concat(points[0].x, \" \").concat(points[0].y);\n      for (var i = 0; i < points.length; i++) {\n        var current = points[i];\n        var next = points[(i + 1) % points.length];\n        var prev = points[i === 0 ? points.length - 1 : i - 1];\n\n        // Skip rounding for triangle points\n        if (current.x === 0 || current.y === cutStartY && next.x === 0 || current.y === cutStartY && prev.x === 0) {\n          path += \" L \".concat(current.x, \" \").concat(current.y);\n          continue;\n        }\n\n        // Calculate vectors\n        var toPrev = {\n          x: prev.x - current.x,\n          y: prev.y - current.y\n        };\n        var toNext = {\n          x: next.x - current.x,\n          y: next.y - current.y\n        };\n\n        // Normalize vectors\n        var toPrevLength = Math.sqrt(toPrev.x * toPrev.x + toPrev.y * toPrev.y);\n        var toNextLength = Math.sqrt(toNext.x * toNext.x + toNext.y * toNext.y);\n        var normPrev = {\n          x: toPrev.x / toPrevLength,\n          y: toPrev.y / toPrevLength\n        };\n        var normNext = {\n          x: toNext.x / toNextLength,\n          y: toNext.y / toNextLength\n        };\n\n        // Calculate control points\n        var cp1 = {\n          x: current.x + normPrev.x * cornerRadius,\n          y: current.y + normPrev.y * cornerRadius\n        };\n        var cp2 = {\n          x: current.x + normNext.x * cornerRadius,\n          y: current.y + normNext.y * cornerRadius\n        };\n\n        // Add to path\n        path += \" L \".concat(cp1.x, \" \").concat(cp1.y);\n        path += \" Q \".concat(current.x, \" \").concat(current.y, \" \").concat(cp2.x, \" \").concat(cp2.y);\n      }\n      return \"<path d=\\\"\".concat(path, \" Z\\\" fill=\\\"white\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BookmarkShape, \"parameters\", {\n  width: {\n    min: 25,\n    max: 100,\n    \"default\": 80\n  },\n  // Width of bookmark\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  // Height of bookmark\n  cutDepth: {\n    min: 20,\n    max: 70,\n    \"default\": 40\n  },\n  // How deep the triangle cuts in\n  cutStart: {\n    min: 50,\n    max: 100,\n    \"default\": 80\n  },\n  // Where triangle starts from top\n  rounding: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  } // Corner rounding amount\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BookmarkShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BookmarkShape.js?");

/***/ }),

/***/ "./src/shapes/BowTieShape.js":
/*!***********************************!*\
  !*** ./src/shapes/BowTieShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar BowTieShape = /*#__PURE__*/function (_Shape) {\n  function BowTieShape() {\n    _classCallCheck(this, BowTieShape);\n    return _callSuper(this, BowTieShape, arguments);\n  }\n  _inherits(BowTieShape, _Shape);\n  return _createClass(BowTieShape, [{\n    key: \"createCurvedElement\",\n    value: function createCurvedElement(rotation) {\n      // Create the curved shape with the given rotation\n      var startX = -this.centerSize / 2 - this.spacing;\n      var endX = -this.arcRadius;\n\n      // Calculate control points\n      var cp1x = -this.centerSize / 2 - this.arcRadius * this.curvature;\n      var cp1y = -this.arcRadius * this.curvature;\n      var cp2x = -this.arcRadius;\n      var cp2y = -this.arcRadius;\n\n      // Create paths for both upper and lower curves\n      var upperCurve = \"M \".concat(startX, \" 0 \\n                           C \").concat(cp1x, \" \").concat(cp1y, \", \").concat(cp2x, \" \").concat(cp2y, \", \").concat(endX, \" 0\");\n      var lowerCurve = \"M \".concat(startX, \" 0 \\n                           C \").concat(cp1x, \" \").concat(-cp1y, \", \").concat(cp2x, \" \").concat(-cp2y, \", \").concat(endX, \" 0\");\n\n      // Apply rotation transform\n      var rad = rotation * Math.PI / 180;\n      var cos = Math.cos(rad);\n      var sin = Math.sin(rad);\n      return \"<g transform=\\\"matrix(\".concat(cos, \" \").concat(sin, \" \").concat(-sin, \" \").concat(cos, \" 0 0)\\\">\\n                    <path d=\\\"\").concat(upperCurve, \" \").concat(lowerCurve, \"\\\"\\n                          fill=\\\"white\\\"/>\\n                </g>\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Create center circle\n      var centerCircle = \"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(this.centerSize / 2, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n\n      // Create curved elements at 0 and 180 degrees\n      var leftElement = this.createCurvedElement(0);\n      var rightElement = this.createCurvedElement(180);\n\n      // Combine all elements\n      return \"<g>\\n            \".concat(centerCircle, \"\\n            \").concat(leftElement, \"\\n            \").concat(rightElement, \"\\n        </g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BowTieShape, \"parameters\", {\n  arcRadius: {\n    min: 50,\n    max: 150,\n    \"default\": 80\n  },\n  centerSize: {\n    min: 10,\n    max: 100,\n    \"default\": 60\n  },\n  curvature: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.5\n  },\n  spacing: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BowTieShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BowTieShape.js?");

/***/ }),

/***/ "./src/shapes/BrickWall.js":
/*!*********************************!*\
  !*** ./src/shapes/BrickWall.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar BrickWall = /*#__PURE__*/function (_Shape) {\n  function BrickWall() {\n    _classCallCheck(this, BrickWall);\n    return _callSuper(this, BrickWall, arguments);\n  }\n  _inherits(BrickWall, _Shape);\n  return _createClass(BrickWall, [{\n    key: \"generateShape\",\n    value:\n    // Remove custom random method - now inherited from Shape\n\n    function generateShape() {\n      // Reset RNG before generating the shape\n      this.resetRNG();\n\n      // Create rectangular wall with specified rows/columns\n      var squareSize = 180;\n      var halfSize = squareSize / 2;\n\n      // Calculate row height\n      var rowHeight = squareSize / this.rows;\n\n      // Default pattern layouts - we'll select one based on parameters\n      var patterns = [\n      // Each row array contains [width1, width2, ...] values that sum to 1.0\n      [[0.33, 0.33, 0.34], [0.5, 0.5], [0.33, 0.33, 0.34], [0.5, 0.5], [0.33, 0.33, 0.34]], [[0.25, 0.25, 0.25, 0.25], [0.33, 0.34, 0.33], [0.25, 0.25, 0.25, 0.25], [0.33, 0.34, 0.33], [0.25, 0.25, 0.25, 0.25]], [[0.25, 0.5, 0.25], [0.4, 0.2, 0.4], [0.25, 0.5, 0.25], [0.33, 0.34, 0.33], [0.25, 0.5, 0.25]]];\n\n      // Select or create pattern based on parameters\n      var selectedPattern;\n      if (this.randomLayout) {\n        // Create a varied pattern that still maintains perfect grid\n        selectedPattern = [];\n        for (var r = 0; r < this.rows; r++) {\n          var rowPattern = void 0;\n          // Alternate between different division patterns\n          if (r % 2 === 0) {\n            // Create pattern with equal divisions\n            rowPattern = Array(this.columns).fill(1 / this.columns);\n          } else {\n            // Create pattern with varying brick sizes\n            // For odd rows, we'll use either 2 or 3 bricks of different sizes\n            if (this.columns <= 3 || this.random() > 0.5) {\n              // Use 2 differently sized bricks\n              var ratio = 0.6 + this.random() * 0.2; // Between 0.6-0.8\n              rowPattern = [ratio, 1 - ratio];\n            } else {\n              // Use 3 bricks with middle one possibly larger\n              var middleRatio = 0.4 + this.random() * 0.2; // 0.4-0.6\n              var sideRatio = (1 - middleRatio) / 2;\n              rowPattern = [sideRatio, middleRatio, sideRatio];\n            }\n          }\n          selectedPattern.push(rowPattern);\n        }\n      } else {\n        // Use one of the predefined patterns\n        var patternIndex = Math.min(Math.floor(this.random() * patterns.length), patterns.length - 1);\n        selectedPattern = patterns[patternIndex];\n\n        // If rows don't match pattern, repeat pattern rows\n        if (selectedPattern.length < this.rows) {\n          var basePattern = _toConsumableArray(selectedPattern);\n          for (var _r = selectedPattern.length; _r < this.rows; _r++) {\n            selectedPattern.push(basePattern[_r % basePattern.length]);\n          }\n        }\n      }\n\n      // Generate bricks using the pattern\n      var bricks = [];\n      for (var row = 0; row < this.rows; row++) {\n        // Get row pattern (or create fallback if missing)\n        var _rowPattern = selectedPattern[row] || Array(this.columns).fill(1 / this.columns);\n\n        // Calculate y position\n        var yPos = -halfSize + row * rowHeight;\n\n        // Starting x position\n        var xPos = -halfSize;\n\n        // Place bricks according to pattern\n        for (var i = 0; i < _rowPattern.length; i++) {\n          // Calculate width based on pattern proportion\n          var widthProportion = _rowPattern[i];\n          var brickWidth = squareSize * widthProportion;\n\n          // Create brick with calculated dimensions\n          var brick = \"<rect \\n                    x=\\\"\".concat(xPos + this.gapSize / 2, \"\\\" \\n                    y=\\\"\").concat(yPos + this.gapSize / 2, \"\\\" \\n                    width=\\\"\").concat(brickWidth - this.gapSize, \"\\\" \\n                    height=\\\"\").concat(rowHeight - this.gapSize, \"\\\"\\n                    rx=\\\"\").concat(this.cornerRadius, \"\\\"\\n                    ry=\\\"\").concat(this.cornerRadius, \"\\\"\\n                    fill=\\\"white\\\"\\n                    stroke=\\\"none\\\"\\n                />\");\n          bricks.push(brick);\n\n          // Move x position\n          xPos += brickWidth;\n        }\n      }\n      return bricks.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BrickWall, \"parameters\", {\n  rows: {\n    min: 1,\n    max: 12,\n    \"default\": 4\n  },\n  columns: {\n    min: 1,\n    max: 12,\n    \"default\": 3\n  },\n  gapSize: {\n    min: 1,\n    max: 10,\n    \"default\": 6\n  },\n  cornerRadius: {\n    min: 0,\n    max: 10,\n    \"default\": 5\n  },\n  randomLayout: {\n    options: ['true', 'false'],\n    \"default\": 'true'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrickWall);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/BrickWall.js?");

/***/ }),

/***/ "./src/shapes/ChaliceShape.js":
/*!************************************!*\
  !*** ./src/shapes/ChaliceShape.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ChaliceShape = /*#__PURE__*/function (_Shape) {\n  function ChaliceShape() {\n    _classCallCheck(this, ChaliceShape);\n    return _callSuper(this, ChaliceShape, arguments);\n  }\n  _inherits(ChaliceShape, _Shape);\n  return _createClass(ChaliceShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Scale to fit the -200 to 200 viewBox\n      var scale = 1;\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Apply scaling to parameters\n      var bowlWidth = this.bowlWidth * scale;\n      var bowlHeight = this.bowlHeight * scale;\n      var stemWidth = this.stemWidth * scale;\n      var baseWidth = this.baseWidth * scale;\n      var curvature = this.curvature;\n\n      // Calculate key points\n      var topY = center.y - bowlHeight / 2;\n      var bottomY = center.y + bowlHeight / 2;\n      var stemHeight = bowlHeight * 0.4;\n\n      // Bowl top points\n      var bowlLeftTop = {\n        x: center.x - bowlWidth / 2,\n        y: topY\n      };\n      var bowlRightTop = {\n        x: center.x + bowlWidth / 2,\n        y: topY\n      };\n\n      // Stem connection points\n      var stemLeftTop = {\n        x: center.x - stemWidth / 2,\n        y: bottomY - stemHeight\n      };\n      var stemRightTop = {\n        x: center.x + stemWidth / 2,\n        y: bottomY - stemHeight\n      };\n\n      // Base points\n      var baseLeftTop = {\n        x: center.x - baseWidth / 2,\n        y: bottomY\n      };\n      var baseRightTop = {\n        x: center.x + baseWidth / 2,\n        y: bottomY\n      };\n\n      // Control points for bowl curves\n      var controlPoint1 = {\n        x: bowlLeftTop.x,\n        y: topY + bowlHeight * curvature\n      };\n      var controlPoint2 = {\n        x: stemLeftTop.x,\n        y: stemLeftTop.y - bowlHeight * curvature\n      };\n      var controlPoint3 = {\n        x: stemRightTop.x,\n        y: stemRightTop.y - bowlHeight * curvature\n      };\n      var controlPoint4 = {\n        x: bowlRightTop.x,\n        y: topY + bowlHeight * curvature\n      };\n\n      // Generate SVG path\n      var pathCommands = [// Start at left top of bowl\n      \"M \".concat(bowlLeftTop.x, \" \").concat(bowlLeftTop.y), // Left bowl curve\n      \"C \".concat(controlPoint1.x, \" \").concat(controlPoint1.y, \" \").concat(controlPoint2.x, \" \").concat(controlPoint2.y, \" \").concat(stemLeftTop.x, \" \").concat(stemLeftTop.y), // Stem to base\n      \"L \".concat(baseLeftTop.x, \" \").concat(baseLeftTop.y), \"L \".concat(baseRightTop.x, \" \").concat(baseRightTop.y), \"L \".concat(stemRightTop.x, \" \").concat(stemRightTop.y), // Right bowl curve\n      \"C \".concat(controlPoint3.x, \" \").concat(controlPoint3.y, \" \").concat(controlPoint4.x, \" \").concat(controlPoint4.y, \" \").concat(bowlRightTop.x, \" \").concat(bowlRightTop.y),\n      // Close path\n      'Z'];\n      return \"<path \\n            d=\\\"\".concat(pathCommands.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ChaliceShape, \"parameters\", {\n  bowlWidth: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  bowlHeight: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  stemWidth: {\n    min: 20,\n    max: 100,\n    \"default\": 40\n  },\n  baseWidth: {\n    min: 40,\n    max: 200,\n    \"default\": 80\n  },\n  curvature: {\n    min: 0,\n    max: 1,\n    \"default\": 0.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChaliceShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ChaliceShape.js?");

/***/ }),

/***/ "./src/shapes/CheckerPattern.js":
/*!**************************************!*\
  !*** ./src/shapes/CheckerPattern.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CheckerPattern = /*#__PURE__*/function (_Shape) {\n  function CheckerPattern() {\n    _classCallCheck(this, CheckerPattern);\n    return _callSuper(this, CheckerPattern, arguments);\n  }\n  _inherits(CheckerPattern, _Shape);\n  return _createClass(CheckerPattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var squares = [];\n      var totalSize = this.count * this.size;\n      var offset = -totalSize / 2;\n\n      // Keep track of the previous row's position and height\n      var previousY = offset;\n      for (var row = 0; row < this.count; row++) {\n        // Calculate vertical scaling based on row position\n        var rowProgress = row / (this.count - 1);\n        var scale = 1 - rowProgress * this.scaleY / 100;\n        for (var col = 0; col < this.count; col++) {\n          if ((row + col) % 2 === 0) {\n            var x = offset + col * this.size;\n            // Instead of calculating y with spacing, use the tracked position\n            var height = this.size * scale;\n            squares.push(\"<rect \\n                        x=\\\"\".concat(x, \"\\\" \\n                        y=\\\"\").concat(previousY, \"\\\" \\n                        width=\\\"\").concat(this.size, \"\\\"\\n                        height=\\\"\").concat(height, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\"));\n          }\n        }\n        previousY += this.size * scale;\n      }\n      return squares.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CheckerPattern, \"parameters\", {\n  size: {\n    min: 25,\n    max: 50,\n    \"default\": 40\n  },\n  count: {\n    min: 2,\n    max: 12,\n    \"default\": 4\n  },\n  scaleY: {\n    min: 0,\n    max: 100,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CheckerPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CheckerPattern.js?");

/***/ }),

/***/ "./src/shapes/CircleComposition.js":
/*!*****************************************!*\
  !*** ./src/shapes/CircleComposition.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CircleComposition = /*#__PURE__*/function (_Shape) {\n  function CircleComposition() {\n    _classCallCheck(this, CircleComposition);\n    return _callSuper(this, CircleComposition, arguments);\n  }\n  _inherits(CircleComposition, _Shape);\n  return _createClass(CircleComposition, [{\n    key: \"calculateDynamicSizes\",\n    value: function calculateDynamicSizes(baseSize, balance, thickness) {\n      // Balance affects the relationship between center and side circles\n      var balanceFactor = balance / 100;\n      var thicknessFactor = thickness / 100;\n      var centerScale = 0.8 + balanceFactor * 0.4;\n      var sideScale = 1.0 - balanceFactor * 0.3;\n      var innerScale = 1.0 - thicknessFactor;\n      return {\n        center: baseSize * centerScale,\n        side: baseSize * sideScale,\n        inner: baseSize * centerScale * innerScale\n      };\n    }\n  }, {\n    key: \"createRing\",\n    value: function createRing(cx, cy, outerRadius, innerRadius) {\n      if (innerRadius <= 0) {\n        return \"<circle \\n                cx=\\\"\".concat(cx, \"\\\" \\n                cy=\\\"\").concat(cy, \"\\\" \\n                r=\\\"\").concat(outerRadius, \"\\\"\\n                fill=\\\"white\\\"\\n            />\");\n      }\n      return \"<path\\n            d=\\\"\\n                M \".concat(cx - outerRadius, \" \").concat(cy, \"\\n                A \").concat(outerRadius, \" \").concat(outerRadius, \" 0 1 1 \").concat(cx + outerRadius, \" \").concat(cy, \"\\n                A \").concat(outerRadius, \" \").concat(outerRadius, \" 0 1 1 \").concat(cx - outerRadius, \" \").concat(cy, \"\\n                M \").concat(cx - innerRadius, \" \").concat(cy, \"\\n                A \").concat(innerRadius, \" \").concat(innerRadius, \" 0 1 0 \").concat(cx + innerRadius, \" \").concat(cy, \"\\n                A \").concat(innerRadius, \" \").concat(innerRadius, \" 0 1 0 \").concat(cx - innerRadius, \" \").concat(cy, \"\\n            \\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }, {\n    key: \"createSemiRing\",\n    value: function createSemiRing(cx, cy, outerRadius, innerRadius, startAngle, endAngle) {\n      var startX = cx + outerRadius * Math.cos(startAngle);\n      var startY = cy + outerRadius * Math.sin(startAngle);\n      var endX = cx + outerRadius * Math.cos(endAngle);\n      var endY = cy + outerRadius * Math.sin(endAngle);\n      var d = \"M \".concat(startX, \" \").concat(startY);\n\n      // Outer arc\n      var largeArcFlag = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      d += \" A \".concat(outerRadius, \" \").concat(outerRadius, \" 0 \").concat(largeArcFlag, \" 1 \").concat(endX, \" \").concat(endY);\n      if (innerRadius > 0) {\n        // Inner arc\n        var innerStartX = cx + innerRadius * Math.cos(endAngle);\n        var innerStartY = cy + innerRadius * Math.sin(endAngle);\n        var innerEndX = cx + innerRadius * Math.cos(startAngle);\n        var innerEndY = cy + innerRadius * Math.sin(startAngle);\n        d += \" L \".concat(innerStartX, \" \").concat(innerStartY);\n        d += \" A \".concat(innerRadius, \" \").concat(innerRadius, \" 0 \").concat(largeArcFlag, \" 0 \").concat(innerEndX, \" \").concat(innerEndY);\n      } else {\n        // If no inner radius, connect to center\n        d += \" L \".concat(cx, \" \").concat(cy);\n      }\n      d += ' Z';\n      return \"<path d=\\\"\".concat(d, \"\\\" fill=\\\"white\\\"/>\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 1.5; // Scale factor if needed\n      var baseCenterSize = this.centerSize * scale;\n      var overlap = this.overlap * scale;\n\n      // Calculate dynamic sizes\n      var sizes = this.calculateDynamicSizes(baseCenterSize, this.balance, this.thickness);\n      var centerSize = sizes.center;\n      var innerSize = sizes.inner;\n      var effectiveSideRadius = sizes.side * this.sideRadius;\n      var effectiveSideInnerRadius = effectiveSideRadius * (1 - this.thickness / 100);\n\n      // Calculate spacing\n      var spacing = Math.max(-centerSize / 4, Math.min(centerSize / 2, overlap));\n\n      // Create center ring\n      var elements = [];\n      elements.push(this.createRing(0, 0, centerSize / 2, innerSize / 2));\n\n      // Add left semi-ring\n      var leftCenterX = -centerSize / 2 - spacing;\n      elements.push(this.createSemiRing(leftCenterX, 0, effectiveSideRadius, effectiveSideInnerRadius, Math.PI / 2, -Math.PI / 2));\n\n      // Add right semi-ring\n      var rightCenterX = centerSize / 2 + spacing;\n      elements.push(this.createSemiRing(rightCenterX, 0, effectiveSideRadius, effectiveSideInnerRadius, -Math.PI / 2, Math.PI / 2));\n      return elements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CircleComposition, \"parameters\", {\n  centerSize: {\n    min: 25,\n    max: 50,\n    \"default\": 40\n  },\n  sideRadius: {\n    min: 0.5,\n    max: 1.5,\n    \"default\": 1.0\n  },\n  overlap: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  },\n  thickness: {\n    min: 10,\n    max: 100,\n    \"default\": 50\n  },\n  balance: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleComposition);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CircleComposition.js?");

/***/ }),

/***/ "./src/shapes/CirclePacking.js":
/*!*************************************!*\
  !*** ./src/shapes/CirclePacking.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CirclePacking = /*#__PURE__*/function (_Shape) {\n  function CirclePacking() {\n    _classCallCheck(this, CirclePacking);\n    return _callSuper(this, CirclePacking, arguments);\n  }\n  _inherits(CirclePacking, _Shape);\n  return _createClass(CirclePacking, [{\n    key: \"canPlaceCircle\",\n    value:\n    // Remove custom RNG methods as they're now inherited from Shape\n\n    // Try to place a new circle with the given radius\n    function canPlaceCircle(circles, x, y, radius) {\n      // Check if within container\n      var distanceFromCenter = Math.sqrt(x * x + y * y);\n      if (distanceFromCenter + radius > this.containerRadius) {\n        return false;\n      }\n\n      // Check if overlapping with any existing circle\n      var _iterator = _createForOfIteratorHelper(circles),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var circle = _step.value;\n          var dx = circle.x - x;\n          var dy = circle.y - y;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          if (distance < circle.radius + radius + this.spacing) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true;\n    }\n\n    // Attempt to place a circle with given radius\n  }, {\n    key: \"tryPlaceCircle\",\n    value: function tryPlaceCircle(circles, radius) {\n      for (var i = 0; i < this.placementAttempts; i++) {\n        // Random angle and distance from center - using seeded randomness\n        var angle = this.random() * 2 * Math.PI;\n        var distance = this.random() * (this.containerRadius - radius);\n        var x = distance * Math.cos(angle);\n        var y = distance * Math.sin(angle);\n        if (this.canPlaceCircle(circles, x, y, radius)) {\n          return {\n            x: x,\n            y: y,\n            radius: radius\n          };\n        }\n      }\n      return null;\n    }\n\n    // Generate circle placements once, then reuse them with spacing adjustments\n  }, {\n    key: \"getCirclePlacements\",\n    value: function getCirclePlacements() {\n      // Reset RNG to initial seed to ensure consistency\n      this.resetRNG();\n      var circles = [];\n      var remainingAttempts = this.circleCount * 3; // Allow extra attempts\n\n      // Start with larger circles\n      while (circles.length < this.circleCount && remainingAttempts > 0) {\n        remainingAttempts--;\n\n        // Vary radius between min and max, favoring smaller circles as we add more\n        var progressFactor = circles.length / this.circleCount;\n        var bias = 0.3 + progressFactor * 0.7; // Starts at 0.3, approaches 1.0\n\n        // Generate radius with bias toward smaller sizes as we progress\n        var radius = this.maxRadius - (this.maxRadius - this.minRadius) * Math.pow(this.random(), 1 - bias);\n        var circle = this.tryPlaceCircle(circles, radius);\n        if (circle) {\n          circles.push(circle);\n        }\n      }\n      return circles;\n    }\n\n    // Check if circles are still valid with current spacing\n  }, {\n    key: \"validateCirclesWithSpacing\",\n    value: function validateCirclesWithSpacing(circles) {\n      // First check each circle against container\n      var _iterator2 = _createForOfIteratorHelper(circles),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var circle = _step2.value;\n          var distanceFromCenter = Math.sqrt(circle.x * circle.x + circle.y * circle.y);\n          if (distanceFromCenter + circle.radius > this.containerRadius) {\n            return false;\n          }\n        }\n\n        // Then check circles against each other\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      for (var i = 0; i < circles.length; i++) {\n        for (var j = i + 1; j < circles.length; j++) {\n          var c1 = circles[i];\n          var c2 = circles[j];\n          var dx = c1.x - c2.x;\n          var dy = c1.y - c2.y;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          if (distance < c1.radius + c2.radius + this.spacing) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Get or calculate circle placements\n      if (!this.circlePlacements) {\n        this.circlePlacements = this.getCirclePlacements();\n      }\n\n      // Make a deep copy of the placements\n      var circles = JSON.parse(JSON.stringify(this.circlePlacements));\n\n      // If circles are invalid with current spacing, regenerate them\n      if (!this.validateCirclesWithSpacing(circles)) {\n        this.circlePlacements = this.getCirclePlacements();\n        var newCircles = JSON.parse(JSON.stringify(this.circlePlacements));\n\n        // If still invalid, use a subset that works\n        if (!this.validateCirclesWithSpacing(newCircles)) {\n          // Sort by size and take only the circles that fit\n          newCircles.sort(function (a, b) {\n            return b.radius - a.radius;\n          });\n          var validCircles = [];\n          var _iterator3 = _createForOfIteratorHelper(newCircles),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var circle = _step3.value;\n              if (this.canPlaceCircle(validCircles, circle.x, circle.y, circle.radius)) {\n                validCircles.push(circle);\n              }\n              if (validCircles.length >= this.circleCount) break;\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          return this.renderCircles(validCircles);\n        }\n        return this.renderCircles(newCircles);\n      }\n      return this.renderCircles(circles);\n    }\n  }, {\n    key: \"renderCircles\",\n    value: function renderCircles(circles) {\n      // Generate SVG elements\n      var svgElements = circles.map(function (circle) {\n        return \"<circle \\n                cx=\\\"\".concat(circle.x, \"\\\" \\n                cy=\\\"\").concat(circle.y, \"\\\" \\n                r=\\\"\").concat(circle.radius, \"\\\"\\n                fill=\\\"white\\\"\\n            />\");\n      });\n      return svgElements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CirclePacking, \"parameters\", {\n  containerRadius: {\n    min: 50,\n    max: 100,\n    \"default\": 80\n  },\n  circleCount: {\n    min: 3,\n    max: 50,\n    \"default\": 10\n  },\n  minRadius: {\n    min: 5,\n    max: 15,\n    \"default\": 10\n  },\n  maxRadius: {\n    min: 15,\n    max: 80,\n    \"default\": 50\n  },\n  spacing: {\n    min: 0,\n    max: 10,\n    \"default\": 2\n  },\n  placementAttempts: {\n    min: 50,\n    max: 1000,\n    \"default\": 200\n  }\n  // seed parameter is now inherited from Shape class\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CirclePacking);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CirclePacking.js?");

/***/ }),

/***/ "./src/shapes/CircleStack.js":
/*!***********************************!*\
  !*** ./src/shapes/CircleStack.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CircleStack = /*#__PURE__*/function (_Shape) {\n  function CircleStack() {\n    _classCallCheck(this, CircleStack);\n    return _callSuper(this, CircleStack, arguments);\n  }\n  _inherits(CircleStack, _Shape);\n  return _createClass(CircleStack, [{\n    key: \"createCircle\",\n    value: function createCircle(cx, cy, size) {\n      return \"<circle \\n            cx=\\\"\".concat(cx, \"\\\" \\n            cy=\\\"\").concat(cy, \"\\\" \\n            r=\\\"\").concat(size / 2, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }, {\n    key: \"createStack\",\n    value: function createStack(centerX, mainSize, endSize, spacing) {\n      var elements = [];\n\n      // Main circle\n      elements.push(this.createCircle(centerX, 0, mainSize));\n\n      // Top small circle\n      elements.push(this.createCircle(centerX, -(mainSize / 2 + endSize / 2 + spacing), endSize));\n\n      // Bottom small circle\n      elements.push(this.createCircle(centerX, mainSize / 2 + endSize / 2 + spacing, endSize));\n      return elements;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n      var mainSize = this.mainSize * scale;\n      var endSize = this.endSize * scale;\n      var spacing = this.spacing * scale;\n      var overlap = this.overlap * scale;\n      var elements = [];\n\n      // Left stack\n      var leftCenterX = -mainSize / 2 + overlap / 2;\n      elements.push.apply(elements, _toConsumableArray(this.createStack(leftCenterX, mainSize, endSize, spacing)));\n\n      // Right stack\n      var rightCenterX = mainSize / 2 - overlap / 2;\n      elements.push.apply(elements, _toConsumableArray(this.createStack(rightCenterX, mainSize, endSize, spacing)));\n      return elements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CircleStack, \"parameters\", {\n  mainSize: {\n    min: 40,\n    max: 120,\n    \"default\": 120\n  },\n  endSize: {\n    min: 20,\n    max: 100,\n    \"default\": 55\n  },\n  spacing: {\n    min: -20,\n    max: 20,\n    \"default\": -12\n  },\n  overlap: {\n    min: 0,\n    max: 40,\n    \"default\": 25\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleStack);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CircleStack.js?");

/***/ }),

/***/ "./src/shapes/CirclesComposition.js":
/*!******************************************!*\
  !*** ./src/shapes/CirclesComposition.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CirclesComposition = /*#__PURE__*/function (_Shape) {\n  function CirclesComposition() {\n    _classCallCheck(this, CirclesComposition);\n    return _callSuper(this, CirclesComposition, arguments);\n  }\n  _inherits(CirclesComposition, _Shape);\n  return _createClass(CirclesComposition, [{\n    key: \"createCircle\",\n    value: function createCircle(cx, cy, size) {\n      return \"<circle \\n            cx=\\\"\".concat(cx, \"\\\" \\n            cy=\\\"\").concat(cy, \"\\\" \\n            r=\\\"\").concat(size / 2, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.lineThickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n        />\");\n    }\n  }, {\n    key: \"createLine\",\n    value: function createLine(x1, y1, x2, y2) {\n      return \"<line \\n            x1=\\\"\".concat(x1, \"\\\" \\n            y1=\\\"\").concat(y1, \"\\\" \\n            x2=\\\"\").concat(x2, \"\\\" \\n            y2=\\\"\").concat(y2, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.lineThickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n        />\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var circleCount = Math.round(this.circleCount);\n      var scale = 0.8;\n      var circleSize = this.circleSize * scale;\n      var spacing = this.spacing * scale;\n      var innerRadius = this.innerRadius * spacing;\n\n      // Draw outer circles and connections\n      for (var i = 0; i < circleCount; i++) {\n        var angle = i / circleCount * 2 * Math.PI;\n        var nextAngle = (i + 1) / circleCount * 2 * Math.PI;\n\n        // Calculate current point\n        var x = Math.cos(angle) * spacing;\n        var y = Math.sin(angle) * spacing;\n\n        // Calculate next point for connecting line\n        var nextX = Math.cos(nextAngle) * spacing;\n        var nextY = Math.sin(nextAngle) * spacing;\n\n        // Calculate inner point for center connection\n        var innerX = Math.cos(angle) * innerRadius;\n        var innerY = Math.sin(angle) * innerRadius;\n\n        // Add outer circle\n        elements.push(this.createCircle(x, y, circleSize));\n\n        // Add line to center\n        elements.push(this.createLine(x, y, innerX, innerY));\n\n        // Add connecting line to next circle\n        elements.push(this.createLine(x, y, nextX, nextY));\n      }\n\n      // Add center circle\n      elements.push(this.createCircle(0, 0, circleSize));\n      return elements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CirclesComposition, \"parameters\", {\n  circleCount: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  circleSize: {\n    min: 40,\n    max: 80,\n    \"default\": 60\n  },\n  lineThickness: {\n    min: 2,\n    max: 10,\n    \"default\": 4\n  },\n  spacing: {\n    min: 40,\n    max: 120,\n    \"default\": 80\n  },\n  innerRadius: {\n    min: 0.3,\n    max: 0.8,\n    \"default\": 0.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CirclesComposition);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CirclesComposition.js?");

/***/ }),

/***/ "./src/shapes/ClassicSmileyShape.js":
/*!******************************************!*\
  !*** ./src/shapes/ClassicSmileyShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ClassicSmileyShape = /*#__PURE__*/function (_Shape) {\n  function ClassicSmileyShape() {\n    _classCallCheck(this, ClassicSmileyShape);\n    return _callSuper(this, ClassicSmileyShape, arguments);\n  }\n  _inherits(ClassicSmileyShape, _Shape);\n  return _createClass(ClassicSmileyShape, [{\n    key: \"getFillAttributes\",\n    value: function getFillAttributes() {\n      switch (this.fillStyle) {\n        case 'filled':\n          return {\n            faceFill: 'white',\n            featureFill: 'black',\n            stroke: 'none'\n          };\n        default:\n          // outline\n          return {\n            faceFill: 'none',\n            featureFill: 'white',\n            stroke: 'white'\n          };\n      }\n    }\n  }, {\n    key: \"interpolateSmile\",\n    value: function interpolateSmile(emotion) {\n      // Convert emotion (-100 to 100) to a normalized range (0 to 1)\n      var t = (emotion + 100) / 200;\n\n      // Define smile characteristics at different emotional states\n      var sad = {\n        width: 0.4,\n        height: -0.15,\n        yPos: 0.3\n      };\n      var neutral = {\n        width: 0.45,\n        height: 0,\n        yPos: 0.2\n      };\n      var happy = {\n        width: 0.5,\n        height: 0.25,\n        yPos: 0.15\n      };\n\n      // Interpolate between sad and neutral for negative emotions\n      // or between neutral and happy for positive emotions\n      if (emotion < 0) {\n        var subT = (emotion + 100) / 100; // 0 to 1 for sad to neutral\n        return {\n          width: sad.width + (neutral.width - sad.width) * subT,\n          height: sad.height + (neutral.height - sad.height) * subT,\n          yPos: sad.yPos + (neutral.yPos - sad.yPos) * subT\n        };\n      } else {\n        var _subT = emotion / 100; // 0 to 1 for neutral to happy\n        return {\n          width: neutral.width + (happy.width - neutral.width) * _subT,\n          height: neutral.height + (happy.height - neutral.height) * _subT,\n          yPos: neutral.yPos + (happy.yPos - neutral.yPos) * _subT\n        };\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var radius = this.size / 2;\n      var fill = this.getFillAttributes();\n      var elements = [];\n\n      // Face circle\n      if (fill.doubleStroke) {\n        elements.push(\"<circle \\n                cx=\\\"0\\\" \\n                cy=\\\"0\\\" \\n                r=\\\"\".concat(radius + this.borderThickness, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.borderThickness, \"\\\"\\n            />\"));\n      }\n      elements.push(\"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(radius, \"\\\"\\n            fill=\\\"\").concat(fill.faceFill, \"\\\"\\n            stroke=\\\"\").concat(fill.stroke, \"\\\"\\n            stroke-width=\\\"\").concat(this.borderThickness, \"\\\"\\n        />\"));\n\n      // Calculate eye positions with rotation\n      var eyeRadians = this.eyeAngle * Math.PI / 180;\n      var baseEyeX = radius * this.eyeSpacing / 100;\n      var baseEyeY = radius * this.eyeY / 100;\n      var eyeWidthPx = radius * this.eyeWidth / 100;\n      var eyeHeightPx = radius * this.eyeHeight / 100;\n\n      // Eyes with rotation\n      ['left', 'right'].forEach(function (side) {\n        var xMult = side === 'left' ? -1 : 1;\n        var rotatedX = baseEyeX * Math.cos(eyeRadians) - baseEyeY * Math.sin(eyeRadians);\n        var rotatedY = baseEyeX * Math.sin(eyeRadians) + baseEyeY * Math.cos(eyeRadians);\n        var eyeElement = \"<ellipse\\n                transform=\\\"rotate(\".concat(_this.eyeAngle, \")\\\"\\n                cx=\\\"\").concat(xMult * rotatedX, \"\\\"\\n                cy=\\\"\").concat(rotatedY, \"\\\"\\n                rx=\\\"\").concat(eyeWidthPx / 2, \"\\\"\\n                ry=\\\"\").concat(eyeHeightPx / 2, \"\\\"\\n                fill=\\\"\").concat(fill.featureFill, \"\\\"\");\n\n        // Add blinking animation \n        eyeElement += \">\\n                    <animate \\n                        attributeName=\\\"ry\\\" \\n                        values=\\\"\".concat(eyeHeightPx / 2, \";\").concat(eyeHeightPx / 2, \";1;\").concat(eyeHeightPx / 2, \"\\\" \\n                        keyTimes=\\\"0;0.85;0.9;1\\\"\\n                        dur=\\\"\").concat(_this.blinkInterval, \"s\\\" \\n                        repeatCount=\\\"indefinite\\\" \\n                    />\\n                </ellipse>\");\n        elements.push(eyeElement);\n      });\n\n      // Generate interpolated smile (static, no animation)\n      var smile = this.interpolateSmile(this.emotion);\n      var smileWidth = radius * smile.width * 2;\n      var startX = -smileWidth / 2;\n      var endX = smileWidth / 2;\n      var centerY = radius * smile.yPos;\n\n      // Calculate control points for the smile curve\n      var curveHeight = radius * smile.height;\n      var cp1x = startX + smileWidth * 0.25;\n      var cp2x = endX - smileWidth * 0.25;\n      var cp1y = centerY + curveHeight;\n      var cp2y = centerY + curveHeight;\n      elements.push(\"<path \\n            d=\\\"M \".concat(startX, \" \").concat(centerY, \"\\n               C \").concat(cp1x, \" \").concat(cp1y, \", \").concat(cp2x, \" \").concat(cp2y, \", \").concat(endX, \" \").concat(centerY, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"\").concat(fill.featureFill, \"\\\"\\n            stroke-width=\\\"\").concat(this.borderThickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n        />\"));\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ClassicSmileyShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 200\n  },\n  borderThickness: {\n    min: 1,\n    max: 10,\n    \"default\": 5\n  },\n  emotion: {\n    min: -100,\n    max: 100,\n    \"default\": 100\n  },\n  // -100 = sad, 0 = neutral, 100 = happy\n  // Eye controls\n  eyeWidth: {\n    min: 5,\n    max: 50,\n    \"default\": 15\n  },\n  eyeHeight: {\n    min: 5,\n    max: 50,\n    \"default\": 35\n  },\n  eyeSpacing: {\n    min: 10,\n    max: 100,\n    \"default\": 25\n  },\n  eyeAngle: {\n    min: -45,\n    max: 45,\n    \"default\": 0\n  },\n  eyeY: {\n    min: -50,\n    max: 50,\n    \"default\": -20\n  },\n  blinkInterval: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  // Style options\n  fillStyle: {\n    options: ['outline', 'filled'],\n    \"default\": 'filled'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ClassicSmileyShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ClassicSmileyShape.js?");

/***/ }),

/***/ "./src/shapes/CloverCross.js":
/*!***********************************!*\
  !*** ./src/shapes/CloverCross.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CloverCross = /*#__PURE__*/function (_Shape) {\n  function CloverCross() {\n    _classCallCheck(this, CloverCross);\n    return _callSuper(this, CloverCross, arguments);\n  }\n  _inherits(CloverCross, _Shape);\n  return _createClass(CloverCross, [{\n    key: \"createLobe\",\n    value: function createLobe(cx, cy, radius) {\n      return \"<circle \\n            cx=\\\"\".concat(cx, \"\\\" \\n            cy=\\\"\").concat(cy, \"\\\" \\n            r=\\\"\").concat(radius / 2, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }, {\n    key: \"createRoundedRect\",\n    value: function createRoundedRect(x, y, width, height, radius) {\n      return \"<rect \\n            x=\\\"\".concat(x, \"\\\" \\n            y=\\\"\").concat(y, \"\\\" \\n            width=\\\"\").concat(width, \"\\\" \\n            height=\\\"\").concat(height, \"\\\" \\n            rx=\\\"\").concat(radius, \"\\\"\\n            ry=\\\"\").concat(radius, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var scale = 1;\n\n      // Scale parameters\n      var lobeSize = this.lobeSize * scale;\n      var crossThickness = Math.min(this.crossThickness * scale, lobeSize * 0.5);\n      var lobeRoundness = Math.min(this.lobeRoundness, 1.0);\n      var crossExtension = this.crossExtension;\n\n      // Calculate dimensions\n      var lobeRadius = lobeSize * lobeRoundness;\n      var lobeOffset = lobeSize * 0.6; // Reduced offset for more compact shape\n\n      // Create the four circular lobes\n      for (var angle = 0; angle < 360; angle += 90) {\n        var radian = angle * Math.PI / 180;\n        var lobeCenterX = Math.cos(radian) * lobeOffset;\n        var lobeCenterY = Math.sin(radian) * lobeOffset;\n        elements.push(this.createLobe(lobeCenterX, lobeCenterY, lobeRadius));\n      }\n\n      // Calculate cross dimensions\n      var crossLength = lobeSize * crossExtension * 1.2;\n\n      // Add vertical bar with rounded ends\n      elements.push(this.createRoundedRect(-crossThickness / 2, -crossLength / 2, crossThickness, crossLength, crossThickness / 2));\n\n      // Add horizontal bar with rounded ends\n      elements.push(this.createRoundedRect(-crossLength / 2, -crossThickness / 2, crossLength, crossThickness, crossThickness / 2));\n      return elements.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CloverCross, \"parameters\", {\n  lobeSize: {\n    min: 30,\n    max: 150,\n    \"default\": 80\n  },\n  crossThickness: {\n    min: 10,\n    max: 50,\n    \"default\": 25\n  },\n  lobeRoundness: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.6\n  },\n  crossExtension: {\n    min: 0.5,\n    max: 1.5,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CloverCross);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CloverCross.js?");

/***/ }),

/***/ "./src/shapes/ConcaveStarShape.js":
/*!****************************************!*\
  !*** ./src/shapes/ConcaveStarShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ConcaveStarShape = /*#__PURE__*/function (_Shape) {\n  function ConcaveStarShape() {\n    _classCallCheck(this, ConcaveStarShape);\n    return _callSuper(this, ConcaveStarShape, arguments);\n  }\n  _inherits(ConcaveStarShape, _Shape);\n  return _createClass(ConcaveStarShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var centerX = 0;\n      var centerY = 0;\n      var radius = 100;\n\n      // Convert rotation to radians\n      var rotationRad = this.rotation * Math.PI / 180;\n      var numberOfPoints = Math.floor(this.points);\n      var pathCommands = [];\n\n      // Generate points and curves\n      for (var i = 0; i <= numberOfPoints * 2; i++) {\n        var angle = i * Math.PI / numberOfPoints + rotationRad;\n        var currentRadius = i % 2 === 0 ? radius : radius * (1 - this.innerDepth);\n        var point = {\n          x: centerX + Math.cos(angle) * currentRadius,\n          y: centerY + Math.sin(angle) * currentRadius\n        };\n        if (i === 0) {\n          // Move to first point\n          pathCommands.push(\"M \".concat(point.x, \" \").concat(point.y));\n        } else {\n          // Calculate previous point data\n          var prevAngle = (i - 1) * Math.PI / numberOfPoints + rotationRad;\n          var prevRadius = (i - 1) % 2 === 0 ? radius : radius * (1 - this.innerDepth);\n          var prevPoint = {\n            x: centerX + Math.cos(prevAngle) * prevRadius,\n            y: centerY + Math.sin(prevAngle) * prevRadius\n          };\n\n          // Calculate control points using angle bisector\n          var _midAngle = (prevAngle + angle) / 2;\n          var _controlDistance = this.sharpness * currentRadius * 0.5;\n          var control1 = {\n            x: prevPoint.x + Math.cos(_midAngle) * _controlDistance,\n            y: prevPoint.y + Math.sin(_midAngle) * _controlDistance\n          };\n          var control2 = {\n            x: point.x - Math.cos(_midAngle) * _controlDistance,\n            y: point.y - Math.sin(_midAngle) * _controlDistance\n          };\n\n          // Add cubic Bzier curve\n          pathCommands.push(\"C \".concat(control1.x, \" \").concat(control1.y, \", \").concat(control2.x, \" \").concat(control2.y, \", \").concat(point.x, \" \").concat(point.y));\n        }\n      }\n\n      // Close the path with a final curve back to the start\n      var firstPoint = {\n        x: centerX + Math.cos(rotationRad) * radius,\n        y: centerY + Math.sin(rotationRad) * radius\n      };\n      var lastAngle = numberOfPoints * 2 * Math.PI / numberOfPoints + rotationRad;\n      var midAngle = (lastAngle + (rotationRad + 2 * Math.PI)) / 2;\n      var controlDistance = this.sharpness * radius * 0.5;\n      var lastPoint = {\n        x: centerX + Math.cos(lastAngle) * (radius * (1 - this.innerDepth)),\n        y: centerY + Math.sin(lastAngle) * (radius * (1 - this.innerDepth))\n      };\n      var finalControl1 = {\n        x: lastPoint.x + Math.cos(midAngle) * controlDistance,\n        y: lastPoint.y + Math.sin(midAngle) * controlDistance\n      };\n      var finalControl2 = {\n        x: firstPoint.x - Math.cos(midAngle) * controlDistance,\n        y: firstPoint.y - Math.sin(midAngle) * controlDistance\n      };\n\n      // Add final curve to close the path\n      pathCommands.push(\"C \".concat(finalControl1.x, \" \").concat(finalControl1.y, \", \").concat(finalControl2.x, \" \").concat(finalControl2.y, \", \").concat(firstPoint.x, \" \").concat(firstPoint.y));\n      return \"<path\\n            d=\\\"\".concat(pathCommands.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcaveStarShape, \"parameters\", {\n  points: {\n    min: 4,\n    max: 16,\n    \"default\": 8\n  },\n  innerDepth: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.3\n  },\n  sharpness: {\n    min: 0.1,\n    max: 2.0,\n    \"default\": 0.7\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 22.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcaveStarShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcaveStarShape.js?");

/***/ }),

/***/ "./src/shapes/ConcentricEllipses.js":
/*!******************************************!*\
  !*** ./src/shapes/ConcentricEllipses.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ConcentricEllipsesShape = /*#__PURE__*/function (_Shape) {\n  function ConcentricEllipsesShape() {\n    _classCallCheck(this, ConcentricEllipsesShape);\n    return _callSuper(this, ConcentricEllipsesShape, arguments);\n  }\n  _inherits(ConcentricEllipsesShape, _Shape);\n  return _createClass(ConcentricEllipsesShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var ellipses = [];\n\n      // Calculate radii for largest and smallest ellipses\n      var outerRx = this.width / 2;\n      var outerRy = this.height / 2;\n      var innerRx = (this.width - (this.count - 1) * this.spacing * 2) / 2;\n      var innerRy = (this.height - (this.count - 1) * this.spacing * 2) / 2;\n\n      // Calculate the maximum safe offset scale\n      // This is the ratio that allows the innermost circle to just touch the edge\n      var maxScaleX = (outerRx - innerRx) / Math.abs(this.xOffset || 1);\n      var maxScaleY = (outerRy - innerRy) / Math.abs(this.yOffset || 1);\n      var safeScale = Math.min(maxScaleX, maxScaleY, this.offsetScale);\n\n      // Calculate base offsets\n      var baseOffsetX = this.xOffset * safeScale;\n      var baseOffsetY = this.yOffset * safeScale;\n      for (var i = 0; i < this.count; i++) {\n        // Calculate current ellipse dimensions\n        var rx = (this.width - i * this.spacing * 2) / 2;\n        var ry = (this.height - i * this.spacing * 2) / 2;\n\n        // Break if ellipse would be too small\n        if (rx <= 0 || ry <= 0) break;\n\n        // Calculate progress for this ring (0 for outer, 1 for inner)\n        var progress = i / (this.count - 1);\n\n        // Apply offset based on progress\n        var cx = baseOffsetX * progress;\n        var cy = baseOffsetY * progress;\n        ellipses.push(\"<ellipse \\n                cx=\\\"\".concat(cx, \"\\\"\\n                cy=\\\"\").concat(cy, \"\\\"\\n                rx=\\\"\").concat(rx, \"\\\"\\n                ry=\\\"\").concat(ry, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            />\"));\n      }\n      return ellipses.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricEllipsesShape, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 200\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 200\n  },\n  count: {\n    min: 2,\n    max: 12,\n    \"default\": 6\n  },\n  spacing: {\n    min: 5,\n    max: 40,\n    \"default\": 20\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  xOffset: {\n    min: -100,\n    max: 100,\n    \"default\": 0\n  },\n  yOffset: {\n    min: -100,\n    max: 100,\n    \"default\": 0\n  },\n  offsetScale: {\n    min: 0,\n    max: 1,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricEllipsesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricEllipses.js?");

/***/ }),

/***/ "./src/shapes/ConcentricFlow.js":
/*!**************************************!*\
  !*** ./src/shapes/ConcentricFlow.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\n/* harmony import */ var _perlin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../perlin.js */ \"./src/perlin.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar ConcentricFlow = /*#__PURE__*/function (_Shape) {\n  function ConcentricFlow() {\n    _classCallCheck(this, ConcentricFlow);\n    return _callSuper(this, ConcentricFlow, arguments);\n  }\n  _inherits(ConcentricFlow, _Shape);\n  return _createClass(ConcentricFlow, [{\n    key: \"getNoise\",\n    value: function getNoise(x, y) {\n      return _perlin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].noise(x * this.noiseScale + this.seed, y * this.noiseScale + this.seed);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.resetRNG();\n      var elements = [];\n\n      // Generate concentric rings with ultra smooth curve rendering\n      for (var r = 0; r < this.ringCount; r++) {\n        var radius = this.innerRadius + (this.outerRadius - this.innerRadius) * (r / (this.ringCount - 1));\n\n        // Generate more points for higher resolution\n        var totalPoints = Math.max(this.pointsPerRing, 200); // Ensure enough points for smoothness\n        var points = [];\n\n        // Generate initial points with noise distortion\n        for (var i = 0; i <= totalPoints; i++) {\n          var angle = i / totalPoints * Math.PI * 2;\n          var baseX = Math.cos(angle) * radius;\n          var baseY = Math.sin(angle) * radius;\n\n          // Apply multi-octave noise for more organic distortion\n          var distortionFactor = this.noiseStrength * (radius / this.outerRadius);\n\n          // Use multiple noise frequencies for more natural look\n          var primaryNoise = this.getNoise(baseX / 50, baseY / 50);\n          var secondaryNoise = this.getNoise(baseX / 25, baseY / 25) * 0.5;\n          var tertiaryNoise = this.getNoise(baseX / 100, baseY / 100) * 0.25;\n          var combinedNoise = (primaryNoise + secondaryNoise + tertiaryNoise) / 1.75;\n          var distortedRadius = radius + combinedNoise * distortionFactor;\n          var x = Math.cos(angle) * distortedRadius;\n          var y = Math.sin(angle) * distortedRadius;\n          points.push({\n            x: x,\n            y: y\n          });\n        }\n\n        // Ensure smooth closure by adding additional points at the beginning/end\n        var firstPoint = points[0];\n        var lastPoint = points[points.length - 1];\n\n        // Close the curve perfectly\n        points.push(_objectSpread({}, firstPoint));\n\n        // Use SVG path commands with tension parameter for optimal smoothness\n        var pathData = \"\";\n\n        // For very small rings, use simplified paths\n        if (radius < this.innerRadius * 1.2) {\n          // Use simple control point calculation for small rings\n          pathData = this.generateSimpleSmoothedPath(points);\n        } else {\n          // Use catmull-rom spline approach for larger rings\n          pathData = this.generateCatmullRomPath(points, this.curveTension);\n        }\n\n        // Add the complete path for this ring\n        if (pathData !== \"\") {\n          elements.push(\"<path \\n                    d=\\\"\".concat(pathData, \"\\\" \\n                    stroke=\\\"white\\\" \\n                    fill=\\\"none\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                    stroke-linejoin=\\\"round\\\"\\n                />\"));\n        }\n      }\n\n      // Add curved arch pattern lines with enhanced smoothness\n      var archCount = Math.floor(this.ringCount / 2);\n      for (var a = 0; a < archCount; a++) {\n        var startAngle = this.random() * Math.PI * 2;\n        var arcLength = Math.PI * (0.3 + this.random() * 0.5);\n        var _radius = this.innerRadius + this.random() * (this.outerRadius - this.innerRadius);\n\n        // Generate more points for the arch\n        var archPoints = [];\n\n        // Use higher resolution for smoother arcs\n        var arcResolution = 40;\n        for (var _i = 0; _i <= arcResolution; _i++) {\n          var _angle = startAngle + arcLength * _i / arcResolution;\n          var _x = Math.cos(_angle) * _radius;\n          var _y = Math.sin(_angle) * _radius;\n\n          // Add subtle variation to make arcs more organic\n          var variation = this.getNoise(_i / 10, a / 5) * 2 * (this.noiseStrength / 15);\n          archPoints.push({\n            x: _x + variation * Math.cos(_angle + Math.PI / 2),\n            y: _y + variation * Math.sin(_angle + Math.PI / 2)\n          });\n        }\n\n        // Create ultra smooth curve for arch\n        var archPath = this.generateCatmullRomPath(archPoints, this.curveTension);\n        elements.push(\"<path \\n                d=\\\"\".concat(archPath, \"\\\" \\n                stroke=\\\"white\\\" \\n                fill=\\\"none\\\"\\n                stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      }\n      return elements.join('');\n    }\n\n    // Generate simple smoothed path with optimized control points\n  }, {\n    key: \"generateSimpleSmoothedPath\",\n    value: function generateSimpleSmoothedPath(points) {\n      if (points.length < 3) return \"\";\n      var pathCommands = [\"M\".concat(points[0].x, \",\").concat(points[0].y)];\n\n      // Use quadratic curves for simplicity and smoothness\n      for (var i = 1; i < points.length; i++) {\n        var prev = points[i - 1];\n        var current = points[i];\n\n        // For simplified paths, use quadratic bezier curves\n        if (i < points.length - 1) {\n          var next = points[i + 1];\n          var controlX = (prev.x + current.x * 2 + next.x) / 4;\n          var controlY = (prev.y + current.y * 2 + next.y) / 4;\n          pathCommands.push(\"Q\".concat(current.x, \",\").concat(current.y, \" \").concat(controlX, \",\").concat(controlY));\n        } else {\n          pathCommands.push(\"L\".concat(current.x, \",\").concat(current.y));\n        }\n      }\n      return pathCommands.join(\" \");\n    }\n\n    // Generate optimized Catmull-Rom spline path\n  }, {\n    key: \"generateCatmullRomPath\",\n    value: function generateCatmullRomPath(points) {\n      var tension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n      if (points.length < 2) return \"\";\n\n      // Start the path\n      var pathData = \"M\".concat(points[0].x, \",\").concat(points[0].y);\n\n      // For higher quality, use a Catmull-Rom spline approximation with cubic beziers\n      // Add extra control points at the beginning and end for better curve calculation\n      var controlPoints = [points[0]].concat(_toConsumableArray(points), [points[points.length - 1] // Duplicate last point\n      ]);\n\n      // Process the points in groups of 4 to create smooth cubic bezier curves\n      for (var i = 0; i < controlPoints.length - 3; i++) {\n        var p0 = controlPoints[i];\n        var p1 = controlPoints[i + 1];\n        var p2 = controlPoints[i + 2];\n        var p3 = controlPoints[i + 3];\n\n        // Skip duplicated points at the beginning\n        if (i === 0 && p0.x === p1.x && p0.y === p1.y) continue;\n\n        // Calculate optimal control points for the cubic bezier curve\n        // The tension parameter controls how \"tight\" the curve is\n        var cp1x = p1.x + (p2.x - p0.x) * tension / 3;\n        var cp1y = p1.y + (p2.y - p0.y) * tension / 3;\n        var cp2x = p2.x - (p3.x - p1.x) * tension / 3;\n        var cp2y = p2.y - (p3.y - p1.y) * tension / 3;\n\n        // Skip the very first point since we already have a \"M\" command for it\n        if (i > 0 || p0.x !== p1.x || p0.y !== p1.y) {\n          pathData += \" C\".concat(cp1x.toFixed(2), \",\").concat(cp1y.toFixed(2), \" \").concat(cp2x.toFixed(2), \",\").concat(cp2y.toFixed(2), \" \").concat(p2.x.toFixed(2), \",\").concat(p2.y.toFixed(2));\n        }\n      }\n      return pathData;\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricFlow, \"parameters\", {\n  ringCount: {\n    min: 5,\n    max: 25,\n    \"default\": 15\n  },\n  pointsPerRing: {\n    min: 50,\n    max: 500,\n    \"default\": 200\n  },\n  innerRadius: {\n    min: 20,\n    max: 60,\n    \"default\": 50\n  },\n  outerRadius: {\n    min: 60,\n    max: 180,\n    \"default\": 95\n  },\n  noiseStrength: {\n    min: 0.1,\n    max: 15,\n    \"default\": 10\n  },\n  noiseScale: {\n    min: 0.5,\n    max: 5,\n    \"default\": 2.5\n  },\n  strokeWidth: {\n    min: 0.5,\n    max: 3,\n    \"default\": 2\n  },\n  curveTension: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.3\n  },\n  curveSegmentLength: {\n    min: 2,\n    max: 10,\n    \"default\": 3\n  },\n  seed: {\n    min: 0,\n    max: 1000,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricFlow);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricFlow.js?");

/***/ }),

/***/ "./src/shapes/ConcentricRectangles.js":
/*!********************************************!*\
  !*** ./src/shapes/ConcentricRectangles.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ConcentricRectangles = /*#__PURE__*/function (_Shape) {\n  function ConcentricRectangles() {\n    _classCallCheck(this, ConcentricRectangles);\n    return _callSuper(this, ConcentricRectangles, arguments);\n  }\n  _inherits(ConcentricRectangles, _Shape);\n  return _createClass(ConcentricRectangles, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var squares = [];\n      for (var i = 0; i < this.count; i++) {\n        var currentSize = this.size - i * this.spacing * 2;\n        if (currentSize <= 0) break;\n        var halfSize = currentSize / 2;\n\n        // Create path string for the square\n        var pathData = \"M \".concat(-halfSize, \" \").concat(-halfSize, \" \") + \"L \".concat(halfSize, \" \").concat(-halfSize, \" \") + \"L \".concat(halfSize, \" \").concat(halfSize, \" \") + \"L \".concat(-halfSize, \" \").concat(halfSize, \" Z\");\n        squares.push(\"<path \\n                d=\\\"\".concat(pathData, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            />\"));\n      }\n      return squares.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricRectangles, \"parameters\", {\n  count: {\n    min: 2,\n    max: 10,\n    \"default\": 6\n  },\n  spacing: {\n    min: 5,\n    max: 40,\n    \"default\": 20\n  },\n  size: {\n    min: 100,\n    max: 200,\n    \"default\": 190\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricRectangles);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricRectangles.js?");

/***/ }),

/***/ "./src/shapes/ConcentricSphereShape.js":
/*!*********************************************!*\
  !*** ./src/shapes/ConcentricSphereShape.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ConcentricSphereShape = /*#__PURE__*/function (_Shape) {\n  function ConcentricSphereShape() {\n    _classCallCheck(this, ConcentricSphereShape);\n    return _callSuper(this, ConcentricSphereShape, arguments);\n  }\n  _inherits(ConcentricSphereShape, _Shape);\n  return _createClass(ConcentricSphereShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var radius = this.radius,\n        layers = this.layers,\n        spacing = this.spacing,\n        rotationX = this.rotationX,\n        strokeWidth = this.strokeWidth;\n\n      // Convert rotation to radians\n      var rotationRadX = rotationX * Math.PI / 180;\n\n      // Calculate the distance between each layer\n      var layerDistance = 2 * radius / (layers + 1);\n\n      // Generate horizontal slices of the sphere\n      for (var i = 0; i < layers; i++) {\n        // Position along the y-axis, from -radius+layerDistance to radius-layerDistance\n        var y = -radius + layerDistance * (i + 1);\n\n        // Calculate the radius of this horizontal slice using the circle equation\n        // r = R - y where R is the sphere radius and y is the height\n        var sliceRadius = Math.sqrt(radius * radius - y * y);\n\n        // Apply the perspective by compressing the height\n        var projectedY = y * Math.cos(rotationRadX);\n\n        // Draw the circle for this layer\n        elements.push(\"<ellipse \\n          cx=\\\"0\\\" \\n          cy=\\\"\".concat(projectedY, \"\\\" \\n          rx=\\\"\").concat(sliceRadius, \"\\\" \\n          ry=\\\"\").concat(sliceRadius * Math.sin(rotationRadX), \"\\\" \\n          stroke=\\\"white\\\" \\n          stroke-width=\\\"\").concat(strokeWidth, \"\\\" \\n          fill=\\\"none\\\" \\n        />\"));\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricSphereShape, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  layers: {\n    min: 3,\n    max: 30,\n    \"default\": 12\n  },\n  spacing: {\n    min: 0.1,\n    max: 2,\n    \"default\": 1\n  },\n  rotationX: {\n    min: 1,\n    max: 90,\n    \"default\": 30\n  },\n  strokeWidth: {\n    min: 0.5,\n    max: 5,\n    \"default\": 1.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricSphereShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricSphereShape.js?");

/***/ }),

/***/ "./src/shapes/ConcentricTarget.js":
/*!****************************************!*\
  !*** ./src/shapes/ConcentricTarget.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ConcentricTarget = /*#__PURE__*/function (_Shape) {\n  function ConcentricTarget() {\n    _classCallCheck(this, ConcentricTarget);\n    return _callSuper(this, ConcentricTarget, arguments);\n  }\n  _inherits(ConcentricTarget, _Shape);\n  return _createClass(ConcentricTarget, [{\n    key: \"validateParameters\",\n    value: function validateParameters() {\n      // Ensure we have valid parameters\n      this.ringCount = Math.min(8, Math.max(2, this.ringCount));\n      this.outerThickness = Math.min(40, Math.max(5, this.outerThickness));\n      this.innerThickness = Math.min(30, Math.max(3, this.innerThickness));\n\n      // Check if we have enough space for all rings\n      var totalSpace = this.maxRadius;\n      var thicknessSum = this.calculateTotalThickness();\n      var spacingNeeded = (this.ringCount - 1) * this.spacing;\n      if (thicknessSum + spacingNeeded > totalSpace) {\n        // Reduce ring count if needed\n        this.ringCount = Math.max(2, Math.floor((totalSpace - this.outerThickness) / ((this.outerThickness + this.innerThickness) / 2 + this.spacing)));\n      }\n    }\n  }, {\n    key: \"calculateTotalThickness\",\n    value: function calculateTotalThickness() {\n      var total = 0;\n      var thicknesses = this.calculateRingThicknesses();\n      thicknesses.forEach(function (t) {\n        return total += t;\n      });\n      return total;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var rings = this.calculateRings();\n\n      // Generate each ring\n      for (var i = 0; i < rings.length; i++) {\n        elements.push(\"<circle \\n                cx=\\\"0\\\" \\n                cy=\\\"0\\\" \\n                r=\\\"\".concat(rings[i].radius, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(rings[i].thickness, \"\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n      }\n\n      // Add center dot if requested\n      if (this.centerDotSize > 0) {\n        elements.push(\"<circle \\n                cx=\\\"0\\\" \\n                cy=\\\"0\\\" \\n                r=\\\"\".concat(this.centerDotSize, \"\\\"\\n                fill=\\\"white\\\"\\n                stroke=\\\"none\\\"\\n            />\"));\n      }\n      return elements.join('');\n    }\n  }, {\n    key: \"calculateRings\",\n    value: function calculateRings() {\n      var rings = [];\n      var thicknesses = this.calculateRingThicknesses();\n      var currentRadius = this.maxRadius;\n      for (var i = 0; i < this.ringCount; i++) {\n        var thickness = thicknesses[i];\n        rings.push({\n          radius: currentRadius,\n          thickness: thickness\n        });\n\n        // Calculate the inner edge of current ring\n        var innerEdge = currentRadius - thickness;\n\n        // Next ring's radius is after the spacing\n        currentRadius = innerEdge - this.spacing;\n\n        // Stop if we're getting too small\n        if (currentRadius < this.centerDotSize * 2) {\n          break;\n        }\n      }\n      return rings;\n    }\n  }, {\n    key: \"calculateRingThicknesses\",\n    value: function calculateRingThicknesses() {\n      var thicknesses = [];\n      switch (this.thicknessPattern) {\n        case 'ascending':\n          // Thinner outer rings, thicker inner rings\n          for (var i = 0; i < this.ringCount; i++) {\n            var ratio = i / (this.ringCount - 1);\n            var thickness = this.innerThickness + ratio * (this.outerThickness - this.innerThickness);\n            thicknesses.push(thickness);\n          }\n          break;\n        case 'alternating':\n          // Alternate between thick and thin\n          for (var _i = 0; _i < this.ringCount; _i++) {\n            thicknesses.push(_i % 2 === 0 ? this.outerThickness : this.innerThickness);\n          }\n          break;\n        case 'random':\n          // Random thickness between inner and outer values\n          for (var _i2 = 0; _i2 < this.ringCount; _i2++) {\n            var randomFactor = Math.random();\n            var _thickness = this.innerThickness + randomFactor * (this.outerThickness - this.innerThickness);\n            thicknesses.push(_thickness);\n          }\n          break;\n        case 'descending':\n        default:\n          // Thicker outer rings, thinner inner rings (default)\n          for (var _i3 = 0; _i3 < this.ringCount; _i3++) {\n            var _ratio = _i3 / (this.ringCount - 1);\n            var _thickness2 = this.outerThickness - _ratio * (this.outerThickness - this.innerThickness);\n            thicknesses.push(_thickness2);\n          }\n          break;\n      }\n      return thicknesses;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConcentricTarget, \"parameters\", {\n  maxRadius: {\n    min: 30,\n    max: 90,\n    \"default\": 80\n  },\n  ringCount: {\n    min: 2,\n    max: 8,\n    \"default\": 4\n  },\n  outerThickness: {\n    min: 5,\n    max: 40,\n    \"default\": 20\n  },\n  innerThickness: {\n    min: 3,\n    max: 30,\n    \"default\": 10\n  },\n  spacing: {\n    min: 3,\n    max: 40,\n    \"default\": 15\n  },\n  centerDotSize: {\n    min: 0,\n    max: 25,\n    \"default\": 8\n  },\n  thicknessPattern: {\n    options: ['descending', 'ascending', 'alternating', 'random'],\n    \"default\": 'descending'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConcentricTarget);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConcentricTarget.js?");

/***/ }),

/***/ "./src/shapes/ConnectedPillsShape.js":
/*!*******************************************!*\
  !*** ./src/shapes/ConnectedPillsShape.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ConnectedPillsShape = /*#__PURE__*/function (_Shape) {\n  function ConnectedPillsShape() {\n    _classCallCheck(this, ConnectedPillsShape);\n    return _callSuper(this, ConnectedPillsShape, arguments);\n  }\n  _inherits(ConnectedPillsShape, _Shape);\n  return _createClass(ConnectedPillsShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Apply scale factor to match viewBox\n      var scale = 0.8; // Adjust scale to fit -200,200 coordinate space\n      var pillHeight = this.pillHeight * scale;\n      var pillWidth = this.pillWidth * scale;\n      var spacing = this.spacing * scale;\n      var cornerRadius = this.cornerRadius * scale;\n      var circleSize = this.centerCircleSize * scale;\n\n      // Calculate positions\n      var centerX = 0;\n      var centerY = 0;\n\n      // Create the paths\n      var paths = [];\n\n      // Left pill rounded rectangle\n      var leftX = centerX - spacing / 2 - pillWidth;\n      var leftY = centerY - pillHeight / 2;\n      paths.push(this.createRoundedRect(leftX, leftY, pillWidth, pillHeight, cornerRadius));\n\n      // Right pill rounded rectangle\n      var rightX = centerX + spacing / 2;\n      var rightY = centerY - pillHeight / 2;\n      paths.push(this.createRoundedRect(rightX, rightY, pillWidth, pillHeight, cornerRadius));\n\n      // Center circle\n      var circleX = centerX;\n      var circleY = centerY;\n      var circle = \"\\n            <circle \\n                cx=\\\"\".concat(circleX, \"\\\"\\n                cy=\\\"\").concat(circleY, \"\\\"\\n                r=\\\"\").concat(circleSize / 2, \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n      paths.push(circle);\n      return paths.join('\\n');\n    }\n  }, {\n    key: \"createRoundedRect\",\n    value: function createRoundedRect(x, y, width, height, radius) {\n      // Create SVG path for rounded rectangle\n      var commands = [// Start at top left after the corner radius\n      \"M \".concat(x + radius, \" \").concat(y), // Top line to right corner\n      \"H \".concat(x + width - radius), // Top right corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x + width, \" \").concat(y + radius), // Right line\n      \"V \".concat(y + height - radius), // Bottom right corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x + width - radius, \" \").concat(y + height), // Bottom line\n      \"H \".concat(x + radius), // Bottom left corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x, \" \").concat(y + height - radius), // Left line\n      \"V \".concat(y + radius), // Top left corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x + radius, \" \").concat(y),\n      // Close path\n      'Z'];\n      return \"\\n            <path \\n                d=\\\"\".concat(commands.join(' '), \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ConnectedPillsShape, \"parameters\", {\n  pillHeight: {\n    min: 100,\n    max: 300,\n    \"default\": 240\n  },\n  pillWidth: {\n    min: 40,\n    max: 120,\n    \"default\": 85\n  },\n  spacing: {\n    min: 0,\n    max: 100,\n    \"default\": 15\n  },\n  cornerRadius: {\n    min: 20,\n    max: 60,\n    \"default\": 42\n  },\n  centerCircleSize: {\n    min: 20,\n    max: 100,\n    \"default\": 85\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConnectedPillsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ConnectedPillsShape.js?");

/***/ }),

/***/ "./src/shapes/CrescentShape.js":
/*!*************************************!*\
  !*** ./src/shapes/CrescentShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CrescentShape = /*#__PURE__*/function (_Shape) {\n  function CrescentShape() {\n    _classCallCheck(this, CrescentShape);\n    return _callSuper(this, CrescentShape, arguments);\n  }\n  _inherits(CrescentShape, _Shape);\n  return _createClass(CrescentShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate the offset position for the second circle\n      var angle = this.rotation * Math.PI / 180;\n      var offsetX = this.offset / 100 * this.radius * Math.cos(angle);\n      var offsetY = this.offset / 100 * this.radius * Math.sin(angle);\n\n      // Calculate the radius of the inner circle based on thickness\n      var innerRadius = this.radius - this.thickness;\n\n      // Create unique IDs for the mask elements\n      var maskId = \"crescent-mask-\".concat(Math.random().toString(36).substr(2, 9));\n      return \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <circle \\n                        cx=\\\"0\\\" \\n                        cy=\\\"0\\\" \\n                        r=\\\"\").concat(this.radius, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\\n                    <circle \\n                        cx=\\\"\").concat(offsetX, \"\\\" \\n                        cy=\\\"\").concat(offsetY, \"\\\" \\n                        r=\\\"\").concat(innerRadius, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                </mask>\\n            </defs>\\n            <rect \\n                x=\\\"-200\\\" \\n                y=\\\"-200\\\" \\n                width=\\\"400\\\" \\n                height=\\\"400\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CrescentShape, \"parameters\", {\n  radius: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  thickness: {\n    min: 1,\n    max: 100,\n    \"default\": 18\n  },\n  rotation: {\n    min: -360,\n    max: 360,\n    \"default\": 0\n  },\n  offset: {\n    min: 0,\n    max: 100,\n    \"default\": 57\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CrescentShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CrescentShape.js?");

/***/ }),

/***/ "./src/shapes/CrossShape.js":
/*!**********************************!*\
  !*** ./src/shapes/CrossShape.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CrossShape = /*#__PURE__*/function (_Shape) {\n  function CrossShape() {\n    _classCallCheck(this, CrossShape);\n    return _callSuper(this, CrossShape, arguments);\n  }\n  _inherits(CrossShape, _Shape);\n  return _createClass(CrossShape, [{\n    key: \"generateArmPoints\",\n    value: function generateArmPoints(angle) {\n      var al = this.armLength;\n      var aw = this.armWidth / 2;\n      var er = Math.min(this.endRadius, aw);\n\n      // Generate base points for a vertical arm\n      var points = [\n      // Center connection point\n      [aw, aw],\n      // Arm points with radius consideration\n      [aw, al - er],\n      // Top right before radius\n      [aw - er, al],\n      // Top right after radius\n      [-aw + er, al],\n      // Top left after radius\n      [-aw, al - er],\n      // Top left before radius\n      [-aw, aw] // Back to center\n      ];\n\n      // Apply rotation transformation\n      return points.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        var rad = angle * Math.PI / 180;\n        return [x * Math.cos(rad) - y * Math.sin(rad), x * Math.sin(rad) + y * Math.cos(rad)];\n      });\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var path = [];\n      var armAngles = [0, 90, 180, 270];\n      var er = Math.min(this.endRadius, this.armWidth / 2);\n\n      // Generate each arm of the cross\n      for (var i = 0; i < armAngles.length; i++) {\n        var points = this.generateArmPoints(armAngles[i]);\n\n        // Start path or continue from last position\n        if (i === 0) {\n          path.push(\"M \".concat(points[0][0], \",\").concat(points[0][1]));\n        }\n\n        // Draw arm with optional end radius\n        path.push(\"L \".concat(points[1][0], \",\").concat(points[1][1]));\n        if (er > 0) {\n          // Add rounded corners at the end\n          path.push(\"A \".concat(er, \" \").concat(er, \" 0 0 1 \").concat(points[2][0], \",\").concat(points[2][1]), \"L \".concat(points[3][0], \",\").concat(points[3][1]), \"A \".concat(er, \" \").concat(er, \" 0 0 1 \").concat(points[4][0], \",\").concat(points[4][1]));\n        } else {\n          // Sharp corners\n          path.push(\"L \".concat(points[2][0], \",\").concat(points[2][1]), \"L \".concat(points[3][0], \",\").concat(points[3][1]), \"L \".concat(points[4][0], \",\").concat(points[4][1]));\n        }\n\n        // Connect back to center\n        path.push(\"L \".concat(points[5][0], \",\").concat(points[5][1]));\n      }\n      path.push('Z'); // Close the path\n      return \"<path d=\\\"\".concat(path.join(' '), \"\\\" fill=\\\"white\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CrossShape, \"parameters\", {\n  armLength: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  },\n  armWidth: {\n    min: 10,\n    max: 100,\n    \"default\": 30\n  },\n  endRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CrossShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CrossShape.js?");

/***/ }),

/***/ "./src/shapes/CrossSqrdShape.js":
/*!**************************************!*\
  !*** ./src/shapes/CrossSqrdShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CrossSqrdShape = /*#__PURE__*/function (_Shape) {\n  function CrossSqrdShape() {\n    _classCallCheck(this, CrossSqrdShape);\n    return _callSuper(this, CrossSqrdShape, arguments);\n  }\n  _inherits(CrossSqrdShape, _Shape);\n  return _createClass(CrossSqrdShape, [{\n    key: \"createRoundedRect\",\n    value: function createRoundedRect(x, y, width, height, radius) {\n      var commands = [// Start at top left after the corner radius\n      \"M \".concat(x + radius, \" \").concat(y), // Top line to right corner\n      \"H \".concat(x + width - radius), // Top right corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x + width, \" \").concat(y + radius), // Right line\n      \"V \".concat(y + height - radius), // Bottom right corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x + width - radius, \" \").concat(y + height), // Bottom line\n      \"H \".concat(x + radius), // Bottom left corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x, \" \").concat(y + height - radius), // Left line\n      \"V \".concat(y + radius), // Top left corner\n      \"A \".concat(radius, \" \").concat(radius, \" 0 0 1 \").concat(x + radius, \" \").concat(y), 'Z'];\n      return commands.join(' ');\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Apply scale factor to match viewBox\n      var scale = 0.8; // Adjust scale to fit -200,200 coordinate space\n      var size = this.size * scale;\n      var spacing = this.spacing * scale;\n      var cornerRadius = this.cornerRadius * scale;\n\n      // Center coordinates\n      var centerX = 0;\n      var centerY = 0;\n\n      // Define the positions for the four squares\n      var positions = [[0, -1],\n      // top\n      [1, 0],\n      // right\n      [0, 1],\n      // bottom\n      [-1, 0] // left\n      ];\n\n      // Create all squares\n      var squares = positions.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        var squareX = centerX + x * spacing - size / 2;\n        var squareY = centerY + y * spacing - size / 2;\n        return _this.createRoundedRect(squareX, squareY, size, size, cornerRadius);\n      });\n      return squares.map(function (square) {\n        return \"\\n            <path \\n                d=\\\"\".concat(square, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"2\\\"\\n            />\\n        \");\n      }).join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CrossSqrdShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  spacing: {\n    min: 0,\n    max: 100,\n    \"default\": 30\n  },\n  cornerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 20\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CrossSqrdShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CrossSqrdShape.js?");

/***/ }),

/***/ "./src/shapes/CrosshairShape.js":
/*!**************************************!*\
  !*** ./src/shapes/CrosshairShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CrosshairShape = /*#__PURE__*/function (_Shape) {\n  function CrosshairShape() {\n    _classCallCheck(this, CrosshairShape);\n    return _callSuper(this, CrosshairShape, arguments);\n  }\n  _inherits(CrosshairShape, _Shape);\n  return _createClass(CrosshairShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var radius = this.radius;\n      var lineThickness = this.lineThickness * this.innerLineWeight;\n      var lineLength = radius * 2 * this.lineRatio;\n      var roundedCenter = this.roundedCenter;\n      var style = this.style;\n      var borderWidth = this.borderWidth;\n\n      // Generate a unique ID for the mask\n      var maskId = \"crosshair-mask-\".concat(Math.floor(Math.random() * 10000));\n\n      // Create mask elements based on the selected style\n      var maskElements = '';\n      if (style === 'plus' || style === 'cross') {\n        // Calculate arm dimensions\n        var halfThickness = lineThickness / 2;\n\n        // Create horizontal line\n        maskElements += \"\\n                <rect \\n                    x=\\\"\".concat(-lineLength / 2, \"\\\" \\n                    y=\\\"\").concat(-halfThickness, \"\\\" \\n                    width=\\\"\").concat(lineLength, \"\\\" \\n                    height=\\\"\").concat(lineThickness, \"\\\"\\n                    fill=\\\"black\\\"\\n                />\");\n\n        // Create vertical line\n        maskElements += \"\\n                <rect \\n                    x=\\\"\".concat(-halfThickness, \"\\\" \\n                    y=\\\"\").concat(-lineLength / 2, \"\\\" \\n                    width=\\\"\").concat(lineThickness, \"\\\" \\n                    height=\\\"\").concat(lineLength, \"\\\"\\n                    fill=\\\"black\\\"\\n                />\");\n\n        // For cross style, add 45-degree rotated lines\n        if (style === 'cross') {\n          var diagonalLength = lineLength * 0.7;\n          var diagonalThickness = lineThickness * 0.8;\n          var halfDiagThickness = diagonalThickness / 2;\n          maskElements += \"\\n                    <rect \\n                        x=\\\"\".concat(-diagonalLength / 2, \"\\\" \\n                        y=\\\"\").concat(-halfDiagThickness, \"\\\" \\n                        width=\\\"\").concat(diagonalLength, \"\\\" \\n                        height=\\\"\").concat(diagonalThickness, \"\\\"\\n                        transform=\\\"rotate(45)\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                    <rect \\n                        x=\\\"\").concat(-diagonalLength / 2, \"\\\" \\n                        y=\\\"\").concat(-halfDiagThickness, \"\\\" \\n                        width=\\\"\").concat(diagonalLength, \"\\\" \\n                        height=\\\"\").concat(diagonalThickness, \"\\\"\\n                        transform=\\\"rotate(-45)\\\"\\n                        fill=\\\"black\\\"\\n                    />\");\n        }\n      } else if (style === 'target') {\n        // Create concentric circles\n        var ringCount = 3;\n        var ringSpacing = radius / (ringCount + 1);\n        for (var i = 1; i <= ringCount; i++) {\n          var ringRadius = i * ringSpacing;\n          var ringThickness = lineThickness * (1 - (i - 1) * 0.15);\n          maskElements += \"\\n                    <circle \\n                        cx=\\\"0\\\" \\n                        cy=\\\"0\\\" \\n                        r=\\\"\".concat(ringRadius, \"\\\"\\n                        stroke=\\\"black\\\"\\n                        stroke-width=\\\"\").concat(ringThickness, \"\\\"\\n                        fill=\\\"none\\\"\\n                    />\");\n        }\n\n        // Add crosshair lines\n        var _halfThickness = lineThickness / 2;\n        maskElements += \"\\n                <rect \\n                    x=\\\"\".concat(-radius, \"\\\" \\n                    y=\\\"\").concat(-_halfThickness, \"\\\" \\n                    width=\\\"\").concat(radius * 2, \"\\\" \\n                    height=\\\"\").concat(lineThickness, \"\\\"\\n                    fill=\\\"black\\\"\\n                />\\n                <rect \\n                    x=\\\"\").concat(-_halfThickness, \"\\\" \\n                    y=\\\"\").concat(-radius, \"\\\" \\n                    width=\\\"\").concat(lineThickness, \"\\\" \\n                    height=\\\"\").concat(radius * 2, \"\\\"\\n                    fill=\\\"black\\\"\\n                />\");\n      } else if (style === 'radar') {\n        // Create radar sweep lines\n        var lineCount = 6;\n        var angleStep = 360 / lineCount;\n        for (var _i = 0; _i < lineCount; _i++) {\n          var angle = _i * angleStep;\n          maskElements += \"\\n                    <line \\n                        x1=\\\"0\\\" \\n                        y1=\\\"0\\\" \\n                        x2=\\\"\".concat(radius * Math.cos(angle * Math.PI / 180), \"\\\" \\n                        y2=\\\"\").concat(radius * Math.sin(angle * Math.PI / 180), \"\\\"\\n                        stroke=\\\"black\\\"\\n                        stroke-width=\\\"\").concat(lineThickness, \"\\\"\\n                    />\");\n        }\n\n        // Add concentric circles\n        var _ringCount = 2;\n        var _ringSpacing = radius / (_ringCount + 1);\n        for (var _i2 = 1; _i2 <= _ringCount; _i2++) {\n          var _ringRadius = _i2 * _ringSpacing;\n          maskElements += \"\\n                    <circle \\n                        cx=\\\"0\\\" \\n                        cy=\\\"0\\\" \\n                        r=\\\"\".concat(_ringRadius, \"\\\"\\n                        stroke=\\\"black\\\"\\n                        stroke-width=\\\"\").concat(lineThickness, \"\\\"\\n                        fill=\\\"none\\\"\\n                    />\");\n        }\n      }\n\n      // Add rounded center if requested\n      if (roundedCenter > 0) {\n        maskElements += \"\\n                <circle \\n                    cx=\\\"0\\\" \\n                    cy=\\\"0\\\" \\n                    r=\\\"\".concat(roundedCenter, \"\\\"\\n                    fill=\\\"black\\\"\\n                />\");\n      }\n\n      // Define the mask\n      var maskDef = \"\\n        <defs>\\n            <mask id=\\\"\".concat(maskId, \"\\\">\\n                <rect x=\\\"-200\\\" y=\\\"-200\\\" width=\\\"400\\\" height=\\\"400\\\" fill=\\\"white\\\" />\\n                \").concat(maskElements, \"\\n            </mask>\\n        </defs>\");\n\n      // Create the main circle with the mask applied\n      var maskedCircle = \"\\n            <circle \\n                cx=\\\"0\\\" \\n                cy=\\\"0\\\" \\n                r=\\\"\".concat(radius, \"\\\"\\n                fill=\\\"white\\\"\\n                stroke=\\\"\").concat(borderWidth > 0 ? 'black' : 'none', \"\\\"\\n                stroke-width=\\\"\").concat(borderWidth, \"\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\");\n      return \"\".concat(maskDef).concat(maskedCircle);\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CrosshairShape, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 90\n  },\n  lineThickness: {\n    min: 1,\n    max: 30,\n    \"default\": 10\n  },\n  lineRatio: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.5\n  },\n  roundedCenter: {\n    min: 0,\n    max: 30,\n    \"default\": 10\n  },\n  style: {\n    options: ['plus', 'cross', 'target', 'radar'],\n    \"default\": 'plus'\n  },\n  innerLineWeight: {\n    min: 0.1,\n    max: 2.0,\n    \"default\": 1.0\n  },\n  borderWidth: {\n    min: 0,\n    max: 15,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CrosshairShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CrosshairShape.js?");

/***/ }),

/***/ "./src/shapes/CrystalShard.js":
/*!************************************!*\
  !*** ./src/shapes/CrystalShard.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CrystalShard = /*#__PURE__*/function (_Shape) {\n  function CrystalShard() {\n    _classCallCheck(this, CrystalShard);\n    return _callSuper(this, CrystalShard, arguments);\n  }\n  _inherits(CrystalShard, _Shape);\n  return _createClass(CrystalShard, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.blades = Math.round(this.blades);\n      var baseRadius = 100;\n      var angleStep = 2 * Math.PI / this.blades;\n      var points = [];\n\n      // Generate main blade points\n      for (var blade = 0; blade < this.blades; blade++) {\n        var baseAngle = angleStep * blade;\n\n        // Blade generation with serrations\n        for (var s = 0; s <= this.serration; s++) {\n          var t = s / this.serration;\n          var radius = baseRadius * (1 - t * this.taper);\n          var angleOffset = this.skew * (t - 0.5);\n          var angle = baseAngle + angleOffset + Math.PI / 2;\n          var x = radius * Math.cos(angle);\n          var y = radius * Math.sin(angle);\n          points.push([x, y]);\n\n          // Add reverse point for serration\n          if (s < this.serration) {\n            var reverseRadius = radius * 0.85;\n            var reverseAngle = angle + angleStep / (this.serration * 2);\n            points.push([reverseRadius * Math.cos(reverseAngle), reverseRadius * Math.sin(reverseAngle)]);\n          }\n        }\n      }\n\n      // Create SVG path\n      var pathData = \"M \".concat(points[0][0], \" \").concat(points[0][1]);\n      for (var i = 1; i < points.length; i++) {\n        pathData += \" L \".concat(points[i][0], \" \").concat(points[i][1]);\n\n        // Create triangular notch\n        if (i % (this.serration * 2) === 0) {\n          var nextIndex = (i + 1) % points.length;\n          var notchX = (points[i][0] + points[nextIndex][0]) / 2;\n          var notchY = (points[i][1] + points[nextIndex][1]) / 2;\n          pathData += \" L \".concat(notchX, \" \").concat(notchY);\n        }\n      }\n      pathData += ' Z';\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CrystalShard, \"parameters\", {\n  blades: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  serration: {\n    min: 1,\n    max: 8,\n    \"default\": 1\n  },\n  taper: {\n    min: 0.2,\n    max: 1,\n    \"default\": 0.3\n  },\n  skew: {\n    min: -1,\n    max: 1,\n    \"default\": 0.2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CrystalShard);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CrystalShard.js?");

/***/ }),

/***/ "./src/shapes/CubeShape.js":
/*!*********************************!*\
  !*** ./src/shapes/CubeShape.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CubeShape = /*#__PURE__*/function (_Shape) {\n  function CubeShape() {\n    _classCallCheck(this, CubeShape);\n    return _callSuper(this, CubeShape, arguments);\n  }\n  _inherits(CubeShape, _Shape);\n  return _createClass(CubeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var size = this.size;\n      var halfSize = size / 2;\n\n      // Convert rotation angles to radians\n      var rotX = this.rotationX * Math.PI / 180;\n      var rotY = this.rotationY * Math.PI / 180;\n      var rotZ = this.rotationZ * Math.PI / 180;\n\n      // Define the vertices of a cube centered at origin\n      var vertices = [[-halfSize, -halfSize, -halfSize],\n      // 0: back bottom left\n      [halfSize, -halfSize, -halfSize],\n      // 1: back bottom right\n      [halfSize, halfSize, -halfSize],\n      // 2: back top right\n      [-halfSize, halfSize, -halfSize],\n      // 3: back top left\n      [-halfSize, -halfSize, halfSize],\n      // 4: front bottom left\n      [halfSize, -halfSize, halfSize],\n      // 5: front bottom right\n      [halfSize, halfSize, halfSize],\n      // 6: front top right\n      [-halfSize, halfSize, halfSize] // 7: front top left\n      ];\n\n      // Apply 3D rotations and projection to 2D\n      var projectedVertices = vertices.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n          x = _ref2[0],\n          y = _ref2[1],\n          z = _ref2[2];\n        // Apply rotation around X axis (pitch)\n        var x1 = x;\n        var y1 = y * Math.cos(rotX) - z * Math.sin(rotX);\n        var z1 = y * Math.sin(rotX) + z * Math.cos(rotX);\n\n        // Apply rotation around Y axis (yaw)\n        var x2 = x1 * Math.cos(rotY) + z1 * Math.sin(rotY);\n        var y2 = y1;\n        var z2 = -x1 * Math.sin(rotY) + z1 * Math.cos(rotY);\n\n        // Apply rotation around Z axis (roll)\n        var x3 = x2 * Math.cos(rotZ) - y2 * Math.sin(rotZ);\n        var y3 = x2 * Math.sin(rotZ) + y2 * Math.cos(rotZ);\n        var z3 = z2;\n\n        // Round to 3 decimal places to avoid floating point precision issues\n        return {\n          x: Math.round(x3 * 1000) / 1000,\n          y: Math.round(y3 * 1000) / 1000,\n          z: Math.round(z3 * 1000) / 1000\n        };\n      });\n\n      // Define edges of the cube (pairs of vertex indices)\n      var edges = [[0, 1], [1, 2], [2, 3], [3, 0],\n      // back face\n      [4, 5], [5, 6], [6, 7], [7, 4],\n      // front face\n      [0, 4], [1, 5], [2, 6], [3, 7] // connecting edges\n      ];\n\n      // Sort edges by average z-depth for proper rendering order\n      var sortedEdges = [].concat(edges).sort(function (a, b) {\n        var avgZA = (projectedVertices[a[0]].z + projectedVertices[a[1]].z) / 2;\n        var avgZB = (projectedVertices[b[0]].z + projectedVertices[b[1]].z) / 2;\n        return avgZB - avgZA; // Draw back-to-front\n      });\n\n      // Create a group for the entire shape\n      elements.push(\"<g stroke=\\\"white\\\" stroke-width=\\\"\".concat(this.thickness, \"\\\" fill=\\\"none\\\" stroke-linejoin=\\\"round\\\" stroke-linecap=\\\"round\\\">\"));\n\n      // Draw all edges as a single path per visible side to ensure perfect connections\n      // Create paths for connected edges\n      var visibleLines = {};\n\n      // Group edges that should be drawn as a single path\n      var connectedPaths = [];\n\n      // Process edges to form continuous paths\n      var remainingEdges = _toConsumableArray(sortedEdges);\n      while (remainingEdges.length > 0) {\n        var currentPath = [remainingEdges[0]];\n        remainingEdges.splice(0, 1);\n        var foundConnection = true;\n        while (foundConnection) {\n          foundConnection = false;\n\n          // Look for an edge that connects to the last vertex in our current path\n          var lastEdge = currentPath[currentPath.length - 1];\n          var lastVertex = lastEdge[1];\n          for (var i = 0; i < remainingEdges.length; i++) {\n            // If this edge starts with our last vertex\n            if (remainingEdges[i][0] === lastVertex) {\n              currentPath.push(remainingEdges[i]);\n              remainingEdges.splice(i, 1);\n              foundConnection = true;\n              break;\n            }\n            // If this edge ends with our last vertex (need to reverse it)\n            else if (remainingEdges[i][1] === lastVertex) {\n              currentPath.push([remainingEdges[i][1], remainingEdges[i][0]]);\n              remainingEdges.splice(i, 1);\n              foundConnection = true;\n              break;\n            }\n          }\n        }\n        connectedPaths.push(currentPath);\n      }\n\n      // Draw each connected path\n      for (var _i = 0, _connectedPaths = connectedPaths; _i < _connectedPaths.length; _i++) {\n        var path = _connectedPaths[_i];\n        var pathData = path.map(function (edge, i) {\n          var start = projectedVertices[edge[0]];\n          var end = projectedVertices[edge[1]];\n          return \"\".concat(i === 0 ? 'M' : 'L').concat(start.x, \",\").concat(start.y, \" L\").concat(end.x, \",\").concat(end.y);\n        }).join(' ');\n        elements.push(\"<path d=\\\"\".concat(pathData, \"\\\" />\"));\n      }\n\n      // Close the group\n      elements.push(\"</g>\");\n      return elements.join('');\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CubeShape, \"parameters\", {\n  size: {\n    min: 20,\n    max: 300,\n    \"default\": 100\n  },\n  rotationX: {\n    min: -60,\n    max: 60,\n    \"default\": 45\n  },\n  rotationY: {\n    min: -60,\n    max: 60,\n    \"default\": 45\n  },\n  rotationZ: {\n    min: -60,\n    max: 60,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CubeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CubeShape.js?");

/***/ }),

/***/ "./src/shapes/CurvedHourglass.js":
/*!***************************************!*\
  !*** ./src/shapes/CurvedHourglass.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CurvedHourglass = /*#__PURE__*/function (_Shape) {\n  function CurvedHourglass() {\n    _classCallCheck(this, CurvedHourglass);\n    return _callSuper(this, CurvedHourglass, arguments);\n  }\n  _inherits(CurvedHourglass, _Shape);\n  return _createClass(CurvedHourglass, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 200;\n      var width = scale * 0.8; // Adjust to fit viewBox\n      var height = width * this.verticalStretch;\n\n      // Center coordinates\n      var centerX = 0;\n      var centerY = 0;\n\n      // Calculate dimensions\n      var top = centerY - height / 2;\n      var bottom = centerY + height / 2;\n      var waistY = centerY;\n\n      // Calculate widths\n      var waistX = width * this.waistWidth;\n      var topX = width * this.topWidth;\n\n      // Calculate curve control points\n      var curveOffset = height / 4 * this.curvature;\n\n      // Build path commands\n      var commands = [// Start at top left\n      \"M \".concat(centerX - topX / 2, \" \").concat(top), // Left side curve to waist\n      \"C \".concat(centerX - topX / 2, \" \").concat(top + curveOffset, \", \\n               \").concat(centerX - waistX / 2, \" \").concat(waistY - curveOffset, \", \\n               \").concat(centerX - waistX / 2, \" \").concat(waistY), // Left side curve to bottom\n      \"C \".concat(centerX - waistX / 2, \" \").concat(waistY + curveOffset, \",\\n               \").concat(centerX - topX / 2, \" \").concat(bottom - curveOffset, \",\\n               \").concat(centerX - topX / 2, \" \").concat(bottom), // Bottom line\n      \"L \".concat(centerX + topX / 2, \" \").concat(bottom), // Right side curve to waist\n      \"C \".concat(centerX + topX / 2, \" \").concat(bottom - curveOffset, \",\\n               \").concat(centerX + waistX / 2, \" \").concat(waistY + curveOffset, \",\\n               \").concat(centerX + waistX / 2, \" \").concat(waistY), // Right side curve to top\n      \"C \".concat(centerX + waistX / 2, \" \").concat(waistY - curveOffset, \",\\n               \").concat(centerX + topX / 2, \" \").concat(top + curveOffset, \",\\n               \").concat(centerX + topX / 2, \" \").concat(top),\n      // Close path\n      'Z'];\n      return \"<path\\n            d=\\\"\".concat(commands.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CurvedHourglass, \"parameters\", {\n  waistWidth: {\n    min: 0.1,\n    max: 0.8,\n    \"default\": 0.3\n  },\n  topWidth: {\n    min: 0.3,\n    max: 1.0,\n    \"default\": 0.8\n  },\n  curvature: {\n    min: 0.1,\n    max: 2.0,\n    \"default\": 0.8\n  },\n  verticalStretch: {\n    min: 0.5,\n    max: 1.2,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CurvedHourglass);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CurvedHourglass.js?");

/***/ }),

/***/ "./src/shapes/CurvedPetalFlower.js":
/*!*****************************************!*\
  !*** ./src/shapes/CurvedPetalFlower.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CurvedPetalFlower = /*#__PURE__*/function (_Shape) {\n  function CurvedPetalFlower() {\n    _classCallCheck(this, CurvedPetalFlower);\n    return _callSuper(this, CurvedPetalFlower, arguments);\n  }\n  _inherits(CurvedPetalFlower, _Shape);\n  return _createClass(CurvedPetalFlower, [{\n    key: \"generatePetalPath\",\n    value: function generatePetalPath(angle) {\n      this.petalCount = Math.round(this.petalCount);\n      var angleStep = 2 * Math.PI / this.petalCount;\n      var halfAngleStep = angleStep / 2;\n\n      // Base points\n      var baseX = Math.cos(angle) * this.innerRadius;\n      var baseY = Math.sin(angle) * this.innerRadius;\n      var tipX = Math.cos(angle) * this.outerRadius;\n      var tipY = Math.sin(angle) * this.outerRadius;\n\n      // Convert parameters to factors\n      var spreadFactor = this.petalSpread / 100;\n      var pointFactor = this.petalPointiness / 100;\n\n      // Control points calculations - ensure consistent scaling\n      var cp1Dist = this.innerRadius + (this.outerRadius - this.innerRadius) * (0.2 + pointFactor * 0.3);\n      var cp2Dist = this.innerRadius + (this.outerRadius - this.innerRadius) * (0.5 + pointFactor * 0.3);\n\n      // Adjust spread based on petalSpread parameter - ensure symmetry\n      var baseAngle = halfAngleStep * (0.3 + spreadFactor * 0.7);\n      // Use consistent angle calculation for tips\n      var tipAngle = halfAngleStep * (0.1 + spreadFactor * 0.5) * (1 - pointFactor * 0.5);\n\n      // Calculate control points with adjusted angles - ensure symmetry\n      var cp1LeftX = Math.cos(angle - baseAngle) * cp1Dist;\n      var cp1LeftY = Math.sin(angle - baseAngle) * cp1Dist;\n      var cp2LeftX = Math.cos(angle - tipAngle) * cp2Dist;\n      var cp2LeftY = Math.sin(angle - tipAngle) * cp2Dist;\n      var cp1RightX = Math.cos(angle + baseAngle) * cp1Dist;\n      var cp1RightY = Math.sin(angle + baseAngle) * cp1Dist;\n      var cp2RightX = Math.cos(angle + tipAngle) * cp2Dist;\n      var cp2RightY = Math.sin(angle + tipAngle) * cp2Dist;\n\n      // Create SVG path for a single petal using cubic Bzier curves\n      return \"M \".concat(baseX, \" \").concat(baseY, \" \\n                C \").concat(cp1LeftX, \" \").concat(cp1LeftY, \", \").concat(cp2LeftX, \" \").concat(cp2LeftY, \", \").concat(tipX, \" \").concat(tipY, \"\\n                C \").concat(cp2RightX, \" \").concat(cp2RightY, \", \").concat(cp1RightX, \" \").concat(cp1RightY, \", \").concat(baseX, \" \").concat(baseY);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.petalCount = Math.round(this.petalCount);\n      var angleStep = 2 * Math.PI / this.petalCount;\n      // Use consistent starting angle - align with image reference\n      var rotationOffset = Math.PI / 2; // Start from top (90 degrees)\n      var paths = [];\n\n      // Generate petals\n      for (var i = 0; i < this.petalCount; i++) {\n        var angle = i * angleStep + rotationOffset;\n        paths.push(this.generatePetalPath(angle));\n      }\n\n      // Add center circle if centerSize > 0\n      if (this.centerSize > 0) {\n        var actualCenterSize = this.innerRadius * this.centerSize / 100;\n        paths.push(\"\\n                <circle \\n                    cx=\\\"0\\\" \\n                    cy=\\\"0\\\" \\n                    r=\\\"\".concat(actualCenterSize, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\\n            \"));\n      }\n\n      // Combine all paths into a single SVG group\n      return \"\\n            <g>\\n                <path \\n                    d=\\\"\".concat(paths.filter(function (p) {\n        return !p.includes('circle');\n      }).join(' '), \"\\\"\\n                    fill=\\\"white\\\"\\n                />\\n                \").concat(paths.filter(function (p) {\n        return p.includes('circle');\n      }).join(''), \"\\n            </g>\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CurvedPetalFlower, \"parameters\", {\n  petalCount: {\n    min: 3,\n    max: 24,\n    \"default\": 12\n  },\n  outerRadius: {\n    min: 40,\n    max: 100,\n    \"default\": 90\n  },\n  innerRadius: {\n    min: 10,\n    max: 50,\n    \"default\": 35\n  },\n  centerSize: {\n    min: 0,\n    max: 100,\n    \"default\": 25\n  },\n  petalSpread: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  },\n  petalPointiness: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CurvedPetalFlower);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CurvedPetalFlower.js?");

/***/ }),

/***/ "./src/shapes/CurvedSplit.js":
/*!***********************************!*\
  !*** ./src/shapes/CurvedSplit.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CurvedSplit = /*#__PURE__*/function (_Shape) {\n  function CurvedSplit() {\n    _classCallCheck(this, CurvedSplit);\n    return _callSuper(this, CurvedSplit, arguments);\n  }\n  _inherits(CurvedSplit, _Shape);\n  return _createClass(CurvedSplit, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 200; // Scale for the viewBox\n      var points = [];\n      var steps = 100;\n\n      // Convert phase to radians\n      var phaseRadians = this.phase * Math.PI / 180;\n\n      // Calculate wave points\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps;\n\n        // Base wave\n        var angle = t * Math.PI * 2 * this.frequency + phaseRadians;\n        var wave = Math.sin(angle) * this.amplitude;\n\n        // Add chaos using additional high-frequency waves\n        var chaosWave = this.chaos * (Math.sin(t * Math.PI * 7.3) * 0.3 + Math.sin(t * Math.PI * 15.7) * 0.2 + Math.sin(t * Math.PI * 25.1) * 0.1) * this.amplitude;\n        var x = -scale / 2 + scale * t;\n        var y = wave + chaosWave;\n        points.push([x, y]);\n      }\n\n      // Create the SVG path\n      var pathData = \"M \".concat(-scale / 2, \" \").concat(scale / 2); // Start at bottom left\n\n      // Add all wave points\n      for (var _i = 0, _points = points; _i < _points.length; _i++) {\n        var _points$_i = _slicedToArray(_points[_i], 2),\n          _x = _points$_i[0],\n          _y = _points$_i[1];\n        pathData += \" L \".concat(_x, \" \").concat(_y);\n      }\n\n      // Complete the shape\n      pathData += \" L \".concat(scale / 2, \" \").concat(scale / 2); // To bottom right\n      pathData += ' Z'; // Close the path\n\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CurvedSplit, \"parameters\", {\n  frequency: {\n    min: 0.5,\n    max: 4.0,\n    \"default\": 1.0\n  },\n  amplitude: {\n    min: 0,\n    max: 100,\n    \"default\": 40\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  chaos: {\n    min: 0,\n    max: 1.0,\n    \"default\": 0.2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CurvedSplit);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CurvedSplit.js?");

/***/ }),

/***/ "./src/shapes/CutoutPill.js":
/*!**********************************!*\
  !*** ./src/shapes/CutoutPill.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CutoutPill = /*#__PURE__*/function (_Shape) {\n  function CutoutPill() {\n    _classCallCheck(this, CutoutPill);\n    return _callSuper(this, CutoutPill, arguments);\n  }\n  _inherits(CutoutPill, _Shape);\n  return _createClass(CutoutPill, [{\n    key: \"createRoundedRectPath\",\n    value: function createRoundedRectPath(x, y, width, height, radius) {\n      // Ensure radius isn't too large for the rectangle\n      var actualRadius = Math.min(radius, Math.min(width / 2, height / 2));\n\n      // Create rounded rectangle path\n      return \"M \".concat(x + actualRadius, \" \").concat(y, \"\\n                H \").concat(x + width - actualRadius, \"\\n                A \").concat(actualRadius, \" \").concat(actualRadius, \" 0 0 1 \").concat(x + width, \" \").concat(y + actualRadius, \"\\n                V \").concat(y + height - actualRadius, \"\\n                A \").concat(actualRadius, \" \").concat(actualRadius, \" 0 0 1 \").concat(x + width - actualRadius, \" \").concat(y + height, \"\\n                H \").concat(x + actualRadius, \"\\n                A \").concat(actualRadius, \" \").concat(actualRadius, \" 0 0 1 \").concat(x, \" \").concat(y + height - actualRadius, \"\\n                V \").concat(y + actualRadius, \"\\n                A \").concat(actualRadius, \" \").concat(actualRadius, \" 0 0 1 \").concat(x + actualRadius, \" \").concat(y, \"\\n                Z\");\n    }\n  }, {\n    key: \"createRectPath\",\n    value: function createRectPath(x, y, width, height) {\n      return \"M \".concat(x, \" \").concat(y, \"\\n                H \").concat(x + width, \"\\n                V \").concat(y + height, \"\\n                H \").concat(x, \"\\n                Z\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate dimensions\n      var cutoutWidth = Math.min(this.cutoutWidth, this.width * 0.9);\n      var cutoutHeight = Math.min(this.cutoutHeight, this.height * 0.9);\n      var cornerRadius = Math.min(this.cornerRadius, Math.min(this.width, this.height) / 2);\n\n      // Calculate positions (centered)\n      var x = -this.width / 2;\n      var y = -this.height / 2;\n      var cutoutX = -cutoutWidth / 2;\n      var cutoutY = -cutoutHeight / 2;\n\n      // Create the main pill and cutout paths\n      var mainPath = this.createRoundedRectPath(x, y, this.width, this.height, cornerRadius);\n      var cutoutPath = this.createRectPath(cutoutX, cutoutY, cutoutWidth, cutoutHeight);\n\n      // Combine paths using SVG's fill-rule to create cutout effect\n      return \"<path \\n            d=\\\"\".concat(mainPath, \" \").concat(cutoutPath, \"\\\"\\n            fill-rule=\\\"evenodd\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(CutoutPill, \"parameters\", {\n  width: {\n    min: 100,\n    max: 300,\n    \"default\": 200\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  cutoutWidth: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  cutoutHeight: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  },\n  cornerRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CutoutPill);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/CutoutPill.js?");

/***/ }),

/***/ "./src/shapes/DNASpiral.js":
/*!*********************************!*\
  !*** ./src/shapes/DNASpiral.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DNASpiral = /*#__PURE__*/function (_Shape) {\n  function DNASpiral() {\n    _classCallCheck(this, DNASpiral);\n    return _callSuper(this, DNASpiral, arguments);\n  }\n  _inherits(DNASpiral, _Shape);\n  return _createClass(DNASpiral, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var height = this.height,\n        width = this.width,\n        segments = this.segments,\n        thickness = this.thickness,\n        boxWidth = this.boxWidth,\n        boxHeight = this.boxHeight,\n        twist = this.twist,\n        rotationX = this.rotationX,\n        rotationY = this.rotationY;\n      var step = height / segments;\n      var angleStep = Math.PI * 2 * twist / segments;\n\n      // Calculate rotations in radians\n      var rotX = rotationX * Math.PI / 180;\n      var rotY = rotationY * Math.PI / 180;\n\n      // Store all rectangles with their z-index for proper stacking\n      var rectangles = [];\n      for (var i = 0; i < segments; i++) {\n        var angle = i * angleStep;\n        var baseY = i * step - height / 2;\n\n        // Calculate base positions for both strands\n        var x1 = Math.sin(angle) * (width / 2);\n        var z1 = Math.cos(angle) * (width / 2);\n        var x2 = Math.sin(angle + Math.PI) * (width / 2);\n        var z2 = Math.cos(angle + Math.PI) * (width / 2);\n\n        // Use consistent width for all rectangles\n        var width1 = boxWidth;\n        var width2 = boxWidth;\n\n        // Apply 3D rotations to positions\n        var pos1 = this.rotate3D(x1, baseY, z1, rotX, rotY);\n        var pos2 = this.rotate3D(x2, baseY, z2, rotX, rotY);\n\n        // Add rectangles with z-index information\n        rectangles.push({\n          svg: this.createProjectedRect(pos1.x, pos1.y, pos1.z, width1, boxHeight, thickness),\n          z: pos1.z\n        });\n        rectangles.push({\n          svg: this.createProjectedRect(pos2.x, pos2.y, pos2.z, width2, boxHeight, thickness),\n          z: pos2.z\n        });\n      }\n\n      // Sort rectangles by z-index (back to front)\n      rectangles.sort(function (a, b) {\n        return a.z - b.z;\n      });\n\n      // Add sorted rectangles to elements array\n      rectangles.forEach(function (rect) {\n        elements.push(rect.svg);\n      });\n      return elements.join('');\n    }\n\n    // Apply 3D rotation to a point\n  }, {\n    key: \"rotate3D\",\n    value: function rotate3D(x, y, z, rotX, rotY) {\n      // First rotate around X axis\n      var cosX = Math.cos(rotX);\n      var sinX = Math.sin(rotX);\n      var y1 = y * cosX - z * sinX;\n      var z1 = y * sinX + z * cosX;\n\n      // Then rotate around Y axis\n      var cosY = Math.cos(rotY);\n      var sinY = Math.sin(rotY);\n      var x2 = x * cosY + z1 * sinY;\n      var z2 = -x * sinY + z1 * cosY;\n      return {\n        x: x2,\n        y: y1,\n        z: z2\n      };\n    }\n\n    // Project a 3D point to 2D with perspective\n  }, {\n    key: \"project\",\n    value: function project(x, y, z) {\n      // Simple perspective projection\n      var focalLength = 400;\n      var scale = focalLength / (focalLength + z);\n      return {\n        x: x * scale,\n        y: y * scale,\n        scale: scale\n      };\n    }\n  }, {\n    key: \"createProjectedRect\",\n    value: function createProjectedRect(x, y, z, width, height, thickness) {\n      // Project center point with perspective\n      var center = this.project(x, y, z);\n\n      // Calculate projected dimensions\n      var projWidth = width * center.scale;\n      var projHeight = height * center.scale;\n\n      // Calculate corners\n      var left = center.x - projWidth / 2;\n      var top = center.y - projHeight / 2;\n\n      // Calculate depth for 3D effect\n      var depth = projHeight * 0.5;\n\n      // Choose style based on z position (darkening for depth)\n      var strokeColor = \"white\";\n      var fillColor = \"white\";\n\n      // Create the rectangle with 3D effect\n      if (z > 0) {\n        // Front-facing rectangle (simple)\n        return \"<rect \\n                x=\\\"\".concat(left, \"\\\" \\n                y=\\\"\").concat(top, \"\\\" \\n                width=\\\"\").concat(projWidth, \"\\\" \\n                height=\\\"\").concat(projHeight, \"\\\" \\n                fill=\\\"\").concat(fillColor, \"\\\" \\n                stroke=\\\"black\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n      } else {\n        // Create 3D box for rectangles facing away\n        // Base rectangle\n        var box = \"<rect \\n                x=\\\"\".concat(left, \"\\\" \\n                y=\\\"\").concat(top, \"\\\" \\n                width=\\\"\").concat(projWidth, \"\\\" \\n                height=\\\"\").concat(projHeight, \"\\\" \\n                fill=\\\"\").concat(fillColor, \"\\\" \\n                stroke=\\\"black\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n\n        // Add perspective lines for depth\n        var backLeft = left - depth * 0.3;\n        var backTop = top - depth * 0.15;\n\n        // Add corner lines\n        box += \"<line \\n                x1=\\\"\".concat(left, \"\\\" \\n                y1=\\\"\").concat(top, \"\\\" \\n                x2=\\\"\").concat(backLeft, \"\\\" \\n                y2=\\\"\").concat(backTop, \"\\\" \\n                stroke=\\\"black\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n        box += \"<line \\n                x1=\\\"\".concat(left + projWidth, \"\\\" \\n                y1=\\\"\").concat(top, \"\\\" \\n                x2=\\\"\").concat(backLeft + projWidth, \"\\\" \\n                y2=\\\"\").concat(backTop, \"\\\" \\n                stroke=\\\"\").concat(strokeColor, \"\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n        box += \"<line \\n                x1=\\\"\".concat(left, \"\\\" \\n                y1=\\\"\").concat(top + projHeight, \"\\\" \\n                x2=\\\"\").concat(backLeft, \"\\\" \\n                y2=\\\"\").concat(backTop + projHeight, \"\\\" \\n                stroke=\\\"\").concat(strokeColor, \"\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n        box += \"<line \\n                x1=\\\"\".concat(left + projWidth, \"\\\" \\n                y1=\\\"\").concat(top + projHeight, \"\\\" \\n                x2=\\\"\").concat(backLeft + projWidth, \"\\\" \\n                y2=\\\"\").concat(backTop + projHeight, \"\\\" \\n                stroke=\\\"\").concat(strokeColor, \"\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n\n        // Back face outline\n        box += \"<rect \\n                x=\\\"\".concat(backLeft, \"\\\" \\n                y=\\\"\").concat(backTop, \"\\\" \\n                width=\\\"\").concat(projWidth, \"\\\" \\n                height=\\\"\").concat(projHeight, \"\\\" \\n                fill=\\\"\").concat(fillColor, \"\\\" \\n                stroke=\\\"black\\\" \\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n            />\");\n        return box;\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DNASpiral, \"parameters\", {\n  height: {\n    min: 50,\n    max: 150,\n    \"default\": 150\n  },\n  width: {\n    min: 10,\n    max: 100,\n    \"default\": 100\n  },\n  segments: {\n    min: 5,\n    max: 60,\n    \"default\": 32\n  },\n  thickness: {\n    min: 1,\n    max: 5,\n    \"default\": 1\n  },\n  boxWidth: {\n    min: 4,\n    max: 50,\n    \"default\": 32\n  },\n  boxHeight: {\n    min: 3,\n    max: 30,\n    \"default\": 12\n  },\n  twist: {\n    min: 1,\n    max: 10,\n    \"default\": 1\n  },\n  rotationX: {\n    min: 0,\n    max: 360,\n    \"default\": 0\n  },\n  rotationY: {\n    min: 0,\n    max: 360,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DNASpiral);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DNASpiral.js?");

/***/ }),

/***/ "./src/shapes/DandelionShape.js":
/*!**************************************!*\
  !*** ./src/shapes/DandelionShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DandelionShape = /*#__PURE__*/function (_Shape) {\n  function DandelionShape() {\n    _classCallCheck(this, DandelionShape);\n    return _callSuper(this, DandelionShape, arguments);\n  }\n  _inherits(DandelionShape, _Shape);\n  return _createClass(DandelionShape, [{\n    key: \"point\",\n    value: function point(centerX, centerY, radius, angle) {\n      var x = centerX + radius * Math.cos(angle);\n      var y = centerY + radius * Math.sin(angle);\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"createFluff\",\n    value: function createFluff(centerX, centerY, size, angle) {\n      // Create ellipse element for the seed head\n      var rx = size;\n      var ry = size / 2;\n\n      // Apply rotation transformation\n      var transform = \"translate(\".concat(centerX, \" \").concat(centerY, \") rotate(\").concat(angle * 180 / Math.PI, \") translate(\").concat(-centerX, \" \").concat(-centerY, \")\");\n      return \"<ellipse \\n            cx=\\\"\".concat(centerX, \"\\\" \\n            cy=\\\"\").concat(centerY, \"\\\" \\n            rx=\\\"\").concat(rx, \"\\\" \\n            ry=\\\"\").concat(ry, \"\\\"\\n            transform=\\\"\").concat(transform, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var centerX = 0;\n      var centerY = 0;\n      var scale = 1;\n\n      // Scale parameters\n      var seedLength = this.seedLength * scale;\n      var seedCurve = this.seedCurve * (Math.PI / 180);\n      var fluffSize = this.fluffSize * scale;\n      var coreRadius = this.coreRadius * scale;\n      var windPhase = this.windPhase * (Math.PI / 180);\n      var elements = [];\n\n      // Draw core\n      elements.push(\"<circle \\n            cx=\\\"\".concat(centerX, \"\\\" \\n            cy=\\\"\").concat(centerY, \"\\\" \\n            r=\\\"\").concat(coreRadius, \"\\\"\\n            fill=\\\"white\\\"\\n        />\"));\n\n      // Generate seeds\n      for (var i = 0; i < this.seedCount; i++) {\n        var angle = i * 2 * Math.PI / this.seedCount + windPhase;\n\n        // Calculate stem points\n        var start = this.point(centerX, centerY, coreRadius, angle);\n        var end = this.point(centerX, centerY, seedLength, angle);\n\n        // Calculate control point for curve\n        var controlDist = seedLength * 0.6;\n        var controlAngle = angle + seedCurve;\n        var control = this.point(centerX, centerY, controlDist, controlAngle);\n\n        // Create curved stem\n        elements.push(\"<path \\n                d=\\\"M \".concat(start.x, \" \").concat(start.y, \" Q \").concat(control.x, \" \").concat(control.y, \" \").concat(end.x, \" \").concat(end.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"1\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n\n        // Add fluffy seed head\n        elements.push(this.createFluff(end.x, end.y, fluffSize, angle));\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DandelionShape, \"parameters\", {\n  seedCount: {\n    min: 12,\n    max: 48,\n    \"default\": 24\n  },\n  seedLength: {\n    min: 40,\n    max: 120,\n    \"default\": 80\n  },\n  seedCurve: {\n    min: 0,\n    max: 90,\n    \"default\": 45\n  },\n  fluffSize: {\n    min: 2,\n    max: 12,\n    \"default\": 6\n  },\n  coreRadius: {\n    min: 5,\n    max: 25,\n    \"default\": 15\n  },\n  windPhase: {\n    min: -45,\n    max: 45,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DandelionShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DandelionShape.js?");

/***/ }),

/***/ "./src/shapes/DendriteShape.js":
/*!*************************************!*\
  !*** ./src/shapes/DendriteShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DendriteShape = /*#__PURE__*/function (_Shape) {\n  function DendriteShape() {\n    _classCallCheck(this, DendriteShape);\n    return _callSuper(this, DendriteShape, arguments);\n  }\n  _inherits(DendriteShape, _Shape);\n  return _createClass(DendriteShape, [{\n    key: \"generateRadialPoint\",\n    value: function generateRadialPoint(radius, angle, randomness) {\n      var noise = this.randomness * (this.random() - 0.5);\n      var x = radius * Math.cos(angle) + noise;\n      var y = radius * Math.sin(angle) + noise;\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"findClosestPoint\",\n    value: function findClosestPoint(point, points) {\n      var minDist = Infinity;\n      var closest = null;\n      var _iterator = _createForOfIteratorHelper(points),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var p = _step.value;\n          var distance = Math.hypot(point.x - p.x, point.y - p.y);\n          if (distance < minDist) {\n            minDist = distance;\n            closest = p;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return closest;\n    }\n  }, {\n    key: \"generateLevelPoints\",\n    value: function generateLevelPoints(radius) {\n      var points = [];\n      var pointCount = Math.ceil(radius * this.spawnFactor / 10);\n      for (var i = 0; i < pointCount; i++) {\n        var angle = i / pointCount * 2 * Math.PI + this.random() * 0.2;\n        points.push(this.generateRadialPoint(radius, angle, this.randomness));\n      }\n      return points;\n    }\n  }, {\n    key: \"generateDendrites\",\n    value: function generateDendrites() {\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var currentRadius = this.radiusStep;\n      var previousLevelPoints = [center];\n      var paths = [];\n      for (var level = 0; level < this.levelCount; level++) {\n        var currentLevelPoints = this.generateLevelPoints(currentRadius);\n        var _iterator2 = _createForOfIteratorHelper(currentLevelPoints),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var endPoint = _step2.value;\n            var startPoint = this.findClosestPoint(endPoint, previousLevelPoints);\n            var foundExisting = false;\n            var _iterator3 = _createForOfIteratorHelper(paths),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var path = _step3.value;\n                var lastPoint = path[path.length - 1];\n                if (Math.abs(lastPoint.x - startPoint.x) < 0.1 && Math.abs(lastPoint.y - startPoint.y) < 0.1) {\n                  path.push(endPoint);\n                  foundExisting = true;\n                  break;\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n            if (!foundExisting) {\n              paths.push([startPoint, endPoint]);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        previousLevelPoints = currentLevelPoints;\n        currentRadius += this.radiusStep;\n      }\n      return paths;\n    }\n  }, {\n    key: \"enhancePathWithIntermediatePoints\",\n    value: function enhancePathWithIntermediatePoints(path) {\n      if (path.length < 2) return path;\n      var enhancedPath = [];\n      var numIntermediatePoints = Math.max(1, Math.floor(this.organicFactor / 2));\n      for (var i = 0; i < path.length - 1; i++) {\n        var p1 = path[i];\n        var p2 = path[i + 1];\n        enhancedPath.push(p1);\n        for (var j = 1; j <= numIntermediatePoints; j++) {\n          var t = j / (numIntermediatePoints + 1);\n          var x = p1.x + (p2.x - p1.x) * t;\n          var y = p1.y + (p2.y - p1.y) * t;\n          var dx = p2.x - p1.x;\n          var dy = p2.y - p1.y;\n          var len = Math.sqrt(dx * dx + dy * dy);\n          var perpX = -dy;\n          var perpY = dx;\n          var maxOffset = len * 0.15 * (this.organicFactor / 10);\n          var offset = (this.random() - 0.5) * maxOffset;\n          enhancedPath.push({\n            x: x + perpX / len * offset,\n            y: y + perpY / len * offset\n          });\n        }\n      }\n      enhancedPath.push(path[path.length - 1]);\n      return enhancedPath;\n    }\n  }, {\n    key: \"generateOrganicCurve\",\n    value: function generateOrganicCurve(points) {\n      if (points.length < 2) return '';\n      if (points.length === 2) {\n        return \"M\".concat(points[0].x, \",\").concat(points[0].y, \" L\").concat(points[1].x, \",\").concat(points[1].y);\n      }\n      var pathData = \"M\".concat(points[0].x, \",\").concat(points[0].y);\n      for (var i = 1; i < points.length; i++) {\n        var prev = points[i - 1];\n        var current = points[i];\n        if (i < points.length - 1) {\n          var next = points[i + 1];\n          var cpX = (prev.x + current.x) / 2;\n          var cpY = (prev.y + current.y) / 2;\n          var dx1 = current.x - prev.x;\n          var dy1 = current.y - prev.y;\n          var dx2 = next.x - current.x;\n          var dy2 = next.y - current.y;\n          var organicOffset = this.organicFactor / 20;\n          var offsetX = (this.random() - 0.5) * organicOffset * Math.abs(dx1 + dx2);\n          var offsetY = (this.random() - 0.5) * organicOffset * Math.abs(dy1 + dy2);\n          pathData += \" Q\".concat(cpX + offsetX, \",\").concat(cpY + offsetY, \" \").concat(current.x, \",\").concat(current.y);\n        } else {\n          pathData += \" L\".concat(current.x, \",\").concat(current.y);\n        }\n      }\n      return pathData;\n    }\n  }, {\n    key: \"generateStraightPaths\",\n    value: function generateStraightPaths(paths) {\n      var _this = this;\n      return paths.map(function (path) {\n        var enhancedPath = _this.enhancePathWithIntermediatePoints(path);\n        return enhancedPath.map(function (point, index) {\n          if (index === 0) return \"M\".concat(point.x, \" \").concat(point.y);\n          return \"L\".concat(point.x, \" \").concat(point.y);\n        }).join(' ');\n      });\n    }\n  }, {\n    key: \"generateCurvedPaths\",\n    value: function generateCurvedPaths(paths) {\n      var _this2 = this;\n      return paths.map(function (path) {\n        var enhancedPath = _this2.enhancePathWithIntermediatePoints(path);\n        return _this2.generateOrganicCurve(enhancedPath);\n      });\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this3 = this;\n      this.resetRNG(this.seed);\n      var paths = this.generateDendrites();\n      var pathStrings;\n      if (this.curveStyle === 'curved') {\n        pathStrings = this.generateCurvedPaths(paths);\n      } else {\n        pathStrings = this.generateStraightPaths(paths);\n      }\n      return pathStrings.map(function (pathString) {\n        return \"<path \\n                d=\\\"\".concat(pathString, \"\\\" \\n                fill=\\\"none\\\" \\n                stroke=\\\"white\\\" \\n                stroke-width=\\\"\").concat(_this3.branchThickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(_this3.lineCap, \"\\\"\\n            />\");\n      }).join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DendriteShape, \"parameters\", {\n  levelCount: {\n    min: 1,\n    max: 15,\n    \"default\": 5\n  },\n  spawnFactor: {\n    min: 1,\n    max: 12,\n    \"default\": 3\n  },\n  radiusStep: {\n    min: 5,\n    max: 20,\n    \"default\": 20\n  },\n  branchThickness: {\n    min: 1,\n    max: 8,\n    \"default\": 2\n  },\n  randomness: {\n    min: 0,\n    max: 10,\n    \"default\": 2\n  },\n  curveStyle: {\n    options: ['straight', 'curved'],\n    \"default\": 'curved'\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  },\n  organicFactor: {\n    min: 0,\n    max: 10,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DendriteShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DendriteShape.js?");

/***/ }),

/***/ "./src/shapes/DiagonalCircleShape.js":
/*!*******************************************!*\
  !*** ./src/shapes/DiagonalCircleShape.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DiagonalCircleShape = /*#__PURE__*/function (_Shape) {\n  function DiagonalCircleShape() {\n    _classCallCheck(this, DiagonalCircleShape);\n    return _callSuper(this, DiagonalCircleShape, arguments);\n  }\n  _inherits(DiagonalCircleShape, _Shape);\n  return _createClass(DiagonalCircleShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var centerX = 0;\n      var centerY = 0;\n\n      // Scale values to match viewBox\n      var viewBoxScale = 1;\n      var circleRadius = this.circleSize / 2 * viewBoxScale;\n      var lineThickness = this.lineThickness * viewBoxScale;\n      var lineAngle = this.lineAngle * (Math.PI / 180); // Convert to radians\n\n      // Calculate line endpoints based on circle size and length parameter\n      var lineHalfLength = circleRadius * this.lineLength;\n      var dx = Math.cos(lineAngle) * lineHalfLength;\n      var dy = Math.sin(lineAngle) * lineHalfLength;\n\n      // Generate a unique ID for the mask\n      var maskId = \"circle-mask-\".concat(Math.random().toString(36).substr(2, 9));\n      return \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <!-- Base circle (white) -->\\n                    <circle \\n                        cx=\\\"\").concat(centerX, \"\\\" \\n                        cy=\\\"\").concat(centerY, \"\\\" \\n                        r=\\\"\").concat(circleRadius, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\\n                    \\n                    <!-- Cutout line (black) -->\\n                    <line \\n                        x1=\\\"\").concat(centerX - dx, \"\\\"\\n                        y1=\\\"\").concat(centerY - dy, \"\\\"\\n                        x2=\\\"\").concat(centerX + dx, \"\\\"\\n                        y2=\\\"\").concat(centerY + dy, \"\\\"\\n                        stroke=\\\"black\\\"\\n                        stroke-width=\\\"\").concat(lineThickness, \"\\\"\\n                        stroke-linecap=\\\"round\\\"\\n                    />\\n                </mask>\\n            </defs>\\n            \\n            <!-- Main shape with mask -->\\n            <g>\\n                <circle \\n                    cx=\\\"\").concat(centerX, \"\\\" \\n                    cy=\\\"\").concat(centerY, \"\\\" \\n                    r=\\\"\").concat(circleRadius, \"\\\"\\n                    fill=\\\"white\\\"\\n                    mask=\\\"url(#\").concat(maskId, \")\\\"\\n                />\\n            </g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiagonalCircleShape, \"parameters\", {\n  circleSize: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  lineThickness: {\n    min: 1,\n    max: 20,\n    \"default\": 10\n  },\n  lineAngle: {\n    min: -45,\n    max: 45,\n    \"default\": -45\n  },\n  lineLength: {\n    min: 0.5,\n    max: 1.2,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiagonalCircleShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiagonalCircleShape.js?");

/***/ }),

/***/ "./src/shapes/DiagonalGrid.js":
/*!************************************!*\
  !*** ./src/shapes/DiagonalGrid.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DiagonalGrid = /*#__PURE__*/function (_Shape) {\n  function DiagonalGrid() {\n    _classCallCheck(this, DiagonalGrid);\n    return _callSuper(this, DiagonalGrid, arguments);\n  }\n  _inherits(DiagonalGrid, _Shape);\n  return _createClass(DiagonalGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.baseSize = 150;\n      var cells = [];\n      var cellSize = this.baseSize / this.gridSize;\n      var startX = -this.baseSize / 2;\n      var startY = -this.baseSize / 2;\n\n      // Generate triangular grid pattern\n      for (var i = 0; i < this.gridSize; i++) {\n        for (var j = 0; j <= i; j++) {\n          var x = startX + j * cellSize + cellSize / 2;\n          var y = startY + i * cellSize + cellSize / 2;\n\n          // Apply cell rotation if in rotated mode\n          var cellRotation = this.cellMode === 'rotated' ? 45 : 0;\n          cells.push(\"<g transform=\\\"translate(\".concat(x, \",\").concat(y, \") rotate(\").concat(cellRotation, \")\\\">\\n                    <rect \\n                        x=\\\"\").concat(-cellSize / 2 + this.inset, \"\\\"\\n                        y=\\\"\").concat(-cellSize / 2 + this.inset, \"\\\"\\n                        width=\\\"\").concat(cellSize - this.inset * 2, \"\\\"\\n                        height=\\\"\").concat(cellSize - this.inset * 2, \"\\\"\\n                        fill=\\\"\").concat(this.fillStyle === 'fill' ? 'white' : 'none', \"\\\"\\n                        stroke=\\\"white\\\"\\n                        stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    />\\n                </g>\"));\n        }\n      }\n      return cells.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiagonalGrid, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 8,\n    \"default\": 3\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  cellMode: {\n    options: ['normal', 'rotated'],\n    \"default\": 'normal'\n  },\n  fillStyle: {\n    options: ['stroke', 'fill'],\n    \"default\": 'stroke'\n  },\n  inset: {\n    min: 0,\n    max: 10,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiagonalGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiagonalGrid.js?");

/***/ }),

/***/ "./src/shapes/DiagonalStripes.js":
/*!***************************************!*\
  !*** ./src/shapes/DiagonalStripes.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DiagonalStripes = /*#__PURE__*/function (_Shape) {\n  function DiagonalStripes() {\n    _classCallCheck(this, DiagonalStripes);\n    return _callSuper(this, DiagonalStripes, arguments);\n  }\n  _inherits(DiagonalStripes, _Shape);\n  return _createClass(DiagonalStripes, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var size = this.size;\n      var diagonalLength = Math.sqrt(2) * size * 1.2; // Extended to ensure coverage\n\n      // Calculate base stripe width without spacing\n      var baseStripeWidth = diagonalLength / (this.stripeCount * 2);\n\n      // Calculate pattern width including spacing\n      var totalWidth = baseStripeWidth * this.stripeCount + this.spacing * (this.stripeCount - 1);\n\n      // Center the pattern\n      var startX = -totalWidth / 2;\n\n      // Create clipping path\n      var clipId = \"square-clip-\".concat(Math.random().toString(36).substr(2, 9));\n      var halfSize = size / 2;\n      var clipPath = \"<defs>\\n            <clipPath id=\\\"\".concat(clipId, \"\\\">\\n                <rect \\n                    x=\\\"\").concat(-halfSize, \"\\\" \\n                    y=\\\"\").concat(-halfSize, \"\\\" \\n                    width=\\\"\").concat(size, \"\\\" \\n                    height=\\\"\").concat(size, \"\\\"\\n                />\\n            </clipPath>\\n        </defs>\");\n\n      // Generate stripes\n      var stripes = [];\n      for (var i = 0; i < this.stripeCount; i++) {\n        var x = startX + i * (baseStripeWidth + this.spacing);\n        stripes.push(\"<rect \\n                x=\\\"\".concat(x, \"\\\"\\n                y=\\\"\").concat(-diagonalLength / 2, \"\\\"\\n                width=\\\"\").concat(baseStripeWidth, \"\\\"\\n                height=\\\"\").concat(diagonalLength, \"\\\"\\n                fill=\\\"white\\\"\\n                transform=\\\"rotate(45, 0, 0)\\\"\\n            />\"));\n      }\n      return \"\\n            \".concat(clipPath, \"\\n            <g clip-path=\\\"url(#\").concat(clipId, \")\\\">\\n                \").concat(stripes.join('\\n                '), \"\\n            </g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiagonalStripes, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 140\n  },\n  stripeCount: {\n    min: 2,\n    max: 20,\n    \"default\": 5\n  },\n  spacing: {\n    min: 1,\n    max: 50,\n    \"default\": 20\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiagonalStripes);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiagonalStripes.js?");

/***/ }),

/***/ "./src/shapes/DiagonalTechShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/DiagonalTechShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DiagonalTechShape = /*#__PURE__*/function (_Shape) {\n  function DiagonalTechShape() {\n    _classCallCheck(this, DiagonalTechShape);\n    return _callSuper(this, DiagonalTechShape, arguments);\n  }\n  _inherits(DiagonalTechShape, _Shape);\n  return _createClass(DiagonalTechShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Center point (0,0) since we're using the -200,-200,400,400 viewBox\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Convert slant angle to radians\n      var slantRad = this.slantAngle * Math.PI / 180;\n\n      // Create center diamond points\n      var diamondPoints = [\"\".concat(center.x - this.centerSize / 2, \",\").concat(center.y), // Left\n      \"\".concat(center.x, \",\").concat(center.y - this.centerSize / 2), // Top\n      \"\".concat(center.x + this.centerSize / 2, \",\").concat(center.y), // Right\n      \"\".concat(center.x, \",\").concat(center.y + this.centerSize / 2) // Bottom\n      ];\n\n      // Calculate arm offsets using trigonometry\n      var dx = Math.cos(slantRad) * this.armLength;\n      var dy = Math.sin(slantRad) * this.armLength;\n\n      // Upper-left arm points\n      var upperLeftArm = [\"\".concat(center.x - this.centerSize / 2, \",\").concat(center.y), // Start at diamond\n      \"\".concat(center.x - this.centerSize / 2 - dx, \",\").concat(center.y - dy), // Outer point\n      \"\".concat(center.x - this.centerSize / 2 - dx, \",\").concat(center.y - dy + this.armWidth), // Width\n      \"\".concat(center.x - this.centerSize / 2, \",\").concat(center.y + this.armWidth) // Back to diamond\n      ];\n\n      // Lower-right arm points\n      var lowerRightArm = [\"\".concat(center.x + this.centerSize / 2, \",\").concat(center.y), // Start at diamond\n      \"\".concat(center.x + this.centerSize / 2 + dx, \",\").concat(center.y + dy), // Outer point\n      \"\".concat(center.x + this.centerSize / 2 + dx, \",\").concat(center.y + dy - this.armWidth), // Width\n      \"\".concat(center.x + this.centerSize / 2, \",\").concat(center.y - this.armWidth) // Back to diamond\n      ];\n\n      // Construct SVG paths\n      return \"\\n            <path d=\\\"M \".concat(diamondPoints[0], \" L \").concat(diamondPoints[1], \" L \").concat(diamondPoints[2], \" L \").concat(diamondPoints[3], \" Z\\\" \\n                  fill=\\\"white\\\" />\\n            <path d=\\\"M \").concat(upperLeftArm[0], \" L \").concat(upperLeftArm[1], \" L \").concat(upperLeftArm[2], \" L \").concat(upperLeftArm[3], \" Z\\\" \\n                  fill=\\\"white\\\" />\\n            <path d=\\\"M \").concat(lowerRightArm[0], \" L \").concat(lowerRightArm[1], \" L \").concat(lowerRightArm[2], \" L \").concat(lowerRightArm[3], \" Z\\\" \\n                  fill=\\\"white\\\" />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiagonalTechShape, \"parameters\", {\n  centerSize: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  armLength: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  armWidth: {\n    min: 10,\n    max: 80,\n    \"default\": 30\n  },\n  slantAngle: {\n    min: 15,\n    max: 75,\n    \"default\": 45\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiagonalTechShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiagonalTechShape.js?");

/***/ }),

/***/ "./src/shapes/DiamondArrowShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/DiamondArrowShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DiamondArrowShape = /*#__PURE__*/function (_Shape) {\n  function DiamondArrowShape() {\n    _classCallCheck(this, DiamondArrowShape);\n    return _callSuper(this, DiamondArrowShape, arguments);\n  }\n  _inherits(DiamondArrowShape, _Shape);\n  return _createClass(DiamondArrowShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var centerX = 0;\n      var centerY = 0;\n\n      // Scale values\n      var scaledSize = this.size;\n      var arrowWidthSize = scaledSize * this.arrowWidth;\n      var arrowDepthSize = scaledSize * this.arrowDepth;\n\n      // Calculate diamond points\n      var top = \"\".concat(centerX, \",\").concat(centerY - scaledSize / 2);\n      var right = \"\".concat(centerX + scaledSize / 2, \",\").concat(centerY);\n      var bottom = \"\".concat(centerX, \",\").concat(centerY + scaledSize / 2);\n      var left = \"\".concat(centerX - scaledSize / 2, \",\").concat(centerY);\n\n      // Generate a unique ID for the mask\n      var maskId = \"diamond-mask-\".concat(Math.random().toString(36).substr(2, 9));\n      return \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <!-- Base diamond (white) -->\\n                    <polygon \\n                        points=\\\"\").concat(top, \" \").concat(right, \" \").concat(bottom, \" \").concat(left, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\\n                    \\n                    <!-- Arrow cutouts (black) -->\\n                    <polygon \\n                        points=\\\"\").concat(centerX - arrowWidthSize / 2, \",\").concat(centerY - arrowDepthSize, \" \\n                               \").concat(centerX, \",\").concat(centerY, \" \\n                               \").concat(centerX + arrowWidthSize / 2, \",\").concat(centerY - arrowDepthSize, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                    <polygon \\n                        points=\\\"\").concat(centerX - arrowWidthSize / 2, \",\").concat(centerY + arrowDepthSize, \" \\n                               \").concat(centerX, \",\").concat(centerY, \" \\n                               \").concat(centerX + arrowWidthSize / 2, \",\").concat(centerY + arrowDepthSize, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                </mask>\\n            </defs>\\n            \\n            <!-- Main shape with mask -->\\n            <polygon \\n                points=\\\"\").concat(top, \" \").concat(right, \" \").concat(bottom, \" \").concat(left, \"\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiamondArrowShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 300,\n    \"default\": 200\n  },\n  arrowWidth: {\n    min: 0.1,\n    max: 0.5,\n    \"default\": 0.3\n  },\n  arrowDepth: {\n    min: 0.1,\n    max: 0.5,\n    \"default\": 0.3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiamondArrowShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiamondArrowShape.js?");

/***/ }),

/***/ "./src/shapes/DiamondHexShape.js":
/*!***************************************!*\
  !*** ./src/shapes/DiamondHexShape.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DiamondHexShape = /*#__PURE__*/function (_Shape) {\n  function DiamondHexShape() {\n    _classCallCheck(this, DiamondHexShape);\n    return _callSuper(this, DiamondHexShape, arguments);\n  }\n  _inherits(DiamondHexShape, _Shape);\n  return _createClass(DiamondHexShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Center point (0,0) since we're using the -200,-200,400,400 viewBox\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Generate hexagon points\n      var hexPoints = [];\n      for (var i = 0; i < 6; i++) {\n        var angle = i * Math.PI / 3;\n        hexPoints.push({\n          x: center.x + Math.cos(angle) * this.hexSize,\n          y: center.y + Math.sin(angle) * this.hexSize\n        });\n      }\n\n      // Generate diamond points\n      var diamondPoints = [{\n        x: center.x,\n        y: center.y - this.diamondHeight / 2\n      },\n      // Top\n      {\n        x: center.x + this.diamondWidth / 2,\n        y: center.y\n      },\n      // Right\n      {\n        x: center.x,\n        y: center.y + this.diamondHeight / 2\n      },\n      // Bottom\n      {\n        x: center.x - this.diamondWidth / 2,\n        y: center.y\n      } // Left\n      ];\n\n      // Create hexagon path\n      var hexPath = \"M \".concat(hexPoints[0].x, \",\").concat(hexPoints[0].y, \" \") + hexPoints.slice(1).map(function (p) {\n        return \"L \".concat(p.x, \",\").concat(p.y);\n      }).join(' ') + ' Z';\n\n      // Create diamond path with optional rounded corners\n      var diamondPath;\n      // Generate path with sharp corners\n      diamondPath = \"M \".concat(diamondPoints[0].x, \",\").concat(diamondPoints[0].y, \" \") + diamondPoints.slice(1).map(function (p) {\n        return \"L \".concat(p.x, \",\").concat(p.y);\n      }).join(' ') + ' Z';\n\n      // Return combined path using fill-rule to create cutout effect\n      return \"<path \\n            d=\\\"\".concat(hexPath, \" \").concat(diamondPath, \"\\\"\\n            fill=\\\"white\\\"\\n            fill-rule=\\\"evenodd\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiamondHexShape, \"parameters\", {\n  hexSize: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  diamondWidth: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  diamondHeight: {\n    min: 10,\n    max: 150,\n    \"default\": 80\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiamondHexShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiamondHexShape.js?");

/***/ }),

/***/ "./src/shapes/DiamondPairShape.js":
/*!****************************************!*\
  !*** ./src/shapes/DiamondPairShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DiamondPairShape = /*#__PURE__*/function (_Shape) {\n  function DiamondPairShape() {\n    _classCallCheck(this, DiamondPairShape);\n    return _callSuper(this, DiamondPairShape, arguments);\n  }\n  _inherits(DiamondPairShape, _Shape);\n  return _createClass(DiamondPairShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var centerX = 0;\n      var centerY = 0;\n      var scale = 1;\n\n      // Scale values\n      var width = this.width * scale;\n      var height = this.height * scale;\n      var angleRad = this.angle * Math.PI / 180;\n      var separation = this.separation * scale;\n\n      // Calculate points for left diamond\n      var leftCenterX = centerX - width / 2 - separation / 2;\n      var leftPoints = [\"\".concat(leftCenterX, \",\").concat(centerY - height / 2), // top\n      \"\".concat(leftCenterX - width / 2 * Math.cos(angleRad), \",\").concat(centerY), // left\n      \"\".concat(leftCenterX, \",\").concat(centerY + height / 2), // bottom\n      \"\".concat(leftCenterX + width / 2 * Math.cos(angleRad), \",\").concat(centerY) // right\n      ].join(' ');\n\n      // Calculate points for right diamond\n      var rightCenterX = centerX + width / 2 + separation / 2;\n      var rightPoints = [\"\".concat(rightCenterX, \",\").concat(centerY - height / 2), // top\n      \"\".concat(rightCenterX - width / 2 * Math.cos(angleRad), \",\").concat(centerY), // left\n      \"\".concat(rightCenterX, \",\").concat(centerY + height / 2), // bottom\n      \"\".concat(rightCenterX + width / 2 * Math.cos(angleRad), \",\").concat(centerY) // right\n      ].join(' ');\n      return \"\\n            <g>\\n                <!-- Left diamond -->\\n                <polygon \\n                    points=\\\"\".concat(leftPoints, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\\n                \\n                <!-- Right diamond -->\\n                <polygon \\n                    points=\\\"\").concat(rightPoints, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\\n            </g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiamondPairShape, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  angle: {\n    min: 30,\n    max: 80,\n    \"default\": 60\n  },\n  separation: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiamondPairShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiamondPairShape.js?");

/***/ }),

/***/ "./src/shapes/DiamondStarShape.js":
/*!****************************************!*\
  !*** ./src/shapes/DiamondStarShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DiamondStarShape = /*#__PURE__*/function (_Shape) {\n  function DiamondStarShape() {\n    _classCallCheck(this, DiamondStarShape);\n    return _callSuper(this, DiamondStarShape, arguments);\n  }\n  _inherits(DiamondStarShape, _Shape);\n  return _createClass(DiamondStarShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Use 100 as our base scale since we're in SVG viewBox coordinates\n      var scale = 100;\n      var center = {\n        x: 0,\n        y: 0\n      }; // Center point in viewBox\n\n      // Calculate four corners of outer diamond\n      var outerPoints = [{\n        x: center.x,\n        y: center.y - scale * this.spread\n      },\n      // Top\n      {\n        x: center.x + scale * this.spread,\n        y: center.y\n      },\n      // Right\n      {\n        x: center.x,\n        y: center.y + scale * this.spread\n      },\n      // Bottom\n      {\n        x: center.x - scale * this.spread,\n        y: center.y\n      } // Left\n      ];\n\n      // Calculate inner square points\n      var innerScale = scale * this.centerSize;\n      var innerPoints = [{\n        x: center.x - innerScale,\n        y: center.y - innerScale\n      },\n      // Top left\n      {\n        x: center.x + innerScale,\n        y: center.y - innerScale\n      },\n      // Top right\n      {\n        x: center.x + innerScale,\n        y: center.y + innerScale\n      },\n      // Bottom right\n      {\n        x: center.x - innerScale,\n        y: center.y + innerScale\n      } // Bottom left\n      ];\n\n      // Generate the four triangular segments\n      var segments = [];\n      for (var i = 0; i < 4; i++) {\n        var trianglePoint = outerPoints[i];\n        var innerPoint1 = innerPoints[i];\n        var innerPoint2 = innerPoints[(i + 1) % 4];\n\n        // Calculate inset point using triangleDepth\n        var insetX = trianglePoint.x * this.triangleDepth + center.x * (1 - this.triangleDepth);\n        var insetY = trianglePoint.y * this.triangleDepth + center.y * (1 - this.triangleDepth);\n\n        // Create path for this segment\n        segments.push(\"\\n                <path d=\\\"\\n                    M \".concat(innerPoint1.x, \",\").concat(innerPoint1.y, \"\\n                    L \").concat(trianglePoint.x, \",\").concat(trianglePoint.y, \"\\n                    L \").concat(innerPoint2.x, \",\").concat(innerPoint2.y, \"\\n                    L \").concat(insetX, \",\").concat(insetY, \"\\n                    Z\\n                \\\" fill=\\\"white\\\" />\\n            \"));\n      }\n      return segments.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiamondStarShape, \"parameters\", {\n  spread: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.7\n  },\n  centerSize: {\n    min: 0.1,\n    max: 0.5,\n    \"default\": 0.2\n  },\n  triangleDepth: {\n    min: 0.1,\n    max: 0.8,\n    \"default\": 0.7\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiamondStarShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DiamondStarShape.js?");

/***/ }),

/***/ "./src/shapes/Dice.js":
/*!****************************!*\
  !*** ./src/shapes/Dice.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DiceCutoutShape = /*#__PURE__*/function (_Shape) {\n  function DiceCutoutShape() {\n    _classCallCheck(this, DiceCutoutShape);\n    return _callSuper(this, DiceCutoutShape, arguments);\n  }\n  _inherits(DiceCutoutShape, _Shape);\n  return _createClass(DiceCutoutShape, [{\n    key: \"calculateOptimalParameters\",\n    value: function calculateOptimalParameters() {\n      var halfSize = this.size / 2;\n      var usableSpace = this.size - 2 * this.padding;\n\n      // Calculate the maximum safe dot size based on usable space\n      var maxSafeDotSize = Math.min(usableSpace / 5,\n      // Ensure 5 dots can fit with spacing\n      this.dotSize // User requested size\n      );\n\n      // Set actual dot size\n      this.actualDotSize = maxSafeDotSize;\n\n      // Calculate spacing between dots\n      // Use 2.5 times dot size as minimum spacing to prevent overlap\n      var minSpacing = this.actualDotSize * 2.5;\n\n      // Calculate dot offset ensuring proper spacing\n      this.dotOffset = Math.min((usableSpace - 2 * this.actualDotSize) / 2,\n      // Maximum possible offset\n      Math.max(minSpacing,\n      // Minimum spacing\n      (usableSpace - 2 * this.actualDotSize) / 3 // Optimal spacing for 3x3 grid\n      ));\n    }\n  }, {\n    key: \"getDotPositions\",\n    value: function getDotPositions() {\n      var positions = {\n        1: [[0, 0]],\n        2: [[-1, -1], [1, 1]],\n        3: [[-1, -1], [0, 0], [1, 1]],\n        4: [[-1, -1], [1, -1], [-1, 1], [1, 1]],\n        5: [[-1, -1], [1, -1], [0, 0], [-1, 1], [1, 1]],\n        6: [[-1, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [1, 1]],\n        7: [[-1, -1], [1, -1], [-1, 0], [0, 0], [1, 0], [-1, 1], [1, 1]],\n        8: [[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]],\n        9: [[-1, -1], [0, -1], [1, -1], [-1, 0], [0, 0], [1, 0], [-1, 1], [0, 1], [1, 1]]\n      };\n      return positions[this.value] || positions[1];\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Calculate the parameters before generating the shape\n      this.calculateOptimalParameters();\n      var halfSize = this.size / 2;\n\n      // Create main rounded square\n      var mainPath = [\"M\".concat(-halfSize + this.cornerRadius, \",\").concat(-halfSize), \"h\".concat(this.size - 2 * this.cornerRadius), \"q\".concat(this.cornerRadius, \",0 \").concat(this.cornerRadius, \",\").concat(this.cornerRadius), \"v\".concat(this.size - 2 * this.cornerRadius), \"q0,\".concat(this.cornerRadius, \" \").concat(-this.cornerRadius, \",\").concat(this.cornerRadius), \"h\".concat(-this.size + 2 * this.cornerRadius), \"q\".concat(-this.cornerRadius, \",0 \").concat(-this.cornerRadius, \",\").concat(-this.cornerRadius), \"v\".concat(-this.size + 2 * this.cornerRadius), \"q0,\".concat(-this.cornerRadius, \" \").concat(this.cornerRadius, \",\").concat(-this.cornerRadius), 'Z'].join(' ');\n\n      // Create dots with proper spacing\n      var dotPositions = this.getDotPositions();\n\n      // Generate separate paths for each dot instead of combining them\n      var dotPaths = dotPositions.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        var cx = x * _this.dotOffset;\n        var cy = y * _this.dotOffset;\n        return \"<circle cx=\\\"\".concat(cx, \"\\\" cy=\\\"\").concat(cy, \"\\\" r=\\\"\").concat(_this.actualDotSize, \"\\\" fill=\\\"black\\\" />\");\n      }).join('');\n\n      // Return SVG with main path and dot circles\n      return \"\\n            <path \\n                d=\\\"\".concat(mainPath, \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n            \").concat(dotPaths, \"\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DiceCutoutShape, \"parameters\", {\n  size: {\n    min: 120,\n    max: 250,\n    \"default\": 150\n  },\n  cornerRadius: {\n    min: 0,\n    max: 60,\n    \"default\": 50\n  },\n  padding: {\n    min: 5,\n    max: 50,\n    \"default\": 17\n  },\n  dotSize: {\n    min: 5,\n    max: 40,\n    \"default\": 10\n  },\n  value: {\n    min: 1,\n    max: 9,\n    \"default\": 5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiceCutoutShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Dice.js?");

/***/ }),

/***/ "./src/shapes/DotSpiral.js":
/*!*********************************!*\
  !*** ./src/shapes/DotSpiral.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DotSpiral = /*#__PURE__*/function (_Shape) {\n  function DotSpiral() {\n    _classCallCheck(this, DotSpiral);\n    return _callSuper(this, DotSpiral, arguments);\n  }\n  _inherits(DotSpiral, _Shape);\n  return _createClass(DotSpiral, [{\n    key: \"getSpreadAngle\",\n    value: function getSpreadAngle() {\n      return this.spread * (Math.PI / 180);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n\n      // Calculate angle step between each segment\n      var angleStep = 2 * Math.PI / this.segments;\n\n      // Generate dots along each segment\n      for (var i = 0; i < this.segments; i++) {\n        // Start position is at the center\n        var x = 0;\n        var y = 0;\n\n        // Calculate starting angle for this segment\n        var startAngle = i * angleStep;\n\n        // Add a few dots per segment\n        for (var j = 0; j < 4; j++) {\n          // Increase radius gradually to create spiral effect\n          var radius = (j + 1) * (this.spiralSize / 5.5); // Adjust divisor for spacing\n\n          // Calculate current angle on the spiral\n          var t = j / 3.0; // Progress through the spiral (0 to 1)\n          var progressAngle = this.getSpreadAngle() * t;\n\n          // Apply rotation and spiral effect\n          var finalAngle = startAngle + progressAngle;\n\n          // Calculate dot position using polar coordinates\n          x = radius * Math.cos(finalAngle);\n          y = radius * Math.sin(finalAngle);\n\n          // Create dot element\n          elements.push(\"<circle \\n                    cx=\\\"\".concat(x, \"\\\" \\n                    cy=\\\"\").concat(y, \"\\\"\\n                    r=\\\"\").concat(this.dotSize, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DotSpiral, \"parameters\", {\n  dotSize: {\n    min: 1,\n    max: 20,\n    \"default\": 4\n  },\n  spiralSize: {\n    min: 50,\n    max: 120,\n    \"default\": 120\n  },\n  // Radius of spiral\n  segments: {\n    min: 3,\n    max: 24,\n    \"default\": 6\n  },\n  // Number of spiral arms\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 8\n  },\n  spread: {\n    min: 20,\n    max: 120,\n    \"default\": 90\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DotSpiral);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DotSpiral.js?");

/***/ }),

/***/ "./src/shapes/DoubleChevronShape.js":
/*!******************************************!*\
  !*** ./src/shapes/DoubleChevronShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DoubleChevronShape = /*#__PURE__*/function (_Shape) {\n  function DoubleChevronShape() {\n    _classCallCheck(this, DoubleChevronShape);\n    return _callSuper(this, DoubleChevronShape, arguments);\n  }\n  _inherits(DoubleChevronShape, _Shape);\n  return _createClass(DoubleChevronShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Center point (0,0) since we're using the -200,-200,400,400 viewBox\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Convert angle to radians and calculate height\n      var angleRad = this.angle * Math.PI / 180;\n      var height = this.width * Math.tan(angleRad) / 2;\n\n      // Calculate points for top chevron\n      var topY = center.y - this.spacing / 2;\n      var topPoints = [{\n        x: center.x - this.width / 2,\n        y: topY + height / 2\n      },\n      // Left\n      {\n        x: center.x,\n        y: topY - height / 2\n      },\n      // Center\n      {\n        x: center.x + this.width / 2,\n        y: topY + height / 2\n      } // Right\n      ];\n\n      // Calculate points for bottom chevron\n      var bottomY = center.y + this.spacing / 2;\n      var bottomPoints = [{\n        x: center.x - this.width / 2,\n        y: bottomY + height / 2\n      },\n      // Left\n      {\n        x: center.x,\n        y: bottomY - height / 2\n      },\n      // Center\n      {\n        x: center.x + this.width / 2,\n        y: bottomY + height / 2\n      } // Right\n      ];\n\n      // Create paths for both chevrons\n      var topPath = \"M \".concat(topPoints[0].x, \",\").concat(topPoints[0].y, \" \\n                        L \").concat(topPoints[1].x, \",\").concat(topPoints[1].y, \" \\n                        L \").concat(topPoints[2].x, \",\").concat(topPoints[2].y);\n      var bottomPath = \"M \".concat(bottomPoints[0].x, \",\").concat(bottomPoints[0].y, \" \\n                           L \").concat(bottomPoints[1].x, \",\").concat(bottomPoints[1].y, \" \\n                           L \").concat(bottomPoints[2].x, \",\").concat(bottomPoints[2].y);\n\n      // Return combined paths with stroke styling\n      return \"<path \\n            d=\\\"\".concat(topPath, \" \").concat(bottomPath, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"square\\\"\\n            stroke-linejoin=\\\"miter\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DoubleChevronShape, \"parameters\", {\n  spacing: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  // Space between chevrons\n  thickness: {\n    min: 2,\n    max: 50,\n    \"default\": 15\n  },\n  // Thickness of lines\n  angle: {\n    min: 20,\n    max: 50,\n    \"default\": 45\n  },\n  // Angle of points\n  width: {\n    min: 100,\n    max: 300,\n    \"default\": 200\n  } // Width of chevrons\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DoubleChevronShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DoubleChevronShape.js?");

/***/ }),

/***/ "./src/shapes/DoubleXShape.js":
/*!************************************!*\
  !*** ./src/shapes/DoubleXShape.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DoubleXShape = /*#__PURE__*/function (_Shape) {\n  function DoubleXShape() {\n    _classCallCheck(this, DoubleXShape);\n    return _callSuper(this, DoubleXShape, arguments);\n  }\n  _inherits(DoubleXShape, _Shape);\n  return _createClass(DoubleXShape, [{\n    key: \"createX\",\n    value: function createX(center, size, angleRad) {\n      var halfSize = size / 2;\n\n      // Calculate corners of the X shape\n      var topLeft = {\n        x: center.x - halfSize * Math.cos(angleRad),\n        y: center.y - halfSize\n      };\n      var topRight = {\n        x: center.x + halfSize * Math.cos(angleRad),\n        y: center.y - halfSize\n      };\n      var bottomLeft = {\n        x: center.x - halfSize * Math.cos(angleRad),\n        y: center.y + halfSize\n      };\n      var bottomRight = {\n        x: center.x + halfSize * Math.cos(angleRad),\n        y: center.y + halfSize\n      };\n\n      // Create paths for both diagonals\n      return \"M \".concat(topLeft.x, \",\").concat(topLeft.y, \" L \").concat(bottomRight.x, \",\").concat(bottomRight.y, \" \\n                M \").concat(topRight.x, \",\").concat(topRight.y, \" L \").concat(bottomLeft.x, \",\").concat(bottomLeft.y);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Calculate base size to ensure shape stays within bounds\n      var baseSize = 100 * this.scale; // Adjusted for viewBox scale\n\n      // Convert angle to radians\n      var angleRad = this.angle * Math.PI / 180;\n\n      // Create paths for both X shapes\n      var x1 = this.createX({\n        x: center.x - this.overlap / 2,\n        y: center.y\n      }, baseSize, angleRad);\n      var x2 = this.createX({\n        x: center.x + this.overlap / 2,\n        y: center.y\n      }, baseSize, angleRad);\n\n      // Return combined paths with stroke styling\n      return \"<path \\n            d=\\\"\".concat(x1, \" \").concat(x2, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"square\\\"\\n            stroke-linejoin=\\\"miter\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DoubleXShape, \"parameters\", {\n  thickness: {\n    min: 1,\n    max: 80,\n    \"default\": 20\n  },\n  overlap: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  },\n  angle: {\n    min: 0,\n    max: 15,\n    \"default\": 6\n  },\n  scale: {\n    min: 0.2,\n    max: 0.8,\n    \"default\": 0.8\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DoubleXShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DoubleXShape.js?");

/***/ }),

/***/ "./src/shapes/DualLensShape.js":
/*!*************************************!*\
  !*** ./src/shapes/DualLensShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar DualLensShape = /*#__PURE__*/function (_Shape) {\n  function DualLensShape() {\n    _classCallCheck(this, DualLensShape);\n    return _callSuper(this, DualLensShape, arguments);\n  }\n  _inherits(DualLensShape, _Shape);\n  return _createClass(DualLensShape, [{\n    key: \"createPillPath\",\n    value: function createPillPath(centerY) {\n      var center = {\n        x: 0,\n        y: centerY\n      }; // Using 0 as center.x in viewBox\n\n      // Calculate control points for curves\n      var leftPoint = {\n        x: center.x - this.width / 2,\n        y: center.y\n      };\n      var rightPoint = {\n        x: center.x + this.width / 2,\n        y: center.y\n      };\n      var topControl1 = {\n        x: center.x - this.width / 4,\n        y: center.y - this.height / 2\n      };\n      var topControl2 = {\n        x: center.x + this.width / 4,\n        y: center.y - this.height / 2\n      };\n      var bottomControl1 = {\n        x: center.x + this.width / 4,\n        y: center.y + this.height / 2\n      };\n      var bottomControl2 = {\n        x: center.x - this.width / 4,\n        y: center.y + this.height / 2\n      };\n\n      // Create path using cubic Bzier curves\n      return \"M \".concat(leftPoint.x, \",\").concat(leftPoint.y, \"\\n                C \").concat(topControl1.x, \",\").concat(topControl1.y, \" \\n                  \").concat(topControl2.x, \",\").concat(topControl2.y, \" \\n                  \").concat(rightPoint.x, \",\").concat(rightPoint.y, \"\\n                C \").concat(bottomControl1.x, \",\").concat(bottomControl1.y, \" \\n                  \").concat(bottomControl2.x, \",\").concat(bottomControl2.y, \" \\n                  \").concat(leftPoint.x, \",\").concat(leftPoint.y);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate vertical positions for both pills\n      var topPillY = -this.spacing / 2 - this.height / 2;\n      var bottomPillY = this.spacing / 2 + this.height / 2;\n\n      // Create paths for both pills\n      var topPill = this.createPillPath(topPillY);\n      var bottomPill = this.createPillPath(bottomPillY);\n\n      // Return combined paths\n      return \"<path \\n            d=\\\"\".concat(topPill, \" \").concat(bottomPill, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(DualLensShape, \"parameters\", {\n  width: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  height: {\n    min: 50,\n    max: 150,\n    \"default\": 90\n  },\n  spacing: {\n    min: -50,\n    max: 50,\n    \"default\": 5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DualLensShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/DualLensShape.js?");

/***/ }),

/***/ "./src/shapes/EllipseGrid.js":
/*!***********************************!*\
  !*** ./src/shapes/EllipseGrid.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar EllipseGrid = /*#__PURE__*/function (_Shape) {\n  function EllipseGrid() {\n    _classCallCheck(this, EllipseGrid);\n    return _callSuper(this, EllipseGrid, arguments);\n  }\n  _inherits(EllipseGrid, _Shape);\n  return _createClass(EllipseGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var ellipses = [];\n      var baseSize = 150;\n      var cellWidth = baseSize / this.columns;\n      var cellHeight = baseSize / this.rows * this.heightRatio;\n      var startX = -baseSize / 2;\n      var startY = -(baseSize * this.heightRatio) / 2;\n\n      // Add minimum size check to prevent disappearing\n      var minSize = Math.max(this.thickness * 2, 1);\n\n      // Calculate ellipse dimensions with spacing and minimum size protection\n      var radiusX = Math.max(cellWidth / 2 * (1 - this.spacing), minSize);\n      var radiusY = Math.max(cellHeight / 2 * (1 - this.spacing), minSize);\n\n      // Convert skew to radians\n      var skewRad = this.skew * Math.PI / 180;\n      for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n          var centerX = startX + j * cellWidth + cellWidth / 2;\n          var centerY = startY + i * cellHeight + cellHeight / 2;\n\n          // Apply skew transformation matrix\n          var transform = \"matrix(1 0 \".concat(Math.tan(skewRad), \" 1 \").concat(centerX, \" \").concat(centerY, \")\");\n\n          // Only add ellipse if it has positive dimensions\n          if (radiusX > 0 && radiusY > 0) {\n            ellipses.push(\"<ellipse \\n                        rx=\\\"\".concat(radiusX, \"\\\" \\n                        ry=\\\"\").concat(radiusY, \"\\\"\\n                        fill=\\\"\").concat(this.mode === 'fill' ? 'white' : 'none', \"\\\"\\n                        stroke=\\\"white\\\"\\n                        stroke-width=\\\"\").concat(this.mode === 'stroke' ? this.thickness : 0, \"\\\"\\n                        transform=\\\"\").concat(transform, \"\\\"\\n                    />\"));\n          }\n        }\n      }\n      return ellipses.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(EllipseGrid, \"parameters\", {\n  skew: {\n    min: -45,\n    max: 45,\n    \"default\": 0\n  },\n  rows: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  columns: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  heightRatio: {\n    min: 0.2,\n    max: 2,\n    \"default\": 1\n  },\n  spacing: {\n    min: 0,\n    max: 0.5,\n    \"default\": 0.2\n  },\n  mode: {\n    options: ['fill', 'stroke'],\n    \"default\": 'fill'\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EllipseGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/EllipseGrid.js?");

/***/ }),

/***/ "./src/shapes/EllipsePacking.js":
/*!**************************************!*\
  !*** ./src/shapes/EllipsePacking.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar EllipsePacking = /*#__PURE__*/function (_Shape) {\n  function EllipsePacking() {\n    _classCallCheck(this, EllipsePacking);\n    return _callSuper(this, EllipsePacking, arguments);\n  }\n  _inherits(EllipsePacking, _Shape);\n  return _createClass(EllipsePacking, [{\n    key: \"generateSizes\",\n    value:\n    // Create a distribution of ellipse sizes with a bias toward a few larger ones\n    function generateSizes() {\n      // Create a distribution of sizes that favors a few large and several small\n      var sizes = [];\n\n      // First ellipse is large (30-100% of max size)\n      var firstSize = this.minRadius + (this.maxRadius - this.minRadius) * (0.3 + this.random() * 0.7);\n      sizes.push(firstSize);\n\n      // Second is medium-large (50-90% of first)\n      if (this.ellipseCount > 1) {\n        var secondSize = firstSize * (0.5 + this.random() * 0.4);\n        sizes.push(secondSize);\n      }\n\n      // Rest follow a power distribution (smaller ones more common)\n      for (var i = 2; i < this.ellipseCount; i++) {\n        var sizeFactor = Math.pow(this.random(), 1.5); // Power curve biases toward smaller values\n        var size = this.minRadius + (this.maxRadius * 0.6 - this.minRadius) * sizeFactor;\n        sizes.push(size);\n      }\n      return sizes.sort(function (a, b) {\n        return b - a;\n      }); // Sort largest to smallest\n    }\n\n    // Try to place an ellipse with balanced distribution\n  }, {\n    key: \"tryPlaceEllipse\",\n    value: function tryPlaceEllipse(placedEllipses, baseRadius, order) {\n      // Generate the ellipse dimensions\n      var ratio = this.minRatio + (this.maxRatio - this.minRatio) * this.random();\n      var rx = baseRadius;\n      var ry = baseRadius / ratio;\n\n      // Properly apply centerBias\n      // Lower values = more ellipses in center, higher values = more at edges\n      var distanceFromCenter;\n      var angle;\n      if (order === 0) {\n        // First ellipse (largest) - apply centerBias\n        // If centerBias is low, place closer to center\n        distanceFromCenter = this.containerRadius * 0.5 * this.centerBias * this.random();\n        angle = this.random() * 2 * Math.PI;\n      } else if (order === 1 && this.ellipseCount > 2) {\n        // Second ellipse - place with consideration for both centerBias and balance\n        var firstEllipse = placedEllipses[0];\n        var firstAngle = Math.atan2(firstEllipse.y, firstEllipse.x);\n        angle = firstAngle + Math.PI + (this.random() - 0.5) * Math.PI * 0.5;\n\n        // Apply centerBias - low values keep it closer to center\n        distanceFromCenter = this.containerRadius * (0.3 * this.centerBias + this.random() * 0.2);\n      } else {\n        // Golden angle for distribution\n        var goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~137.5 degrees\n\n        // Get the last placed ellipse's angle\n        var lastAngle = 0;\n        if (placedEllipses.length > 0) {\n          var lastEllipse = placedEllipses[placedEllipses.length - 1];\n          lastAngle = Math.atan2(lastEllipse.y, lastEllipse.x);\n        }\n\n        // Add golden angle plus some randomness\n        angle = lastAngle + goldenAngle + (this.random() - 0.5) * 0.5;\n\n        // Apply centerBias to distance calculation\n        // Lower centerBias = stay closer to center, higher = move more toward edge\n        var biasedRandom = Math.pow(this.random(), 1 - this.centerBias);\n        distanceFromCenter = this.containerRadius * biasedRandom * 0.7;\n      }\n      var x = distanceFromCenter * Math.cos(angle);\n      var y = distanceFromCenter * Math.sin(angle);\n\n      // Random rotation\n      var rotation = this.random() * 2 * Math.PI;\n\n      // Check for valid placement\n      if (this.isValidPlacement(placedEllipses, x, y, rx, ry, rotation)) {\n        return {\n          x: x,\n          y: y,\n          rx: rx,\n          ry: ry,\n          rotation: rotation\n        };\n      }\n      return null;\n    }\n\n    // Improved ellipse overlap detection\n  }, {\n    key: \"isValidPlacement\",\n    value: function isValidPlacement(placedEllipses, x, y, rx, ry, rotation) {\n      // Check container bounds - ensure ellipse is fully contained\n      // Use a simplified approach for checking if ellipse fits in container\n      var effectiveRadius = Math.max(rx, ry);\n      var distToCenter = Math.sqrt(x * x + y * y);\n      if (distToCenter + effectiveRadius > this.containerRadius) {\n        return false;\n      }\n\n      // Check overlap with other ellipses using improved spacing\n      var _iterator = _createForOfIteratorHelper(placedEllipses),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ellipse = _step.value;\n          var dx = ellipse.x - x;\n          var dy = ellipse.y - y;\n          var distanceBetweenCenters = Math.sqrt(dx * dx + dy * dy);\n\n          // Calculate required minimum distance:\n          // Sum of the semi-major axes of both ellipses, plus spacing\n          var ellipse1Max = Math.max(rx, ry);\n          var ellipse2Max = Math.max(ellipse.rx, ellipse.ry);\n          var minRequiredDistance = ellipse1Max + ellipse2Max + this.spacing;\n          if (distanceBetweenCenters < minRequiredDistance) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true;\n    }\n\n    // Generate all ellipse placements with balanced distribution\n  }, {\n    key: \"getEllipsePlacements\",\n    value: function getEllipsePlacements() {\n      // Reset RNG\n      this.resetRNG(this.seed);\n\n      // Generate size distribution\n      var sizes = this.generateSizes();\n      var ellipses = [];\n      var maxAttempts = 50;\n\n      // Place ellipses in order of size\n      for (var i = 0; i < sizes.length; i++) {\n        var placed = false;\n        for (var attempt = 0; attempt < maxAttempts && !placed; attempt++) {\n          var ellipse = this.tryPlaceEllipse(ellipses, sizes[i], i);\n          if (ellipse) {\n            ellipses.push(ellipse);\n            placed = true;\n          }\n        }\n\n        // If we couldn't place this one after many attempts, just skip it\n        if (!placed) {\n          continue;\n        }\n      }\n      return ellipses;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Generate new placements each time\n      var ellipses = this.getEllipsePlacements();\n      return this.renderShape(ellipses);\n    }\n  }, {\n    key: \"renderShape\",\n    value: function renderShape(ellipses) {\n      // Generate SVG with mask for the cut-out effect\n      var maskId = \"ellipse-mask-\".concat(Math.floor(Math.random() * 10000));\n\n      // Create ellipses as cut-outs (black to cut through the white circle)\n      var ellipsesElements = ellipses.map(function (ellipse) {\n        return \"<ellipse \\n                cx=\\\"\".concat(ellipse.x, \"\\\" \\n                cy=\\\"\").concat(ellipse.y, \"\\\" \\n                rx=\\\"\").concat(ellipse.rx, \"\\\" \\n                ry=\\\"\").concat(ellipse.ry, \"\\\"\\n                transform=\\\"rotate(\").concat(ellipse.rotation * (180 / Math.PI), \" \").concat(ellipse.x, \" \").concat(ellipse.y, \")\\\"\\n                fill=\\\"black\\\"\\n            />\");\n      });\n\n      // Use a mask to combine all elements\n      return \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <rect x=\\\"-\").concat(this.containerRadius * 2, \"\\\" y=\\\"-\").concat(this.containerRadius * 2, \"\\\" \\n                          width=\\\"\").concat(this.containerRadius * 4, \"\\\" height=\\\"\").concat(this.containerRadius * 4, \"\\\" \\n                          fill=\\\"white\\\" />\\n                    \").concat(ellipsesElements.join(''), \"\\n                </mask>\\n            </defs>\\n            <circle \\n                cx=\\\"0\\\" \\n                cy=\\\"0\\\" \\n                r=\\\"\").concat(this.containerRadius, \"\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(EllipsePacking, \"parameters\", {\n  containerRadius: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  ellipseCount: {\n    min: 3,\n    max: 30,\n    \"default\": 6\n  },\n  minRadius: {\n    min: 5,\n    max: 15,\n    \"default\": 5\n  },\n  maxRadius: {\n    min: 15,\n    max: 30,\n    \"default\": 40\n  },\n  minRatio: {\n    min: 0.3,\n    max: 1,\n    \"default\": 0.6\n  },\n  maxRatio: {\n    min: 1,\n    max: 2.5,\n    \"default\": 1.8\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 2\n  },\n  centerBias: {\n    min: 0,\n    max: 1,\n    \"default\": 0.4\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EllipsePacking);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/EllipsePacking.js?");

/***/ }),

/***/ "./src/shapes/EllipsesStackShape.js":
/*!******************************************!*\
  !*** ./src/shapes/EllipsesStackShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar EllipsesStackShape = /*#__PURE__*/function (_Shape) {\n  function EllipsesStackShape() {\n    _classCallCheck(this, EllipsesStackShape);\n    return _callSuper(this, EllipsesStackShape, arguments);\n  }\n  _inherits(EllipsesStackShape, _Shape);\n  return _createClass(EllipsesStackShape, [{\n    key: \"calculateHeights\",\n    value: function calculateHeights() {\n      var heights = new Array(this.count).fill(0);\n      var mid = (this.count - 1) / 2;\n      var heightDiff = this.maxHeight - this.minHeight;\n\n      // Calculate blend factor based on direction\n      var blendToCenterPeak = 1 - Math.min(1, Math.abs(this.direction) * 3);\n      for (var i = 0; i < this.count; i++) {\n        // Calculate center peak height\n        var distFromCenter = Math.abs(i - mid) / mid;\n        var centerPeakHeight = this.maxHeight - distFromCenter * heightDiff;\n\n        // Calculate directional height\n        var directionalProgress = this.direction > 0 ? i / (this.count - 1) : 1 - i / (this.count - 1);\n        var directionalHeight = this.minHeight + directionalProgress * heightDiff;\n\n        // Blend between the two patterns\n        heights[i] = centerPeakHeight * blendToCenterPeak + directionalHeight * (1 - blendToCenterPeak);\n      }\n      return heights;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var heights = this.calculateHeights();\n\n      // Calculate total pattern dimensions\n      var totalHeight = (this.count - 1) * this.spacing + heights.reduce(function (sum, height) {\n        return sum + height;\n      }, 0);\n      var boundSize = 200;\n      var scaleX = boundSize / this.width;\n      var scaleY = boundSize / totalHeight;\n      var scale = Math.min(scaleX, scaleY) * 0.8; // 80% of available space for margin\n\n      // Scale dimensions\n      var scaledWidth = this.width * scale;\n      var scaledSpacing = this.spacing * scale;\n      var scaledHeights = heights.map(function (h) {\n        return h * scale;\n      });\n\n      // Calculate start position to center the shape\n      var scaledTotalHeight = (this.count - 1) * scaledSpacing + scaledHeights.reduce(function (sum, height) {\n        return sum + height;\n      }, 0);\n      var startX = -scaledWidth / 2; // Center horizontally\n      var startY = -scaledTotalHeight / 2; // Center vertically\n\n      // Generate ellipses\n      var currentY = startY;\n      var ellipses = [];\n      for (var i = 0; i < scaledHeights.length; i++) {\n        var height = scaledHeights[i];\n        ellipses.push(\"<ellipse\\n                cx=\\\"\".concat(startX + scaledWidth / 2, \"\\\"\\n                cy=\\\"\").concat(currentY + height / 2, \"\\\"\\n                rx=\\\"\").concat(scaledWidth / 2, \"\\\"\\n                ry=\\\"\").concat(height / 2, \"\\\"\\n                fill=\\\"white\\\"\\n            />\"));\n        currentY += height + scaledSpacing;\n      }\n      return ellipses.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(EllipsesStackShape, \"parameters\", {\n  count: {\n    min: 2,\n    max: 12,\n    \"default\": 5\n  },\n  spacing: {\n    min: 5,\n    max: 50,\n    \"default\": 24\n  },\n  width: {\n    min: 100,\n    max: 300,\n    \"default\": 169\n  },\n  direction: {\n    min: -0.5,\n    max: 0.5,\n    \"default\": 0.5\n  },\n  minHeight: {\n    min: 2,\n    max: 20,\n    \"default\": 9\n  },\n  maxHeight: {\n    min: 20,\n    max: 80,\n    \"default\": 80\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EllipsesStackShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/EllipsesStackShape.js?");

/***/ }),

/***/ "./src/shapes/ExpandArrowsShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/ExpandArrowsShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ExpandArrowsShape = /*#__PURE__*/function (_Shape) {\n  function ExpandArrowsShape() {\n    _classCallCheck(this, ExpandArrowsShape);\n    return _callSuper(this, ExpandArrowsShape, arguments);\n  }\n  _inherits(ExpandArrowsShape, _Shape);\n  return _createClass(ExpandArrowsShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var halfSize = this.size / 2;\n      var cl = this.cornerLength; // Corner length\n      var elements = [];\n\n      // Top left corner\n      elements.push(\"<path\\n            d=\\\"M \".concat(-halfSize, \" \").concat(-halfSize + cl, \" L \").concat(-halfSize, \" \").concat(-halfSize, \" L \").concat(-halfSize + cl, \" \").concat(-halfSize, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linejoin=\\\"miter\\\"\\n        />\"));\n\n      // Top right corner\n      elements.push(\"<path\\n            d=\\\"M \".concat(halfSize - cl, \" \").concat(-halfSize, \" L \").concat(halfSize, \" \").concat(-halfSize, \" L \").concat(halfSize, \" \").concat(-halfSize + cl, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linejoin=\\\"miter\\\"\\n        />\"));\n\n      // Bottom right corner\n      elements.push(\"<path\\n            d=\\\"M \".concat(halfSize, \" \").concat(halfSize - cl, \" L \").concat(halfSize, \" \").concat(halfSize, \" L \").concat(halfSize - cl, \" \").concat(halfSize, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linejoin=\\\"miter\\\"\\n        />\"));\n\n      // Bottom left corner\n      elements.push(\"<path\\n            d=\\\"M \".concat(-halfSize + cl, \" \").concat(halfSize, \" L \").concat(-halfSize, \" \").concat(halfSize, \" L \").concat(-halfSize, \" \").concat(halfSize - cl, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linejoin=\\\"miter\\\"\\n        />\"));\n\n      // Diagonal X in the middle\n      elements.push(\"<path\\n            d=\\\"M \".concat(-halfSize, \" \").concat(-halfSize, \" L \").concat(halfSize, \" \").concat(halfSize, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      elements.push(\"<path\\n            d=\\\"M \".concat(halfSize, \" \").concat(-halfSize, \" L \").concat(-halfSize, \" \").concat(halfSize, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ExpandArrowsShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  // Overall size of the shape\n  cornerLength: {\n    min: 20,\n    max: 80,\n    \"default\": 40\n  },\n  // Length of corner sections\n  thickness: {\n    min: 1,\n    max: 20,\n    \"default\": 10\n  } // Line thickness\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExpandArrowsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ExpandArrowsShape.js?");

/***/ }),

/***/ "./src/shapes/EyeShape.js":
/*!********************************!*\
  !*** ./src/shapes/EyeShape.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar EyeShape = /*#__PURE__*/function (_Shape) {\n  function EyeShape() {\n    _classCallCheck(this, EyeShape);\n    return _callSuper(this, EyeShape, arguments);\n  }\n  _inherits(EyeShape, _Shape);\n  return _createClass(EyeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = Math.min(400, 400) / 400;\n      var width = this.width * scale;\n      var height = this.height * scale;\n      var halfWidth = width / 2;\n      var halfHeight = height / 2;\n      var innerWidth = width * this.openness;\n      var innerHalfWidth = innerWidth / 2;\n      var innerHeight = height * this.openness;\n      var outerPath = \"M \".concat(-halfWidth, \" 0 \\n           Q 0 \").concat(-halfHeight, \" \").concat(halfWidth, \" 0\\n           Q 0 \").concat(halfHeight, \" \").concat(-halfWidth, \" 0\");\n      var innerPath = \"M \".concat(-innerHalfWidth, \" 0\\n           Q 0 \").concat(-innerHeight / 2, \" \").concat(innerHalfWidth, \" 0\\n           Q 0 \").concat(innerHeight / 2, \" \").concat(-innerHalfWidth, \" 0\");\n      return \"<path d=\\\"\".concat(outerPath, \"\\\" fill=\\\"white\\\" />\\n               <path d=\\\"\").concat(innerPath, \"\\\" fill=\\\"black\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(EyeShape, \"parameters\", {\n  width: {\n    min: 50,\n    max: 150,\n    \"default\": 150\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  openness: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EyeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/EyeShape.js?");

/***/ }),

/***/ "./src/shapes/FingerprintShape.js":
/*!****************************************!*\
  !*** ./src/shapes/FingerprintShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar FingerprintShape = /*#__PURE__*/function (_Shape) {\n  function FingerprintShape() {\n    _classCallCheck(this, FingerprintShape);\n    return _callSuper(this, FingerprintShape, arguments);\n  }\n  _inherits(FingerprintShape, _Shape);\n  return _createClass(FingerprintShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var maxRadius = this.radius;\n\n      // Define a unique ID for the clip path\n      var clipPathId = \"fingerprint-clip-\".concat(Date.now());\n\n      // Create a clip path to contain everything within a circle\n      elements.push(\"\\n            <defs>\\n                <clipPath id=\\\"\".concat(clipPathId, \"\\\">\\n                    <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(maxRadius, \"\\\" />\\n                </clipPath>\\n            </defs>\\n        \"));\n\n      // Start a group with the clip path applied\n      elements.push(\"<g clip-path=\\\"url(#\".concat(clipPathId, \")\\\">\"));\n\n      // Calculate adaptive gap based on radius and lineCount\n      var adaptiveGap = maxRadius / this.lineCount;\n\n      // Create each arc and its vertical lines\n      for (var i = 0; i < this.lineCount; i++) {\n        var currentRadius = maxRadius - i * adaptiveGap;\n        if (currentRadius <= 0) continue;\n\n        // Add the semicircular arc at top\n        elements.push(\"\\n                <path\\n                    d=\\\"M \".concat(-currentRadius, \",0 \\n                       A \").concat(currentRadius, \" \").concat(currentRadius, \" 0 0 1 \").concat(currentRadius, \",0\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    fill=\\\"none\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\\n            \"));\n\n        // Add vertical lines extending past the bottom of the circle\n        // (they'll be clipped by the clipPath)\n        elements.push(\"\\n                <line\\n                    x1=\\\"\".concat(-currentRadius, \"\\\"\\n                    y1=\\\"0\\\"\\n                    x2=\\\"\").concat(-currentRadius, \"\\\"\\n                    y2=\\\"\").concat(maxRadius * 2, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\\n            \"));\n        elements.push(\"\\n                <line\\n                    x1=\\\"\".concat(currentRadius, \"\\\"\\n                    y1=\\\"0\\\"\\n                    x2=\\\"\").concat(currentRadius, \"\\\"\\n                    y2=\\\"\").concat(maxRadius * 2, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\\n            \"));\n      }\n\n      // Add center line\n      elements.push(\"\\n            <line\\n                x1=\\\"0\\\"\\n                y1=\\\"0\\\"\\n                x2=\\\"0\\\"\\n                y2=\\\"\".concat(maxRadius * 2, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n            />\\n        \"));\n\n      // Close the group\n      elements.push(\"</g>\");\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FingerprintShape, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  lineCount: {\n    min: 3,\n    max: 8,\n    \"default\": 5\n  },\n  strokeWidth: {\n    min: 1,\n    max: 20,\n    \"default\": 10\n  },\n  gap: {\n    min: 5,\n    max: 30,\n    \"default\": 18\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FingerprintShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FingerprintShape.js?");

/***/ }),

/***/ "./src/shapes/FlatWave.js":
/*!********************************!*\
  !*** ./src/shapes/FlatWave.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar FlatWave = /*#__PURE__*/function (_Shape) {\n  function FlatWave() {\n    _classCallCheck(this, FlatWave);\n    return _callSuper(this, FlatWave, arguments);\n  }\n  _inherits(FlatWave, _Shape);\n  return _createClass(FlatWave, [{\n    key: \"getWaveValue\",\n    value: function getWaveValue(t, type) {\n      // Normalize t to [0, 1] range\n      t = (t % 1 + 1) % 1;\n\n      // Apply balance (horizontal shift)\n      t = t + this.balance * 0.2;\n      t = (t % 1 + 1) % 1;\n\n      // Apply pinch effect\n      if (this.pinch > 0) {\n        var pinchFactor = 1 + this.pinch * 2;\n        t = Math.pow(t, pinchFactor) / Math.pow(1, pinchFactor - 1);\n      }\n      var value = 0;\n      switch (type) {\n        case 'sine':\n          value = Math.sin(t * Math.PI * 2);\n          break;\n        case 'smooth':\n          {\n            // Pure mathematical smooth curve\n            var baseWave = Math.sin(t * Math.PI * 2);\n            var tension = 0.5 + this.tension * 1.5;\n            var modulator = Math.pow(Math.abs(Math.sin(t * Math.PI)), tension);\n            value = baseWave * (1 + modulator * 0.5);\n            break;\n          }\n        case 'sharp':\n          {\n            // Sharp peaks with curve control\n            var sharpness = 1 + this.curve * 4;\n            value = Math.pow(Math.sin(t * Math.PI * 2), sharpness);\n            break;\n          }\n        case 'bounce':\n          {\n            // Bouncy wave with variable curve\n            var bounciness = 1 + this.curve * 3;\n            value = Math.sin(t * Math.PI * 2) * (1 - Math.pow(Math.sin(t * Math.PI), bounciness));\n            break;\n          }\n        case 'clean':\n          {\n            // Clean wave with minimal distortion\n            var cleanness = 0.5 + this.tension * 0.5;\n            value = Math.sin(t * Math.PI * 2) * Math.pow(Math.sin(t * Math.PI), cleanness);\n            break;\n          }\n        case 'fluid':\n          {\n            // Fluid wave with variable smoothness\n            var fluidity = 1 + this.curve * 2;\n            var base = Math.sin(t * Math.PI * 2);\n            var mod = Math.sin(t * Math.PI * 4);\n            value = base * (1 - mod * mod * this.tension);\n            break;\n          }\n        default:\n          value = Math.sin(t * Math.PI * 2);\n      }\n\n      // Apply curve transformation\n      if (this.curve > 0) {\n        var sign = Math.sign(value);\n        value = sign * Math.pow(Math.abs(value), 1 - this.curve * 0.5);\n      }\n      return value;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var width = 120;\n      var steps = 400; // Increased resolution for smoother curves\n      var phaseRad = this.phase * Math.PI / 180;\n      var points = [];\n\n      // Generate top wave points\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps;\n        var x = -width / 2 + width * t;\n\n        // Calculate wave value\n        var waveT = t * this.frequency + phaseRad / (Math.PI * 2);\n        var y = this.getWaveValue(waveT, this.waveform);\n        y *= this.amplitude;\n        points.push([x, y]);\n      }\n\n      // Generate path\n      var d = \"M \".concat(-width / 2, \" 0\"); // Start at bottom left\n\n      // Add top wave points with smooth curve\n      for (var _i = 0; _i < points.length; _i++) {\n        var curr = points[_i];\n        var prev = points[Math.max(0, _i - 1)];\n        if (_i === 0) {\n          d += \" L \".concat(curr[0], \" \").concat(curr[1]);\n        } else {\n          var cp1x = prev[0] + (curr[0] - prev[0]) / 3;\n          var cp2x = curr[0] - (curr[0] - prev[0]) / 3;\n          d += \" C \".concat(cp1x, \" \").concat(prev[1], \" \").concat(cp2x, \" \").concat(curr[1], \" \").concat(curr[0], \" \").concat(curr[1]);\n        }\n      }\n\n      // Complete the path\n      d += \" L \".concat(width / 2, \" 0 Z\");\n      return \"<path \\n            d=\\\"\".concat(d, \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"none\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FlatWave, \"parameters\", {\n  amplitude: {\n    min: 10,\n    max: 150,\n    \"default\": 50\n  },\n  frequency: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  waveform: {\n    options: ['sine', 'smooth', 'sharp', 'bounce', 'clean', 'fluid'],\n    \"default\": 'sine'\n  },\n  curve: {\n    min: 0,\n    max: 1,\n    \"default\": 0.5\n  },\n  pinch: {\n    min: 0,\n    max: 1,\n    \"default\": 0\n  },\n  balance: {\n    min: -1,\n    max: 1,\n    \"default\": 0\n  },\n  tension: {\n    min: 0,\n    max: 1,\n    \"default\": 0.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FlatWave);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FlatWave.js?");

/***/ }),

/***/ "./src/shapes/FloralSprayShape.js":
/*!****************************************!*\
  !*** ./src/shapes/FloralSprayShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar FloralSprayShape = /*#__PURE__*/function (_Shape) {\n  function FloralSprayShape() {\n    _classCallCheck(this, FloralSprayShape);\n    return _callSuper(this, FloralSprayShape, arguments);\n  }\n  _inherits(FloralSprayShape, _Shape);\n  return _createClass(FloralSprayShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate stem\n      this.branchCount = Math.round(this.branchCount);\n      var stemHeight = this.branchLength * 0.25;\n      var verticalOffset = +this.branchLength * 0.4;\n      var stemStartY = stemHeight * 0.6 + verticalOffset;\n      var stemStart = {\n        x: 0,\n        y: stemStartY\n      };\n      var stemEnd = {\n        x: 0,\n        y: verticalOffset\n      };\n      var stemCP1 = {\n        x: stemStart.x,\n        y: stemStart.y - stemHeight * 0.3\n      };\n      var stemCP2 = {\n        x: stemEnd.x,\n        y: stemEnd.y + stemHeight * 0.1\n      };\n\n      // Generate stem path\n      var stem = \"M \".concat(stemStart.x, \" \").concat(stemStart.y, \" \\n                     C \").concat(stemCP1.x, \" \").concat(stemCP1.y, \", \\n                       \").concat(stemCP2.x, \" \").concat(stemCP2.y, \", \\n                       \").concat(stemEnd.x, \" \").concat(stemEnd.y);\n\n      // Generate branches\n      var branches = [];\n      if (this.branchCount > 0) {\n        var spreadRad = this.spread * Math.PI / 180.0;\n        var startAngle = -Math.PI / 2 - spreadRad / 2;\n        for (var i = 0; i < this.branchCount; i++) {\n          var progress = i / Math.max(1, this.branchCount - 1);\n          var angle = startAngle + progress * spreadRad;\n\n          // Calculate length with tapering at edges\n          var edgeFactor = 1.0 - Math.pow(2 * (progress - 0.5), 2) * 0.15;\n          var thisLength = this.branchLength * edgeFactor;\n\n          // Adjust bulb size based on position\n          var bulbFactor = 1.0 - Math.pow(2 * (progress - 0.5), 2) * 0.2;\n          var thisBulbSize = this.bulbSize * bulbFactor;\n          var branch = this.createBranch(stemEnd, angle, thisLength, this.thickness * (0.9 + edgeFactor * 0.1), thisBulbSize);\n          branches.push(branch);\n        }\n      }\n      return \"\\n            <g>\\n                <path \\n                    d=\\\"\".concat(stem, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness * 2.5, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                    stroke-linejoin=\\\"round\\\"\\n                    fill=\\\"none\\\"\\n                />\\n                \").concat(branches.join('\\n'), \"\\n            </g>\\n        \");\n    }\n  }, {\n    key: \"createBranch\",\n    value: function createBranch(start, angle, length, thickness, bulbSize) {\n      // Calculate end point\n      var end = {\n        x: start.x + length * Math.cos(angle),\n        y: start.y + length * Math.sin(angle)\n      };\n\n      // Create control points for smooth curve\n      var cp1 = {\n        x: start.x + length * 0.35 * Math.cos(angle),\n        y: start.y + length * 0.35 * Math.sin(angle)\n      };\n      var cp2 = {\n        x: start.x + length * 0.65 * Math.cos(angle),\n        y: start.y + length * 0.65 * Math.sin(angle)\n      };\n\n      // Create branch and bulb paths\n      var branchPath = \"M \".concat(start.x, \" \").concat(start.y, \" \\n                           C \").concat(cp1.x, \" \").concat(cp1.y, \", \\n                             \").concat(cp2.x, \" \").concat(cp2.y, \", \\n                             \").concat(end.x, \" \").concat(end.y);\n      return \"\\n            <path \\n                d=\\\"\".concat(branchPath, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n                fill=\\\"none\\\"\\n            />\\n            <circle \\n                cx=\\\"\").concat(end.x, \"\\\"\\n                cy=\\\"\").concat(end.y, \"\\\"\\n                r=\\\"\").concat(bulbSize, \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FloralSprayShape, \"parameters\", {\n  branchLength: {\n    min: 40,\n    max: 150,\n    \"default\": 80\n  },\n  branchCount: {\n    min: 3,\n    max: 8,\n    \"default\": 5\n  },\n  thickness: {\n    min: 2,\n    max: 12,\n    \"default\": 6\n  },\n  spread: {\n    min: 30,\n    max: 120,\n    \"default\": 75\n  },\n  bulbSize: {\n    min: 5,\n    max: 25,\n    \"default\": 15\n  }\n});\nwindow.Shape = FloralSprayShape;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FloralSprayShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FloralSprayShape.js?");

/***/ }),

/***/ "./src/shapes/FlowField.js":
/*!*********************************!*\
  !*** ./src/shapes/FlowField.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar FlowField = /*#__PURE__*/function (_Shape) {\n  function FlowField() {\n    _classCallCheck(this, FlowField);\n    return _callSuper(this, FlowField, arguments);\n  }\n  _inherits(FlowField, _Shape);\n  return _createClass(FlowField, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var size = 200; // Fixed 200x200 size\n      var elements = [];\n\n      // Calculate the actual width based on horizontal scale\n      var width = size * this.horizontalScale;\n\n      // Calculate spacing for lines\n      var lineSpacing = size / (this.lineCount + 1);\n\n      // Generate each flow curve\n      var allPaths = [];\n      for (var i = 0; i < this.lineCount; i++) {\n        // Y position of current line\n        var y = -size / 2 + lineSpacing * (i + 1);\n\n        // Alternate curve direction for each line\n        var isEven = i % 2 === 0;\n\n        // Generate clean, precise S-curve\n        var path = this.createPreciseCurve(y, width, isEven);\n        allPaths.push(path);\n      }\n\n      // Combine all paths into a single white filled shape\n      elements.push(\"<path d=\\\"\".concat(allPaths.join(' '), \"\\\" fill=\\\"white\\\" />\"));\n      return elements.join('');\n    }\n  }, {\n    key: \"createPreciseCurve\",\n    value: function createPreciseCurve(centerY, width, isEven) {\n      // Calculate dimensions\n      var halfWidth = width / 2;\n      var halfThickness = this.thickness / 2;\n\n      // Calculate curve control point offset based on curve amount\n      var curveOffset = halfWidth * this.curveAmount;\n\n      // The direction of the curve depends on whether the line is even or odd\n      var direction = isEven ? 1 : -1;\n\n      // Start with top-left corner\n      var path = \"M \".concat(-halfWidth, \",\").concat(centerY - halfThickness);\n\n      // Create the top curved edge with precise control points\n      path += \" C \".concat(-halfWidth / 3, \",\").concat(centerY - halfThickness - direction * curveOffset);\n      path += \" \".concat(halfWidth / 3, \",\").concat(centerY - halfThickness + direction * curveOffset);\n      path += \" \".concat(halfWidth, \",\").concat(centerY - halfThickness);\n\n      // Connect to top-right to bottom-right\n      path += \" L \".concat(halfWidth, \",\").concat(centerY + halfThickness);\n\n      // Create the bottom curved edge (reversed)\n      path += \" C \".concat(halfWidth / 3, \",\").concat(centerY + halfThickness + direction * curveOffset);\n      path += \" \".concat(-halfWidth / 3, \",\").concat(centerY + halfThickness - direction * curveOffset);\n      path += \" \".concat(-halfWidth, \",\").concat(centerY + halfThickness);\n\n      // Close the path\n      path += \" Z\";\n      return path;\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FlowField, \"parameters\", {\n  lineCount: {\n    min: 2,\n    max: 5,\n    \"default\": 3\n  },\n  thickness: {\n    min: 15,\n    max: 35,\n    \"default\": 25\n  },\n  curveAmount: {\n    min: 0.2,\n    max: 0.6,\n    \"default\": 0.4\n  },\n  horizontalScale: {\n    min: 0.6,\n    max: 0.9,\n    \"default\": 0.85\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FlowField);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FlowField.js?");

/***/ }),

/***/ "./src/shapes/FlowFieldShape.js":
/*!**************************************!*\
  !*** ./src/shapes/FlowFieldShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar FlowFieldShape = /*#__PURE__*/function (_Shape) {\n  function FlowFieldShape() {\n    _classCallCheck(this, FlowFieldShape);\n    return _callSuper(this, FlowFieldShape, arguments);\n  }\n  _inherits(FlowFieldShape, _Shape);\n  return _createClass(FlowFieldShape, [{\n    key: \"getGridPoints\",\n    value: function getGridPoints() {\n      var points = [];\n      var cellSize = this.fieldSize / this.gridSize;\n      for (var row = 0; row <= this.gridSize; row++) {\n        for (var col = 0; col <= this.gridSize; col++) {\n          var x = -this.fieldSize / 2 + col * cellSize;\n          var y = -this.fieldSize / 2 + row * cellSize;\n          points.push({\n            x: x,\n            y: y\n          });\n        }\n      }\n      return points;\n    }\n  }, {\n    key: \"calculateFlowVectors\",\n    value: function calculateFlowVectors(points) {\n      var vectors = [];\n      for (var i = 0; i < points.length; i++) {\n        var p = points[i];\n        var xNoise = Math.sin((p.x + this.seed) * 0.01 + this.noiseScale);\n        var yNoise = Math.cos((p.y + this.seed) * 0.01 + this.noiseScale);\n        if (i > 0) {\n          var prevPoint = points[i - 1];\n          xNoise += Math.sin((prevPoint.x + this.seed) * 0.01 + this.noiseScale);\n          yNoise += Math.cos((prevPoint.y + this.seed) * 0.01 + this.noiseScale);\n        }\n        var angle = Math.atan2(yNoise, xNoise) + Math.PI / 4;\n        var vector = {\n          x: Math.cos(angle) * this.flowStrength,\n          y: Math.sin(angle) * this.flowStrength\n        };\n        vectors.push(vector);\n      }\n      return vectors;\n    }\n  }, {\n    key: \"createParticleLines\",\n    value: function createParticleLines(points, vectors) {\n      var lines = [];\n      var cellSize = this.fieldSize / this.gridSize;\n      for (var i = 0; i < points.length; i++) {\n        var p = points[i];\n        var v = vectors[i];\n\n        // Calculate particle positions based on flow vectors\n        var particles = [];\n        for (var step = 0; step <= this.gridSize; step++) {\n          var t = step / this.gridSize;\n          var px = p.x + v.x * t * cellSize;\n          var py = p.y + v.y * t * cellSize;\n          particles.push({\n            x: px,\n            y: py\n          });\n        }\n\n        // Create lines connecting particles\n        var color = 'white';\n        for (var j = 0; j < particles.length - 1; j++) {\n          var angle = i / this.gridSize * Math.PI * 2;\n          var hue = angle / (Math.PI * 2) * 360;\n          color = \"hsl(\".concat(hue, \", 80%, 60%)\");\n          lines.push(\"<line \\n                    x1=\\\"\".concat(particles[j].x, \"\\\" \\n                    y1=\\\"\").concat(particles[j].y, \"\\\" \\n                    x2=\\\"\").concat(particles[j + 1].x, \"\\\" \\n                    y2=\\\"\").concat(particles[j + 1].y, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"2\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\"));\n        }\n      }\n      return lines.join('');\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.flowStrength = 1.0;\n      var points = this.getGridPoints();\n      var vectors = this.calculateFlowVectors(points);\n      var particleLines = this.createParticleLines(points, vectors);\n      return \"<g>\\n            \".concat(particleLines, \"\\n        </g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FlowFieldShape, \"parameters\", {\n  fieldSize: {\n    min: 60,\n    max: 150,\n    \"default\": 150\n  },\n  gridSize: {\n    min: 4,\n    max: 16,\n    \"default\": 16\n  },\n  // Number of grid cells\n  noiseScale: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  // Scale of noise field\n  seed: {\n    min: 0,\n    max: 1000,\n    \"default\": 123\n  } // Seed for consistent random generation\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FlowFieldShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FlowFieldShape.js?");

/***/ }),

/***/ "./src/shapes/FlowerMandala.js":
/*!*************************************!*\
  !*** ./src/shapes/FlowerMandala.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar FlowerMandala = /*#__PURE__*/function (_Shape) {\n  function FlowerMandala() {\n    _classCallCheck(this, FlowerMandala);\n    return _callSuper(this, FlowerMandala, arguments);\n  }\n  _inherits(FlowerMandala, _Shape);\n  return _createClass(FlowerMandala, [{\n    key: \"generatePetalPath\",\n    value: function generatePetalPath(centerX, centerY, innerRadius, outerRadius, startAngle, endAngle) {\n      var midAngle = (startAngle + endAngle) / 2;\n      var controlDistance = (outerRadius - innerRadius) * 0;\n\n      // Calculate points\n      var innerX = centerX + innerRadius * Math.cos(startAngle);\n      var innerY = centerY + innerRadius * Math.sin(startAngle);\n      var outerX = centerX + outerRadius * Math.cos(midAngle);\n      var outerY = centerY + outerRadius * Math.sin(midAngle);\n      var endX = centerX + innerRadius * Math.cos(endAngle);\n      var endY = centerY + innerRadius * Math.sin(endAngle);\n\n      // Calculate control points\n      var controlX1 = innerX + controlDistance * Math.cos(midAngle);\n      var controlY1 = innerY + controlDistance * Math.sin(midAngle);\n      var controlX2 = outerX - controlDistance * Math.cos(midAngle);\n      var controlY2 = outerY - controlDistance * Math.sin(midAngle);\n      return \"M \".concat(innerX, \" \").concat(innerY, \"\\n                Q \").concat(controlX1, \" \").concat(controlY1, \" \").concat(outerX, \" \").concat(outerY, \"\\n                Q \").concat(controlX2, \" \").concat(controlY2, \" \").concat(endX, \" \").concat(endY);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var baseRotation = Math.PI / 180;\n      this.petals = Math.round(this.petals);\n\n      // Generate each layer\n      for (var layer = 0; layer < this.layers; layer++) {\n        var layerInnerRadius = this.innerRadius + layer * (this.outerRadius - this.innerRadius) / this.layers;\n        var layerOuterRadius = layerInnerRadius + (this.outerRadius - this.innerRadius) / this.layers;\n\n        // Calculate petal angles for this layer\n        var angleStep = 2 * Math.PI / this.petals;\n        var layerRotation = baseRotation + layer * Math.PI / this.petals;\n\n        // Generate petals for this layer\n        for (var i = 0; i < this.petals; i++) {\n          var startAngle = i * angleStep + layerRotation;\n          var endAngle = startAngle + angleStep;\n          var petalPath = this.generatePetalPath(0, 0, layerInnerRadius, layerOuterRadius, startAngle, endAngle);\n          paths.push(\"<path d=\\\"\".concat(petalPath, \"\\\" fill=\\\"white\\\"/>\"));\n        }\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FlowerMandala, \"parameters\", {\n  petals: {\n    min: 5,\n    max: 24,\n    \"default\": 12\n  },\n  layers: {\n    min: 2,\n    max: 6,\n    \"default\": 4\n  },\n  innerRadius: {\n    min: 10,\n    max: 80,\n    \"default\": 30\n  },\n  outerRadius: {\n    min: 50,\n    max: 150,\n    \"default\": 100\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FlowerMandala);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FlowerMandala.js?");

/***/ }),

/***/ "./src/shapes/FlowerPetalsShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/FlowerPetalsShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar FlowerPetalsShape = /*#__PURE__*/function (_Shape) {\n  function FlowerPetalsShape() {\n    _classCallCheck(this, FlowerPetalsShape);\n    return _callSuper(this, FlowerPetalsShape, arguments);\n  }\n  _inherits(FlowerPetalsShape, _Shape);\n  return _createClass(FlowerPetalsShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var petals = [];\n\n      // Create four petals\n      for (var i = 0; i < 4; i++) {\n        var angle = i * Math.PI / 2;\n        var startPoint = {\n          x: this.centerGap * Math.cos(angle),\n          y: this.centerGap * Math.sin(angle)\n        };\n        var endPoint = {\n          x: this.petalSize * Math.cos(angle),\n          y: this.petalSize * Math.sin(angle)\n        };\n        var controlPoint1 = {\n          x: startPoint.x + this.petalSize * this.petalCurve * Math.cos(angle + Math.PI / 2 * this.petalWidth),\n          y: startPoint.y + this.petalSize * this.petalCurve * Math.sin(angle + Math.PI / 2 * this.petalWidth)\n        };\n        var controlPoint2 = {\n          x: startPoint.x + this.petalSize * this.petalCurve * Math.cos(angle - Math.PI / 2 * this.petalWidth),\n          y: startPoint.y + this.petalSize * this.petalCurve * Math.sin(angle - Math.PI / 2 * this.petalWidth)\n        };\n\n        // Create petal path using quadratic Bzier curves\n        var petalPath = \"\\n                M \".concat(startPoint.x, \" \").concat(startPoint.y, \"\\n                Q \").concat(controlPoint1.x, \" \").concat(controlPoint1.y, \", \").concat(endPoint.x, \" \").concat(endPoint.y, \"\\n                Q \").concat(controlPoint2.x, \" \").concat(controlPoint2.y, \", \").concat(startPoint.x, \" \").concat(startPoint.y, \"\\n            \");\n        petals.push(petalPath);\n      }\n      return \"\\n            <path \\n                d=\\\"\".concat(petals.join(' '), \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FlowerPetalsShape, \"parameters\", {\n  petalSize: {\n    min: 50,\n    max: 100,\n    \"default\": 80\n  },\n  petalWidth: {\n    min: 0.2,\n    max: 1.0,\n    \"default\": 0.5\n  },\n  centerGap: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  },\n  petalCurve: {\n    min: 0.1,\n    max: 2.0,\n    \"default\": 0.8\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FlowerPetalsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FlowerPetalsShape.js?");

/***/ }),

/***/ "./src/shapes/FractalFlowerShape.js":
/*!******************************************!*\
  !*** ./src/shapes/FractalFlowerShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar FractalFlowerShape = /*#__PURE__*/function (_Shape) {\n  function FractalFlowerShape() {\n    _classCallCheck(this, FractalFlowerShape);\n    return _callSuper(this, FractalFlowerShape, arguments);\n  }\n  _inherits(FractalFlowerShape, _Shape);\n  return _createClass(FractalFlowerShape, [{\n    key: \"drawFrostBranch\",\n    value: function drawFrostBranch(start, angle, length, depth, spread, complexity, maxRadius) {\n      var _this = this;\n      var paths = [];\n\n      // Calculate end point\n      var startToCenter = Math.hypot(start.x - start.x, start.y - start.y);\n      var remainingRadius = maxRadius - startToCenter;\n      var currentLength = Math.min(length, remainingRadius);\n      var end = {\n        x: start.x + currentLength * Math.cos(angle),\n        y: start.y + currentLength * Math.sin(angle)\n      };\n\n      // Draw main branch\n      paths.push(\"M \".concat(start.x, \",\").concat(start.y, \" L \").concat(end.x, \",\").concat(end.y));\n      if (depth > 0) {\n        // Calculate sub-branch properties\n        var subLength = currentLength * (0.6 - complexity * 0.2);\n        var spreadRad = spread * Math.PI / 180.0 * (1.0 - depth * 0.1);\n\n        // Draw sub-branches\n        [-spreadRad, spreadRad].forEach(function (subAngle) {\n          var subPaths = _this.drawFrostBranch(end, angle + subAngle, subLength, depth - 1, spread, complexity, maxRadius);\n          paths.push.apply(paths, _toConsumableArray(subPaths));\n        });\n\n        // Add crystal details\n        var crystalSize = currentLength * 0.15 * (1.0 + complexity * 0.5);\n        var crystalPoints = [];\n        for (var i = 0; i < 4; i++) {\n          var pointAngle = angle + i * Math.PI / 2;\n          crystalPoints.push(\"\".concat(end.x + crystalSize * Math.cos(pointAngle), \",\").concat(end.y + crystalSize * Math.sin(pointAngle)));\n        }\n        paths.push(\"M \".concat(crystalPoints[0], \" L \").concat(crystalPoints[1], \" L \").concat(crystalPoints[2], \" L \").concat(crystalPoints[3], \" Z\"));\n      }\n      return paths;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var maxSize = 200;\n      var scale = maxSize / 400;\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var maxRadius = maxSize * 0.45;\n      var baseLength = Math.min(this.crystalSize * scale, maxRadius);\n      var paths = [];\n\n      // Generate evenly distributed branches\n      for (var branch = 0; branch < this.branches; branch++) {\n        var baseAngle = branch * 2 * Math.PI / this.branches;\n        var branchPaths = this.drawFrostBranch(center, baseAngle, baseLength, this.depth, this.spread, this.complexity, maxRadius);\n        paths.push.apply(paths, _toConsumableArray(branchPaths));\n      }\n      return \"<path \\n            d=\\\"\".concat(paths.join(' '), \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FractalFlowerShape, \"parameters\", {\n  branches: {\n    min: 4,\n    max: 12,\n    \"default\": 6\n  },\n  depth: {\n    min: 2,\n    max: 7,\n    \"default\": 4\n  },\n  spread: {\n    min: 15,\n    max: 60,\n    \"default\": 30\n  },\n  crystalSize: {\n    min: 40,\n    max: 120,\n    \"default\": 80\n  },\n  complexity: {\n    min: 0,\n    max: 1,\n    \"default\": 0.5\n  },\n  thickness: {\n    min: 1,\n    max: 8,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FractalFlowerShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FractalFlowerShape.js?");

/***/ }),

/***/ "./src/shapes/FractalTreeShape.js":
/*!****************************************!*\
  !*** ./src/shapes/FractalTreeShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar FractalTreeShape = /*#__PURE__*/function (_Shape) {\n  function FractalTreeShape() {\n    _classCallCheck(this, FractalTreeShape);\n    return _callSuper(this, FractalTreeShape, arguments);\n  }\n  _inherits(FractalTreeShape, _Shape);\n  return _createClass(FractalTreeShape, [{\n    key: \"calculateBoundingBox\",\n    value: function calculateBoundingBox(depth, angle, lengthRatio) {\n      var width = 0;\n      var currentLength = 100.0;\n      var currentWidth = 0;\n      for (var i = 0; i < depth; i++) {\n        currentWidth = currentLength * Math.sin(angle * Math.PI / 180) * 2;\n        width = Math.max(width, currentWidth);\n        currentLength *= lengthRatio;\n      }\n      return width;\n    }\n  }, {\n    key: \"drawBranch\",\n    value: function drawBranch(start, length, angle, depth, paths) {\n      if (depth <= 0) return;\n      var end = {\n        x: start.x + length * Math.cos(angle * Math.PI / 180),\n        y: start.y - length * Math.sin(angle * Math.PI / 180)\n      };\n      paths.push(\"M \".concat(start.x, \",\").concat(start.y, \" L \").concat(end.x, \",\").concat(end.y));\n      var newLength = length * this.lengthRatio;\n      this.drawBranch(end, newLength, angle + this.branchAngle, depth - 1, paths);\n      this.drawBranch(end, newLength, angle - this.branchAngle, depth - 1, paths);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var boundingWidth = this.calculateBoundingBox(this.depth, this.branchAngle, this.lengthRatio);\n      var totalHeight = 100.0 * (1 - Math.pow(this.lengthRatio, this.depth)) / (1 - this.lengthRatio);\n\n      // Calculate scale to fit within bounds with padding\n      var maxDimension = Math.max(boundingWidth, totalHeight) * 1.2; // Add 20% padding\n      var scale = 200 / maxDimension;\n\n      // Start from bottom center\n      var startY = totalHeight / 2 * scale;\n      var startPoint = {\n        x: 0,\n        y: startY\n      };\n      var paths = [];\n      this.drawBranch(startPoint, 100 * scale, 90, this.depth, paths);\n      return \"<path \\n            d=\\\"\".concat(paths.join(' '), \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FractalTreeShape, \"parameters\", {\n  branchAngle: {\n    min: 10,\n    max: 45,\n    \"default\": 30\n  },\n  lengthRatio: {\n    min: 0.5,\n    max: 0.8,\n    \"default\": 0.7\n  },\n  depth: {\n    min: 2,\n    max: 8,\n    \"default\": 5\n  },\n  thickness: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FractalTreeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FractalTreeShape.js?");

/***/ }),

/***/ "./src/shapes/FrostRaysShape.js":
/*!**************************************!*\
  !*** ./src/shapes/FrostRaysShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar FrostRaysShape = /*#__PURE__*/function (_Shape) {\n  function FrostRaysShape() {\n    _classCallCheck(this, FrostRaysShape);\n    return _callSuper(this, FrostRaysShape, arguments);\n  }\n  _inherits(FrostRaysShape, _Shape);\n  return _createClass(FrostRaysShape, [{\n    key: \"createBranch\",\n    value: function createBranch(center, angle, innerRadius, outerRadius, branchWidth, segmentCount, subCrystalSize) {\n      var paths = [];\n\n      // Calculate main branch points\n      var startX = center.x + innerRadius * Math.cos(angle);\n      var startY = center.y + innerRadius * Math.sin(angle);\n      var endX = center.x + outerRadius * Math.cos(angle);\n      var endY = center.y + outerRadius * Math.sin(angle);\n\n      // Draw main branch line\n      paths.push(\"M \".concat(startX, \",\").concat(startY, \" L \").concat(endX, \",\").concat(endY));\n      this.points = Math.round(this.points);\n\n      // Add segments along the branch\n      var segmentLength = (outerRadius - innerRadius) / segmentCount;\n      for (var i = 1; i <= segmentCount; i++) {\n        var segmentRadius = innerRadius + segmentLength * i;\n        var segmentCenter = {\n          x: center.x + segmentRadius * Math.cos(angle),\n          y: center.y + segmentRadius * Math.sin(angle)\n        };\n\n        // Add side crystals\n        var sideAngle1 = angle + Math.PI / 3;\n        var sideAngle2 = angle - Math.PI / 3;\n        var sideLength = segmentLength * subCrystalSize;\n        var side1End = {\n          x: segmentCenter.x + sideLength * Math.cos(sideAngle1),\n          y: segmentCenter.y + sideLength * Math.sin(sideAngle1)\n        };\n        var side2End = {\n          x: segmentCenter.x + sideLength * Math.cos(sideAngle2),\n          y: segmentCenter.y + sideLength * Math.sin(sideAngle2)\n        };\n        paths.push(\"M \".concat(segmentCenter.x, \",\").concat(segmentCenter.y, \" L \").concat(side1End.x, \",\").concat(side1End.y), \"M \".concat(segmentCenter.x, \",\").concat(segmentCenter.y, \" L \").concat(side2End.x, \",\").concat(side2End.y));\n      }\n      return paths;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var innerRadius = this.innerRadius * 100 * scale;\n      var outerRadius = 120 * scale;\n      var phase = this.phase * (Math.PI / 180.0);\n      var paths = [];\n\n      // Draw main branches\n      for (var i = 0; i < this.points; i++) {\n        var angle = i * 2 * Math.PI / this.points + phase;\n        var branchPaths = this.createBranch(center, angle, innerRadius, outerRadius, this.branchWidth * scale, this.segmentCount, this.subCrystalSize);\n        paths.push.apply(paths, _toConsumableArray(branchPaths));\n      }\n\n      // Draw central core\n      var coreRadius = innerRadius * 0.3;\n      paths.push(\"M \".concat(center.x + coreRadius, \",\").concat(center.y, \" A \").concat(coreRadius, \",\").concat(coreRadius, \" 0 1,0 \").concat(center.x - coreRadius, \",\").concat(center.y, \" A \").concat(coreRadius, \",\").concat(coreRadius, \" 0 1,0 \").concat(center.x + coreRadius, \",\").concat(center.y));\n      return \"<path \\n           d=\\\"\".concat(paths.join(' '), \"\\\"\\n           fill=\\\"none\\\"\\n           stroke=\\\"white\\\"\\n           stroke-width=\\\"\").concat(this.branchWidth * scale, \"\\\"\\n           stroke-linecap=\\\"round\\\"\\n           stroke-linejoin=\\\"round\\\"\\n       />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FrostRaysShape, \"parameters\", {\n  points: {\n    min: 4,\n    max: 12,\n    \"default\": 6\n  },\n  innerRadius: {\n    min: 0.2,\n    max: 0.8,\n    \"default\": 0.4\n  },\n  branchWidth: {\n    min: 2,\n    max: 15,\n    \"default\": 8\n  },\n  segmentCount: {\n    min: 2,\n    max: 8,\n    \"default\": 4\n  },\n  subCrystalSize: {\n    min: 0.1,\n    max: 2.0,\n    \"default\": 0.25\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": -180\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FrostRaysShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FrostRaysShape.js?");

/***/ }),

/***/ "./src/shapes/FunnelShape.js":
/*!***********************************!*\
  !*** ./src/shapes/FunnelShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar FunnelShape = /*#__PURE__*/function (_Shape) {\n  function FunnelShape() {\n    _classCallCheck(this, FunnelShape);\n    return _callSuper(this, FunnelShape, arguments);\n  }\n  _inherits(FunnelShape, _Shape);\n  return _createClass(FunnelShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Scale the parameters\n      var topWidth = this.topWidth * scale;\n      var neckWidth = this.neckWidth * scale;\n      var neckHeight = this.neckHeight * scale;\n      var topHeight = this.topHeight * scale;\n\n      // Calculate key points\n      var totalHeight = topHeight + neckHeight;\n      var topY = center.y - totalHeight / 2;\n      var neckY = topY + topHeight;\n\n      // Build the path\n      var path = [// Top rectangle - start at top left\n      \"M \".concat(center.x - topWidth / 2, \",\").concat(topY), // Top line to right\n      \"L \".concat(center.x + topWidth / 2, \",\").concat(topY), // Right side down to neck\n      \"L \".concat(center.x + neckWidth / 2, \",\").concat(neckY), // Right neck line\n      \"L \".concat(center.x + neckWidth / 2, \",\").concat(neckY + neckHeight), // Bottom line\n      \"L \".concat(center.x - neckWidth / 2, \",\").concat(neckY + neckHeight), // Left neck line\n      \"L \".concat(center.x - neckWidth / 2, \",\").concat(neckY), // Left side up to top\n      \"L \".concat(center.x - topWidth / 2, \",\").concat(topY),\n      // Close path\n      'Z'].join(' ');\n      return \"<path \\n           d=\\\"\".concat(path, \"\\\"\\n           fill=\\\"white\\\"\\n           stroke=\\\"none\\\"\\n       />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(FunnelShape, \"parameters\", {\n  topWidth: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  neckWidth: {\n    min: 20,\n    max: 100,\n    \"default\": 40\n  },\n  neckHeight: {\n    min: 20,\n    max: 100,\n    \"default\": 50\n  },\n  topHeight: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FunnelShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/FunnelShape.js?");

/***/ }),

/***/ "./src/shapes/GeometricEmblem.js":
/*!***************************************!*\
  !*** ./src/shapes/GeometricEmblem.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar GeometricEmblem = /*#__PURE__*/function (_Shape) {\n  function GeometricEmblem() {\n    _classCallCheck(this, GeometricEmblem);\n    return _callSuper(this, GeometricEmblem, arguments);\n  }\n  _inherits(GeometricEmblem, _Shape);\n  return _createClass(GeometricEmblem, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = [];\n      var scale = 0.8;\n      var outerRadius = 100 * scale;\n      var innerRadius = this.innerRadius * 100 * scale;\n      var rotationRad = 0.0;\n      this.points = Math.round(this.points);\n      for (var i = 0; i < this.points; i++) {\n        var angle1 = i * 2 * Math.PI / this.points + rotationRad;\n        var angle2 = (i + 1) * 2 * Math.PI / this.points + rotationRad;\n        var outer1 = {\n          x: outerRadius * Math.cos(angle1),\n          y: outerRadius * Math.sin(angle1)\n        };\n        var outer2 = {\n          x: outerRadius * Math.cos(angle2),\n          y: outerRadius * Math.sin(angle2)\n        };\n        var inner1 = {\n          x: innerRadius * Math.cos(angle1),\n          y: innerRadius * Math.sin(angle1)\n        };\n        var inner2 = {\n          x: innerRadius * Math.cos(angle2),\n          y: innerRadius * Math.sin(angle2)\n        };\n\n        // Create a complete segment path\n        points.push(\"\\n                <path d=\\\"\\n                    M \".concat(outer1.x, \",\").concat(outer1.y, \"\\n                    L \").concat(outer2.x, \",\").concat(outer2.y, \"\\n                    L \").concat(inner2.x, \",\").concat(inner2.y, \"\\n                    L \").concat(inner1.x, \",\").concat(inner1.y, \"\\n                    Z\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linejoin=\\\"round\\\"\\n                    fill=\\\"none\\\"\\n                />\\n            \"));\n      }\n      return points.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GeometricEmblem, \"parameters\", {\n  points: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  innerRadius: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeometricEmblem);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/GeometricEmblem.js?");

/***/ }),

/***/ "./src/shapes/GeometricLogo.js":
/*!*************************************!*\
  !*** ./src/shapes/GeometricLogo.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar GeometricLogo = /*#__PURE__*/function (_Shape) {\n  function GeometricLogo() {\n    _classCallCheck(this, GeometricLogo);\n    return _callSuper(this, GeometricLogo, arguments);\n  }\n  _inherits(GeometricLogo, _Shape);\n  return _createClass(GeometricLogo, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var size = 200; // Base size for scaling\n\n      // Swap x and y coordinates and negate x for -90 degree rotation\n      var topPoint = {\n        x: size * this.height / 2,\n        y: 0\n      };\n      var bottomPoint = {\n        x: -(size * this.height / 2),\n        y: 0\n      };\n      var leftPoint = {\n        x: 0,\n        y: size * this.spread / 2\n      };\n      var rightPoint = {\n        x: 0,\n        y: -(size * this.spread / 2)\n      };\n\n      // Calculate center points for the triangles\n      var centerTop = {\n        x: size * this.pointiness / 2,\n        y: size * this.centerOffset\n      };\n      var centerBottom = {\n        x: -(size * this.pointiness / 2),\n        y: size * this.centerOffset\n      };\n\n      // Create paths for each triangle\n      var topTriangle = \"\\n            M \".concat(topPoint.x, \",\").concat(topPoint.y, \"\\n            L \").concat(leftPoint.x, \",\").concat(leftPoint.y, \"\\n            L \").concat(centerTop.x, \",\").concat(centerTop.y, \"\\n            Z\\n        \");\n      var rightTriangle = \"\\n            M \".concat(rightPoint.x, \",\").concat(rightPoint.y, \"\\n            L \").concat(centerTop.x, \",\").concat(centerTop.y, \"\\n            L \").concat(centerBottom.x, \",\").concat(centerBottom.y, \"\\n            Z\\n        \");\n      var bottomTriangle = \"\\n            M \".concat(bottomPoint.x, \",\").concat(bottomPoint.y, \"\\n            L \").concat(centerBottom.x, \",\").concat(centerBottom.y, \"\\n            L \").concat(leftPoint.x, \",\").concat(leftPoint.y, \"\\n            Z\\n        \");\n      return \"\\n            <path d=\\\"\".concat(topTriangle, \" \").concat(rightTriangle, \" \").concat(bottomTriangle, \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GeometricLogo, \"parameters\", {\n  spread: {\n    min: 0.2,\n    max: 1.0,\n    \"default\": 0.9\n  },\n  height: {\n    min: 0.5,\n    max: 1.5,\n    \"default\": 0.6\n  },\n  pointiness: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  },\n  centerOffset: {\n    min: -0.3,\n    max: 0.3,\n    \"default\": 0.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeometricLogo);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/GeometricLogo.js?");

/***/ }),

/***/ "./src/shapes/GeometricPetalFlower.js":
/*!********************************************!*\
  !*** ./src/shapes/GeometricPetalFlower.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar GeometricPetalFlower = /*#__PURE__*/function (_Shape) {\n  function GeometricPetalFlower() {\n    _classCallCheck(this, GeometricPetalFlower);\n    return _callSuper(this, GeometricPetalFlower, arguments);\n  }\n  _inherits(GeometricPetalFlower, _Shape);\n  return _createClass(GeometricPetalFlower, [{\n    key: \"generatePetal\",\n    value: function generatePetal(centerAngle, halfAngleStep) {\n      // Calculate angles for start and end of petal\n      var startAngle = centerAngle - halfAngleStep;\n      var endAngle = centerAngle + halfAngleStep;\n\n      // Calculate points for the petal\n      var startPoint = {\n        x: this.innerRadius * Math.cos(startAngle),\n        y: this.innerRadius * Math.sin(startAngle)\n      };\n      var endPoint = {\n        x: this.innerRadius * Math.cos(endAngle),\n        y: this.innerRadius * Math.sin(endAngle)\n      };\n      var petalTip = {\n        x: this.petalLength * Math.cos(centerAngle),\n        y: this.petalLength * Math.sin(centerAngle)\n      };\n\n      // Calculate control points for the curves (symmetrically)\n      var controlPoint1 = {\n        x: startPoint.x + this.petalWidth * 0.7 * Math.cos(centerAngle + Math.PI / 2) + this.petalLength * this.petalPointiness * Math.cos(centerAngle),\n        y: startPoint.y + this.petalWidth * 0.7 * Math.sin(centerAngle + Math.PI / 2) + this.petalLength * this.petalPointiness * Math.sin(centerAngle)\n      };\n      var controlPoint2 = {\n        x: endPoint.x + this.petalWidth * 0.7 * Math.cos(centerAngle - Math.PI / 2) + this.petalLength * this.petalPointiness * Math.cos(centerAngle),\n        y: endPoint.y + this.petalWidth * 0.7 * Math.sin(centerAngle - Math.PI / 2) + this.petalLength * this.petalPointiness * Math.sin(centerAngle)\n      };\n\n      // Create the petal path\n      return {\n        startPoint: startPoint,\n        endPoint: endPoint,\n        path: \"C \".concat(controlPoint1.x, \",\").concat(controlPoint1.y, \" \\n                   \").concat(petalTip.x * (1 - this.petalPointiness * 0.3), \",\").concat(petalTip.y * (1 - this.petalPointiness * 0.3), \" \\n                   \").concat(petalTip.x, \",\").concat(petalTip.y, \"\\n                   C \").concat(petalTip.x * (1 - this.petalPointiness * 0.3), \",\").concat(petalTip.y * (1 - this.petalPointiness * 0.3), \"\\n                   \").concat(controlPoint2.x, \",\").concat(controlPoint2.y, \" \\n                   \").concat(endPoint.x, \",\").concat(endPoint.y)\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Round to ensure integer number of petals\n      this.petalCount = Math.round(this.petalCount);\n\n      // Calculate angle step between petals\n      var angleStep = 2 * Math.PI / this.petalCount;\n      var halfAngleStep = angleStep / 2;\n      var pathData = '';\n\n      // Start at the first petal's starting point\n      var startAngle = 0 - halfAngleStep;\n      var firstPoint = {\n        x: this.innerRadius * Math.cos(startAngle),\n        y: this.innerRadius * Math.sin(startAngle)\n      };\n      pathData = \"M \".concat(firstPoint.x, \",\").concat(firstPoint.y);\n\n      // For each petal\n      for (var i = 0; i < this.petalCount; i++) {\n        var centerAngle = i * angleStep;\n        var petal = this.generatePetal(centerAngle, halfAngleStep);\n        pathData += ' ' + petal.path;\n      }\n\n      // Close the path\n      pathData += ' Z';\n      return \"\\n            <path \\n                d=\\\"\".concat(pathData, \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GeometricPetalFlower, \"parameters\", {\n  petalCount: {\n    min: 4,\n    max: 24,\n    \"default\": 12\n  },\n  petalLength: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  petalWidth: {\n    min: 10,\n    max: 100,\n    \"default\": 35\n  },\n  petalPointiness: {\n    min: 0.2,\n    max: 1.0,\n    \"default\": 0.5\n  },\n  innerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 15\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeometricPetalFlower);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/GeometricPetalFlower.js?");

/***/ }),

/***/ "./src/shapes/GlitchPattern.js":
/*!*************************************!*\
  !*** ./src/shapes/GlitchPattern.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar GlitchPattern = /*#__PURE__*/function (_Shape) {\n  function GlitchPattern() {\n    _classCallCheck(this, GlitchPattern);\n    return _callSuper(this, GlitchPattern, arguments);\n  }\n  _inherits(GlitchPattern, _Shape);\n  return _createClass(GlitchPattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Reset RNG for consistent results\n      this.resetRNG();\n      var size = 180;\n      var cellSize = (size - (this.gridSize - 1) * this.gapSize) / this.gridSize;\n      var startPos = -size / 2;\n\n      // Prepare cell occupancy grid\n      var grid = Array(this.gridSize).fill().map(function () {\n        return Array(_this.gridSize).fill(false);\n      });\n\n      // Generate pattern based on complexity\n      this.generateTechPattern(grid);\n\n      // Create shapes from the pattern\n      var elements = [];\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          if (grid[y][x]) {\n            // Calculate position\n            var xPos = startPos + x * (cellSize + this.gapSize);\n            var yPos = startPos + y * (cellSize + this.gapSize);\n\n            // Check for merged cells (horizontal)\n            var width = cellSize;\n            var height = cellSize;\n\n            // Try to extend horizontally and vertically based on emphasis\n            if (this.emphasis !== 'vertical') {\n              width = this.extendHorizontally(grid, x, y) * (cellSize + this.gapSize) - this.gapSize;\n            }\n            if (this.emphasis !== 'horizontal') {\n              height = this.extendVertically(grid, x, y) * (cellSize + this.gapSize) - this.gapSize;\n            }\n\n            // Add rect element\n            elements.push(\"<rect \\n                        x=\\\"\".concat(xPos, \"\\\" \\n                        y=\\\"\").concat(yPos, \"\\\" \\n                        width=\\\"\").concat(width, \"\\\" \\n                        height=\\\"\").concat(height, \"\\\"\\n                        rx=\\\"\").concat(this.cornerRadius, \"\\\"\\n                        ry=\\\"\").concat(this.cornerRadius, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\"));\n\n            // Mark extended cells as processed\n            var extendX = width / (cellSize + this.gapSize) + 0.1;\n            var extendY = height / (cellSize + this.gapSize) + 0.1;\n            for (var j = 0; j < extendY; j++) {\n              for (var i = 0; i < extendX; i++) {\n                if (x + i < this.gridSize && y + j < this.gridSize) {\n                  grid[y + j][x + i] = false;\n                }\n              }\n            }\n\n            // Re-mark current cell to continue iteration\n            grid[y][x] = true;\n          }\n        }\n      }\n      return elements.join('');\n    }\n  }, {\n    key: \"generateTechPattern\",\n    value: function generateTechPattern(grid) {\n      // Apply base fill percentage\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          // Apply symmetry if enabled\n          if (this.symmetry > 0 && this.random() * 100 < this.symmetry) {\n            // Determine symmetry type (quadrant, axial, etc.)\n            var centerX = this.gridSize / 2;\n            var centerY = this.gridSize / 2;\n            var reflectX = Math.floor(centerX * 2) - x;\n            var reflectY = Math.floor(centerY * 2) - y;\n            if (reflectX >= 0 && reflectX < this.gridSize && reflectY >= 0 && reflectY < this.gridSize) {\n              // Apply mirrored value\n              grid[y][x] = grid[reflectY][reflectX];\n              continue;\n            }\n          }\n\n          // Generate weighted pattern based on uniformity\n          var fillChance = this.fillPercentage;\n\n          // Apply non-uniformity adjustments\n          if (this.uniformity < 100) {\n            var noiseAmount = (100 - this.uniformity) / 100;\n            var patternFactor = this.getPatternFactor(x, y);\n            fillChance = this.fillPercentage * (1 - noiseAmount) + patternFactor * noiseAmount * 100;\n          }\n          grid[y][x] = this.random() * 100 < fillChance;\n        }\n      }\n\n      // Add complexity elements based on complexity parameter\n      this.addComplexityFeatures(grid);\n    }\n  }, {\n    key: \"getPatternFactor\",\n    value: function getPatternFactor(x, y) {\n      // Different pattern factors to create tech-like arrangements\n      var centerX = this.gridSize / 2;\n      var centerY = this.gridSize / 2;\n\n      // Distance from center\n      var dx = (x - centerX) / this.gridSize;\n      var dy = (y - centerY) / this.gridSize;\n      var dist = Math.sqrt(dx * dx + dy * dy) * 2;\n\n      // Angular component\n      var angle = Math.atan2(dy, dx) / Math.PI;\n\n      // Tech pattern factors\n      var linearGradient = 1 - y / this.gridSize;\n      var radialGradient = 1 - dist;\n      var angularPattern = (Math.sin(angle * 4) + 1) / 2;\n      var gridPattern = x % 2 * 0.5 + y % 3 * 0.3;\n\n      // Combine factors based on seed for variety\n      var seed = this.seed % 4;\n      switch (seed) {\n        case 0:\n          return linearGradient * 0.6 + angularPattern * 0.4;\n        case 1:\n          return radialGradient * 0.7 + gridPattern * 0.3;\n        case 2:\n          return angularPattern * 0.5 + gridPattern * 0.5;\n        case 3:\n          return linearGradient * 0.4 + radialGradient * 0.6;\n        default:\n          return linearGradient;\n      }\n    }\n  }, {\n    key: \"addComplexityFeatures\",\n    value: function addComplexityFeatures(grid) {\n      if (this.complexity <= 1) return;\n\n      // Add L-shapes and other tech patterns based on complexity\n      var featureCount = Math.max(1, Math.floor((this.complexity - 1) * this.gridSize / 2));\n      for (var i = 0; i < featureCount; i++) {\n        var featureType = Math.floor(this.random() * 4);\n        var x = Math.floor(this.random() * (this.gridSize - 2));\n        var y = Math.floor(this.random() * (this.gridSize - 2));\n        switch (featureType) {\n          case 0:\n            // L-shape\n            grid[y][x] = true;\n            grid[y + 1][x] = true;\n            grid[y + 1][x + 1] = true;\n            break;\n          case 1:\n            // T-shape\n            grid[y][x] = true;\n            grid[y][x + 1] = true;\n            grid[y + 1][x + 1] = true;\n            break;\n          case 2:\n            // Plus-shape\n            if (x > 0 && y > 0 && x < this.gridSize - 1 && y < this.gridSize - 1) {\n              grid[y][x] = true;\n              grid[y - 1][x] = true;\n              grid[y + 1][x] = true;\n              grid[y][x - 1] = true;\n              grid[y][x + 1] = true;\n            }\n            break;\n          case 3:\n            // Block\n            grid[y][x] = true;\n            grid[y][x + 1] = true;\n            grid[y + 1][x] = true;\n            grid[y + 1][x + 1] = true;\n            break;\n        }\n      }\n    }\n  }, {\n    key: \"extendHorizontally\",\n    value: function extendHorizontally(grid, startX, startY) {\n      var width = 1;\n      var x = startX + 1;\n      while (x < this.gridSize && grid[startY][x]) {\n        width++;\n        x++;\n      }\n      return width;\n    }\n  }, {\n    key: \"extendVertically\",\n    value: function extendVertically(grid, startX, startY) {\n      var height = 1;\n      var y = startY + 1;\n      while (y < this.gridSize && grid[y][startX]) {\n        height++;\n        y++;\n      }\n      return height;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GlitchPattern, \"parameters\", {\n  gridSize: {\n    min: 4,\n    max: 12,\n    \"default\": 8\n  },\n  fillPercentage: {\n    min: 20,\n    max: 80,\n    \"default\": 60\n  },\n  cornerRadius: {\n    min: 0,\n    max: 8,\n    \"default\": 2\n  },\n  gapSize: {\n    min: 2,\n    max: 10,\n    \"default\": 4\n  },\n  uniformity: {\n    min: 0,\n    max: 100,\n    \"default\": 30\n  },\n  complexity: {\n    min: 1,\n    max: 5,\n    \"default\": 3\n  },\n  emphasis: {\n    options: ['horizontal', 'vertical', 'balanced'],\n    \"default\": 'balanced'\n  },\n  symmetry: {\n    min: 0,\n    max: 100,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GlitchPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/GlitchPattern.js?");

/***/ }),

/***/ "./src/shapes/Globe.js":
/*!*****************************!*\
  !*** ./src/shapes/Globe.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar GlobeShape = /*#__PURE__*/function (_Shape) {\n  function GlobeShape() {\n    _classCallCheck(this, GlobeShape);\n    return _callSuper(this, GlobeShape, arguments);\n  }\n  _inherits(GlobeShape, _Shape);\n  return _createClass(GlobeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n\n      // Generate meridians (vertical ellipses)\n      if (this.meridians > 0) {\n        var meridianStep = Math.PI / (this.meridians + 1);\n        for (var i = 1; i <= this.meridians; i++) {\n          var angle = meridianStep * i;\n          // Use absolute value of cosine to prevent negative radius\n          var compression = Math.abs(Math.cos(angle));\n          elements.push(\"<ellipse\\n                    cx=\\\"0\\\"\\n                    cy=\\\"0\\\"\\n                    rx=\\\"\".concat(this.radius, \"\\\"\\n                    ry=\\\"\").concat(this.radius * compression, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    fill=\\\"none\\\"\\n                />\"));\n        }\n      }\n\n      // Generate parallels (horizontal ellipses)\n      if (this.parallels > 0) {\n        var parallelStep = Math.PI / (this.parallels + 1);\n        for (var _i = 1; _i <= this.parallels; _i++) {\n          var _angle = parallelStep * _i;\n          // Use absolute value of cosine to prevent negative radius\n          var _compression = Math.abs(Math.cos(_angle));\n          elements.push(\"<ellipse\\n                    cx=\\\"0\\\"\\n                    cy=\\\"0\\\"\\n                    rx=\\\"\".concat(this.radius * _compression, \"\\\"\\n                    ry=\\\"\").concat(this.radius, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    fill=\\\"none\\\"\\n                />\"));\n        }\n      }\n\n      // Add outer circle last so it's on top\n      elements.push(\"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(this.radius, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GlobeShape, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  meridians: {\n    min: 0,\n    max: 24,\n    \"default\": 0\n  },\n  // Vertical lines\n  parallels: {\n    min: 0,\n    max: 24,\n    \"default\": 7\n  },\n  // Horizontal lines\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GlobeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Globe.js?");

/***/ }),

/***/ "./src/shapes/Goblet.js":
/*!******************************!*\
  !*** ./src/shapes/Goblet.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar GobletShape = /*#__PURE__*/function (_Shape) {\n  function GobletShape() {\n    _classCallCheck(this, GobletShape);\n    return _callSuper(this, GobletShape, arguments);\n  }\n  _inherits(GobletShape, _Shape);\n  return _createClass(GobletShape, [{\n    key: \"generateProfilePoints\",\n    value: function generateProfilePoints() {\n      var points = [];\n      var steps = this.resolution;\n      var size = 80;\n      var normalizedStemHeight = this.stemHeight / this.height;\n      var totalHeight = size * 2;\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps;\n        var x = void 0,\n          y = void 0;\n\n        // Y coordinate with slight curve adjustment for minimal style\n        y = size - t * totalHeight;\n\n        // X coordinate calculation with style variations\n        if (t < normalizedStemHeight) {\n          // Stem section with style-specific modulation\n          var stemT = t / normalizedStemHeight;\n          var stemShape = void 0;\n          switch (this.style) {\n            case 'minimal':\n              // Straight lines with subtle curves\n              stemShape = Math.sin(stemT * Math.PI * 0.5) * this.modulation * 0.05;\n              break;\n            case 'organic':\n              // More natural, flowing curves\n              stemShape = Math.sin(stemT * Math.PI) * this.modulation * Math.sin(stemT * 3 * Math.PI) * 0.15;\n              break;\n            default:\n              // smooth\n              // Classic smooth curves\n              stemShape = Math.sin(stemT * Math.PI) * this.modulation * 0.1;\n          }\n          x = this.baseWidth / 100 * size + stemShape * size;\n        } else {\n          // Bowl section with enhanced style variations\n          var bowlT = (t - normalizedStemHeight) / (1 - normalizedStemHeight);\n          var width = this.baseWidth / 100 + (this.width / 100 - this.baseWidth / 100) * this.getBowlProfile(bowlT);\n\n          // Style-specific modulation\n          switch (this.style) {\n            case 'minimal':\n              // Subtle, clean modulation\n              for (var j = 1; j <= this.complexity; j++) {\n                width += Math.sin(bowlT * j * Math.PI) * this.modulation * 0.05 * (1 - bowlT);\n              }\n              break;\n            case 'organic':\n              // More dramatic, natural variations\n              for (var _j = 1; _j <= this.complexity; _j++) {\n                width += Math.sin(bowlT * _j * Math.PI) * Math.cos(bowlT * _j * 0.5 * Math.PI) * this.modulation * 0.15;\n              }\n              break;\n            default:\n              // smooth\n              // Classic smooth variations\n              for (var _j2 = 1; _j2 <= this.complexity; _j2++) {\n                width += Math.sin(bowlT * _j2 * Math.PI) * this.modulation * 0.1;\n              }\n          }\n          x = width * size;\n        }\n        points.push([x, y]);\n      }\n      return points;\n    }\n  }, {\n    key: \"getBowlProfile\",\n    value: function getBowlProfile(t) {\n      // Style-specific bowl profiles\n      switch (this.style) {\n        case 'minimal':\n          // More linear profile with subtle curve\n          return t * (1.2 - t * 0.2);\n        case 'organic':\n          // More dramatic curve\n          return 0.6 * (1 - Math.cos(t * Math.PI));\n        default:\n          // smooth\n          // Classic smooth curve\n          return 0.5 * (1 - Math.cos(t * Math.PI));\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = this.generateProfilePoints();\n\n      // Generate right side\n      var rightSide = points.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        return \"\".concat(x, \",\").concat(y);\n      }).join(' L');\n\n      // Mirror for left side\n      var leftSide = points.map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          x = _ref4[0],\n          y = _ref4[1];\n        return \"\".concat(-x, \",\").concat(y);\n      }).reverse().join(' L');\n\n      // Combine into complete path\n      var pathData = \"M\".concat(leftSide, \" L\").concat(rightSide, \"Z\");\n      return \"<g transform=\\\"translate(0,0)\\\">\\n            <path \\n                d=\\\"\".concat(pathData, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"1.5\\\"\\n                fill=\\\"white\\\"\\n            />\\n        </g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(GobletShape, \"parameters\", {\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 140\n  },\n  width: {\n    min: 20,\n    max: 120,\n    \"default\": 80\n  },\n  // Increased max width\n  baseWidth: {\n    min: 10,\n    max: 80,\n    \"default\": 30\n  },\n  // More dramatic base options\n  stemHeight: {\n    min: 10,\n    max: 140,\n    \"default\": 50\n  },\n  // Increased range\n  modulation: {\n    min: 0,\n    max: 1.5,\n    \"default\": 0.5\n  },\n  // Increased max modulation\n  complexity: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  // More complexity options\n  resolution: {\n    min: 10,\n    max: 100,\n    \"default\": 50\n  },\n  style: {\n    options: ['smooth', 'organic', 'minimal'],\n    \"default\": 'minimal'\n  } // Added minimal style\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GobletShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Goblet.js?");

/***/ }),

/***/ "./src/shapes/HexagonalCluster.js":
/*!****************************************!*\
  !*** ./src/shapes/HexagonalCluster.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar HexagonalCluster = /*#__PURE__*/function (_Shape) {\n  function HexagonalCluster() {\n    _classCallCheck(this, HexagonalCluster);\n    return _callSuper(this, HexagonalCluster, arguments);\n  }\n  _inherits(HexagonalCluster, _Shape);\n  return _createClass(HexagonalCluster, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n\n      // Core constants\n      var sqrt3 = Math.sqrt(3);\n      var baseScale = 1.2; // Scale factor for SVG viewBox\n      var hexSize = this.hexSize * baseScale;\n      var gridRadius = Math.round(this.complexity);\n      var numPoints = Math.max(3, Math.round(this.points));\n      var cornerRadius = this.cornerRadius * baseScale;\n      // const rotationAngle = this.rotation * (Math.PI / 180);\n      var rotationAngle = 0.0;\n\n      // Hex point class with neighbor tracking\n      var HexPoint = /*#__PURE__*/function () {\n        function HexPoint(q, r, s) {\n          _classCallCheck(this, HexPoint);\n          this.q = q;\n          this.r = r;\n          this.s = s;\n          this.neighbors = [];\n        }\n        return _createClass(HexPoint, [{\n          key: \"equals\",\n          value: function equals(other) {\n            return this.q === other.q && this.r === other.r && this.s === other.s;\n          }\n        }]);\n      }(); // Generate hex grid\n      var generateHexGrid = function generateHexGrid(radius) {\n        var points = new Map();\n        for (var q = -radius; q <= radius; q++) {\n          var rMin = Math.max(-radius, -q - radius);\n          var rMax = Math.min(radius, -q + radius);\n          for (var r = rMin; r <= rMax; r++) {\n            var s = -q - r;\n            var key = \"\".concat(q, \",\").concat(r);\n            points.set(key, new HexPoint(q, r, s));\n          }\n        }\n\n        // Add neighbors\n        var directions = [[1, 0], [1, -1], [0, -1], [-1, 0], [-1, 1], [0, 1]];\n        points.forEach(function (point) {\n          directions.forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n              dq = _ref2[0],\n              dr = _ref2[1];\n            var key = \"\".concat(point.q + dq, \",\").concat(point.r + dr);\n            var neighbor = points.get(key);\n            if (neighbor) {\n              point.neighbors.push(neighbor);\n            }\n          });\n        });\n        return Array.from(points.values());\n      };\n\n      // Generate shape via random walk\n      var generateShapePoints = function generateShapePoints(grid, count) {\n        var start = grid[Math.floor(_this.random() * grid.length)];\n        var visited = new Set([start]);\n        var shape = [start];\n        var current = start;\n        while (shape.length < count) {\n          var available = current.neighbors.filter(function (n) {\n            return !visited.has(n);\n          });\n          if (available.length > 0) {\n            current = available[Math.floor(_this.random() * available.length)];\n            visited.add(current);\n            shape.push(current);\n          } else {\n            current = shape[Math.floor(_this.random() * shape.length)];\n          }\n        }\n        return shape;\n      };\n\n      // Convert hex coordinates to pixel coordinates\n      var hexToPixel = function hexToPixel(hex) {\n        return {\n          x: hexSize * (sqrt3 * hex.q + sqrt3 / 2 * hex.r),\n          y: hexSize * (3 / 2 * hex.r)\n        };\n      };\n\n      // Apply rotation to a point\n      var rotatePoint = function rotatePoint(point, angle) {\n        var cos = Math.cos(angle);\n        var sin = Math.sin(angle);\n        return {\n          x: point.x * cos - point.y * sin,\n          y: point.x * sin + point.y * cos\n        };\n      };\n\n      // Apply distortion to a point\n      var distortPoint = function distortPoint(point, factor) {\n        if (factor <= 0) return point;\n        var distortX = (_this.random() - 0.5) * factor;\n        var distortY = (_this.random() - 0.5) * factor;\n        return {\n          x: point.x + distortX,\n          y: point.y + distortY\n        };\n      };\n\n      // Generate and process shape points\n      var grid = generateHexGrid(gridRadius);\n      var shapeHexes = generateShapePoints(grid, numPoints);\n      var points = shapeHexes.map(function (hex) {\n        return hexToPixel(hex);\n      });\n\n      // Calculate bounds\n      var bounds = points.reduce(function (acc, pt) {\n        return {\n          minX: Math.min(acc.minX, pt.x),\n          maxX: Math.max(acc.maxX, pt.x),\n          minY: Math.min(acc.minY, pt.y),\n          maxY: Math.max(acc.maxY, pt.y)\n        };\n      }, {\n        minX: Infinity,\n        maxX: -Infinity,\n        minY: Infinity,\n        maxY: -Infinity\n      });\n\n      // Center the points\n      var centerX = (bounds.maxX + bounds.minX) / 2;\n      var centerY = (bounds.maxY + bounds.minY) / 2;\n      points = points.map(function (pt) {\n        return {\n          x: pt.x - centerX,\n          y: pt.y - centerY\n        };\n      });\n\n      // Calculate centroid for angle sorting\n      var centroid = points.reduce(function (sum, pt) {\n        return {\n          x: sum.x + pt.x / points.length,\n          y: sum.y + pt.y / points.length\n        };\n      }, {\n        x: 0,\n        y: 0\n      });\n\n      // Sort points by angle around centroid\n      points.sort(function (a, b) {\n        return Math.atan2(a.y - centroid.y, a.x - centroid.x) - Math.atan2(b.y - centroid.y, b.x - centroid.x);\n      });\n\n      // Apply distortion if needed\n      if (this.distortion > 0) {\n        points = points.map(function (pt) {\n          return distortPoint(pt, _this.distortion);\n        });\n      }\n\n      // Apply rotation if needed\n      if (rotationAngle !== 0) {\n        points = points.map(function (pt) {\n          return rotatePoint(pt, rotationAngle);\n        });\n      }\n\n      // Determine corner radii based on style\n      var determineCornerRadii = function determineCornerRadii(points, baseRadius, style) {\n        var count = points.length;\n        var radii = new Array(count);\n        switch (style) {\n          case 0:\n            // All rounded\n            for (var i = 0; i < count; i++) {\n              radii[i] = baseRadius;\n            }\n            break;\n          case 1:\n            // None rounded\n            for (var _i = 0; _i < count; _i++) {\n              radii[_i] = 0;\n            }\n            break;\n          case 2:\n            // Alternating\n            for (var _i2 = 0; _i2 < count; _i2++) {\n              radii[_i2] = _i2 % 2 === 0 ? baseRadius : 0;\n            }\n            break;\n          case 3:\n            // Random\n            for (var _i3 = 0; _i3 < count; _i3++) {\n              radii[_i3] = _this.random() < 0.5 ? baseRadius : 0;\n            }\n            break;\n          default:\n            for (var _i4 = 0; _i4 < count; _i4++) {\n              radii[_i4] = baseRadius;\n            }\n        }\n        return radii;\n      };\n\n      // Create path with variable corner radii\n      var createVaryingRadiiPath = function createVaryingRadiiPath(points, radii) {\n        var count = points.length;\n        var parts = [];\n        for (var i = 0; i < count; i++) {\n          var curr = points[i];\n          var prev = points[(i - 1 + count) % count];\n          var next = points[(i + 1) % count];\n          var radius = radii[i];\n          var v1 = {\n            x: curr.x - prev.x,\n            y: curr.y - prev.y\n          };\n          var v2 = {\n            x: next.x - curr.x,\n            y: next.y - curr.y\n          };\n          var len1 = Math.hypot(v1.x, v1.y);\n          var len2 = Math.hypot(v2.x, v2.y);\n          if (len1 === 0 || len2 === 0) continue;\n          if (radius <= 0) {\n            // Sharp corner\n            if (i === 0) {\n              parts.push(\"M \".concat(curr.x, \" \").concat(curr.y));\n            } else {\n              parts.push(\"L \".concat(curr.x, \" \").concat(curr.y));\n            }\n          } else {\n            // Rounded corner\n            var distance = Math.min(radius, Math.min(len1, len2) / 2);\n            var p1 = {\n              x: curr.x - v1.x / len1 * distance,\n              y: curr.y - v1.y / len1 * distance\n            };\n            var p2 = {\n              x: curr.x + v2.x / len2 * distance,\n              y: curr.y + v2.y / len2 * distance\n            };\n            if (i === 0) {\n              parts.push(\"M \".concat(p1.x, \" \").concat(p1.y));\n            } else {\n              parts.push(\"L \".concat(p1.x, \" \").concat(p1.y));\n            }\n            parts.push(\"Q \".concat(curr.x, \" \").concat(curr.y, \" \").concat(p2.x, \" \").concat(p2.y));\n          }\n        }\n        parts.push('Z');\n        return parts.join(' ');\n      };\n\n      // Determine corner radii based on selected style\n      var cornerRadii = determineCornerRadii(points, cornerRadius, this.cornerStyle);\n\n      // Generate the main path\n      var mainPath = createVaryingRadiiPath(points, cornerRadii);\n      return \"<path \\n            d=\\\"\".concat(mainPath, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(HexagonalCluster, \"parameters\", {\n  complexity: {\n    min: 4,\n    max: 12,\n    \"default\": 5\n  },\n  // Grid radius\n  points: {\n    min: 5,\n    max: 16,\n    \"default\": 8\n  },\n  // Number of hex cells used\n  hexSize: {\n    min: 20,\n    max: 40,\n    \"default\": 28\n  },\n  // Base size of a hex cell\n  cornerRadius: {\n    min: 0,\n    max: 60,\n    \"default\": 10\n  },\n  // Base rounding at vertices\n  cornerStyle: {\n    min: 0,\n    max: 3,\n    \"default\": 0\n  },\n  // 0: all, 1: none, 2: alternating, 3: random\n  distortion: {\n    min: 0,\n    max: 30,\n    \"default\": 0\n  } // Add irregularity to shape\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HexagonalCluster);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/HexagonalCluster.js?");

/***/ }),

/***/ "./src/shapes/HollowEllipse.js":
/*!*************************************!*\
  !*** ./src/shapes/HollowEllipse.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar HollowEllipse = /*#__PURE__*/function (_Shape) {\n  function HollowEllipse() {\n    _classCallCheck(this, HollowEllipse);\n    return _callSuper(this, HollowEllipse, arguments);\n  }\n  _inherits(HollowEllipse, _Shape);\n  return _createClass(HollowEllipse, [{\n    key: \"validateInnerEllipseBounds\",\n    value: function validateInnerEllipseBounds() {\n      // Ensure inner ellipse is not larger than outer ellipse\n      this.innerRadiusX = Math.min(this.innerRadiusX, this.outerRadiusX * 0.95);\n      this.innerRadiusY = Math.min(this.innerRadiusY, this.outerRadiusY * 0.95);\n\n      // Calculate the maximum allowed offset to keep inner ellipse within outer\n      var maxOffsetX = Math.max(1, this.outerRadiusX - this.innerRadiusX);\n      var maxOffsetY = Math.max(1, this.outerRadiusY - this.innerRadiusY);\n\n      // Constrain the inner ellipse offsets\n      this.innerOffsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, this.innerOffsetX));\n      this.innerOffsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, this.innerOffsetY));\n    }\n  }, {\n    key: \"applyPerspectiveTransform\",\n    value: function applyPerspectiveTransform(rx, ry, rotX, rotY) {\n      // Convert degrees to radians\n      var radX = rotX * Math.PI / 180;\n      var radY = rotY * Math.PI / 180;\n\n      // Apply perspective transformation to ellipse radii\n      var transformedRx = rx * Math.abs(Math.cos(radY));\n      var transformedRy = ry * Math.abs(Math.cos(radX));\n      return {\n        rx: Math.max(1, transformedRx),\n        // Prevent zero or negative values\n        ry: Math.max(1, transformedRy)\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Validate inner ellipse is within bounds\n      this.validateInnerEllipseBounds();\n\n      // Generate a unique ID for this mask instance\n      var maskId = \"hollow-ellipse-mask-\".concat(Math.floor(Math.random() * 10000));\n\n      // Apply perspective transforms for x and y rotations\n      var outerTransformed = this.applyPerspectiveTransform(this.outerRadiusX, this.outerRadiusY, this.rotationX, this.rotationY);\n      var innerTransformed = this.applyPerspectiveTransform(this.innerRadiusX, this.innerRadiusY, this.rotationX, this.rotationY);\n\n      // Also transform the offset based on perspective\n      var offsetTransform = this.applyPerspectiveTransform(this.innerOffsetX, this.innerOffsetY, this.rotationX, this.rotationY);\n\n      // Calculate adjusted offsets based on perspective\n      var adjustedOffsetX = this.innerOffsetX * Math.abs(Math.cos(this.rotationY * Math.PI / 180));\n      var adjustedOffsetY = this.innerOffsetY * Math.abs(Math.cos(this.rotationX * Math.PI / 180));\n\n      // Create the mask with outer ellipse (white) and inner ellipse (black)\n      var defs = \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <rect x=\\\"-200\\\" y=\\\"-200\\\" width=\\\"400\\\" height=\\\"400\\\" fill=\\\"black\\\" />\\n                    <ellipse \\n                        cx=\\\"0\\\" \\n                        cy=\\\"0\\\" \\n                        rx=\\\"\").concat(outerTransformed.rx, \"\\\" \\n                        ry=\\\"\").concat(outerTransformed.ry, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\\n                    <ellipse \\n                        cx=\\\"\").concat(adjustedOffsetX, \"\\\" \\n                        cy=\\\"\").concat(adjustedOffsetY, \"\\\" \\n                        rx=\\\"\").concat(innerTransformed.rx, \"\\\" \\n                        ry=\\\"\").concat(innerTransformed.ry, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                </mask>\\n            </defs>\\n        \");\n\n      // Create the main ellipse shape and apply the mask and rotation\n      var shape = \"\\n            <g transform=\\\"rotate(\".concat(this.rotationZ, \")\\\">\\n                <ellipse \\n                    cx=\\\"0\\\" \\n                    cy=\\\"0\\\" \\n                    rx=\\\"\").concat(outerTransformed.rx, \"\\\" \\n                    ry=\\\"\").concat(outerTransformed.ry, \"\\\"\\n                    fill=\\\"white\\\"\\n                    mask=\\\"url(#\").concat(maskId, \")\\\"\\n                />\\n            </g>\\n        \");\n      return defs + shape;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(HollowEllipse, \"parameters\", {\n  outerRadiusX: {\n    min: 100,\n    max: 200,\n    \"default\": 100\n  },\n  outerRadiusY: {\n    min: 100,\n    max: 200,\n    \"default\": 100\n  },\n  innerRadiusX: {\n    min: 25,\n    max: 50,\n    \"default\": 40\n  },\n  innerRadiusY: {\n    min: 25,\n    max: 50,\n    \"default\": 40\n  },\n  innerOffsetX: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  },\n  innerOffsetY: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  },\n  rotationX: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  },\n  rotationY: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  },\n  rotationZ: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HollowEllipse);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/HollowEllipse.js?");

/***/ }),

/***/ "./src/shapes/HorizontalRects.js":
/*!***************************************!*\
  !*** ./src/shapes/HorizontalRects.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar HorizontalRects = /*#__PURE__*/function (_Shape) {\n  function HorizontalRects() {\n    _classCallCheck(this, HorizontalRects);\n    return _callSuper(this, HorizontalRects, arguments);\n  }\n  _inherits(HorizontalRects, _Shape);\n  return _createClass(HorizontalRects, [{\n    key: \"calculateHeights\",\n    value: function calculateHeights() {\n      var heights = new Array(this.count);\n      var heightDiff = this.maxHeight - this.minHeight;\n      if (Math.abs(this.direction) <= 0.1) {\n        // Center peak pattern\n        var mid = Math.floor((this.count - 1) / 2);\n        for (var i = 0; i < this.count; i++) {\n          var distFromCenter = Math.abs(i - mid) / (this.count - 1);\n          heights[i] = this.maxHeight - distFromCenter * heightDiff * 2;\n        }\n      } else {\n        // Ascending or descending pattern\n        for (var _i = 0; _i < this.count; _i++) {\n          var progress = this.direction > 0 ? _i / (this.count - 1) : 1 - _i / (this.count - 1);\n          heights[_i] = this.minHeight + progress * heightDiff;\n        }\n      }\n      return heights;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      this.boundary = 200;\n      var heights = this.calculateHeights();\n\n      // Calculate total pattern height for scaling\n      var totalHeight = (this.count - 1) * this.spacing + heights.reduce(function (sum, h) {\n        return sum + h;\n      }, 0);\n\n      // Scale to fit within boundary\n      var scale = Math.min(1, this.boundary / totalHeight);\n\n      // Calculate scaled dimensions\n      var scaledTotalHeight = totalHeight * scale;\n      var scaledSpacing = this.spacing * scale;\n\n      // Start from vertical center\n      var currentY = -scaledTotalHeight / 2;\n\n      // Generate rectangles\n      var rects = heights.map(function (height) {\n        var scaledHeight = height * scale;\n        var rect = \"<rect \\n                x=\\\"\".concat(-_this.width / 2, \"\\\"\\n                y=\\\"\").concat(currentY, \"\\\"\\n                width=\\\"\").concat(_this.width, \"\\\"\\n                height=\\\"\").concat(scaledHeight, \"\\\"\\n                fill=\\\"\").concat(_this.mode === 'fill' ? 'white' : 'none', \"\\\"\\n                stroke=\\\"\").concat(_this.mode === 'stroke' ? 'white' : 'none', \"\\\"\\n                stroke-width=\\\"\").concat(_this.mode === 'stroke' ? _this.thickness : 0, \"\\\"\\n            />\");\n        currentY += scaledHeight + scaledSpacing;\n        return rect;\n      });\n      return rects.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(HorizontalRects, \"parameters\", {\n  count: {\n    min: 3,\n    max: 12,\n    \"default\": 5\n  },\n  spacing: {\n    min: 5,\n    max: 50,\n    \"default\": 24\n  },\n  width: {\n    min: 100,\n    max: 200,\n    \"default\": 169\n  },\n  direction: {\n    min: -1,\n    max: 1,\n    \"default\": 0.9,\n    step: 0.1\n  },\n  minHeight: {\n    min: 2,\n    max: 20,\n    \"default\": 9\n  },\n  maxHeight: {\n    min: 20,\n    max: 80,\n    \"default\": 80\n  },\n  mode: {\n    options: ['fill', 'stroke'],\n    \"default\": 'fill'\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HorizontalRects);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/HorizontalRects.js?");

/***/ }),

/***/ "./src/shapes/Hourglass.js":
/*!*********************************!*\
  !*** ./src/shapes/Hourglass.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar HourglassShape = /*#__PURE__*/function (_Shape) {\n  function HourglassShape() {\n    _classCallCheck(this, HourglassShape);\n    return _callSuper(this, HourglassShape, arguments);\n  }\n  _inherits(HourglassShape, _Shape);\n  return _createClass(HourglassShape, [{\n    key: \"validateParams\",\n    value: function validateParams(options) {\n      var validated = _objectSpread({}, options);\n\n      // Ensure waist is narrower than ends\n      if ('waistWidth' in options) {\n        var minEndWidth = options.endWidth || this.endWidth;\n        validated.waistWidth = Math.min(options.waistWidth, minEndWidth - 20 // Ensure at least 20% difference\n        );\n      }\n\n      // Ensure ends are wider than waist\n      if ('endWidth' in options) {\n        validated.endWidth = Math.max(options.endWidth, (options.waistWidth || this.waistWidth) + 20);\n      }\n      return validated;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.waistWidth = this.waistWidth / 100;\n      this.endWidth = this.endWidth / 100;\n      this.rounding = this.rounding / 100;\n      var size = 150;\n      var halfSize = size / 2;\n\n      // Base points for the hourglass (centered waist)\n      var points = [{\n        x: -halfSize * this.endWidth,\n        y: -halfSize\n      },\n      // Top left\n      {\n        x: -halfSize * this.waistWidth,\n        y: 0\n      },\n      // Waist left\n      {\n        x: -halfSize * this.endWidth,\n        y: halfSize\n      },\n      // Bottom left\n      {\n        x: halfSize * this.endWidth,\n        y: halfSize\n      },\n      // Bottom right\n      {\n        x: halfSize * this.waistWidth,\n        y: 0\n      },\n      // Waist right\n      {\n        x: halfSize * this.endWidth,\n        y: -halfSize\n      } // Top right\n      ];\n\n      // If no rounding, return straight path\n      if (this.rounding === 0) {\n        return \"<path d=\\\"\".concat(points.map(function (p, i) {\n          return (i === 0 ? 'M' : 'L') + \" \".concat(p.x, \" \").concat(p.y);\n        }).join(''), \" Z\\\" fill=\\\"white\\\" />\");\n      }\n\n      // Calculate maximum allowed corner radius based on smallest segment\n      var minSegmentLength = Math.min(Math.abs(points[0].y - points[1].y), Math.abs(points[1].y - points[2].y));\n      var maxRadius = minSegmentLength * 0.5;\n      var cornerRadius = maxRadius * this.rounding;\n\n      // Generate rounded corners path\n      var path = \"M \".concat(points[0].x, \" \").concat(points[0].y);\n      for (var i = 0; i < points.length; i++) {\n        var current = points[i];\n        var next = points[(i + 1) % points.length];\n        var prev = points[i === 0 ? points.length - 1 : i - 1];\n\n        // Calculate vectors\n        var toPrev = {\n          x: prev.x - current.x,\n          y: prev.y - current.y\n        };\n        var toNext = {\n          x: next.x - current.x,\n          y: next.y - current.y\n        };\n\n        // Normalize vectors\n        var toPrevLength = Math.sqrt(toPrev.x * toPrev.x + toPrev.y * toPrev.y);\n        var toNextLength = Math.sqrt(toNext.x * toNext.x + toNext.y * toNext.y);\n        var normPrev = {\n          x: toPrev.x / toPrevLength,\n          y: toPrev.y / toPrevLength\n        };\n        var normNext = {\n          x: toNext.x / toNextLength,\n          y: toNext.y / toNextLength\n        };\n\n        // Calculate control points\n        var cp1 = {\n          x: current.x + normPrev.x * cornerRadius,\n          y: current.y + normPrev.y * cornerRadius\n        };\n        var cp2 = {\n          x: current.x + normNext.x * cornerRadius,\n          y: current.y + normNext.y * cornerRadius\n        };\n\n        // Add to path\n        path += \" L \".concat(cp1.x, \" \").concat(cp1.y);\n        path += \" Q \".concat(current.x, \" \").concat(current.y, \" \").concat(cp2.x, \" \").concat(cp2.y);\n      }\n      return \"<path d=\\\"\".concat(path, \" Z\\\" fill=\\\"white\\\" />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(HourglassShape, \"parameters\", {\n  waistWidth: {\n    min: 0,\n    max: 100,\n    \"default\": 30\n  },\n  endWidth: {\n    min: 25,\n    max: 100,\n    \"default\": 80\n  },\n  rounding: {\n    min: 0,\n    max: 100,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HourglassShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Hourglass.js?");

/***/ }),

/***/ "./src/shapes/HourglassEllipse.js":
/*!****************************************!*\
  !*** ./src/shapes/HourglassEllipse.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar HourglassEllipseShape = /*#__PURE__*/function (_Shape) {\n  function HourglassEllipseShape() {\n    _classCallCheck(this, HourglassEllipseShape);\n    return _callSuper(this, HourglassEllipseShape, arguments);\n  }\n  _inherits(HourglassEllipseShape, _Shape);\n  return _createClass(HourglassEllipseShape, [{\n    key: \"validateParams\",\n    value: function validateParams(options) {\n      var validated = _objectSpread({}, options);\n\n      // Ensure waist width is appropriate\n      if ('waistWidth' in options) {\n        validated.waistWidth = Math.min(options.waistWidth, options.endWidth || this.endWidth);\n      }\n      return validated;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Convert percentages to actual values\n      this.waistWidth = this.waistWidth / 100;\n      this.waistHeight = this.waistHeight / 100;\n      this.endWidth = this.endWidth / 100;\n      var size = 150;\n      var halfSize = size / 2;\n\n      // Calculate dimensions\n      var endWidth = halfSize * this.endWidth;\n      var ellipseRx = halfSize * this.waistWidth;\n      var ellipseRy = halfSize * this.waistHeight;\n      var triangleHeight = halfSize - ellipseRy;\n\n      // Generate the shape combining paths and ellipse\n      return \"\\n            <path d=\\\"M \".concat(-endWidth, \" \").concat(-halfSize, \" \\n                     L 0 \").concat(-ellipseRy, \"\\n                     L \").concat(endWidth, \" \").concat(-halfSize, \" Z\\\" \\n                  fill=\\\"white\\\" />\\n            <ellipse cx=\\\"0\\\" cy=\\\"0\\\" \\n                     rx=\\\"\").concat(ellipseRx, \"\\\" ry=\\\"\").concat(ellipseRy, \"\\\" \\n                     fill=\\\"white\\\" />\\n            <path d=\\\"M \").concat(-endWidth, \" \").concat(halfSize, \"\\n                     L 0 \").concat(ellipseRy, \"\\n                     L \").concat(endWidth, \" \").concat(halfSize, \" Z\\\" \\n                  fill=\\\"white\\\" />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(HourglassEllipseShape, \"parameters\", {\n  waistWidth: {\n    min: 10,\n    max: 100,\n    \"default\": 60\n  },\n  // Width of the ellipse\n  waistHeight: {\n    min: 10,\n    max: 100,\n    \"default\": 30\n  },\n  // Height of the ellipse\n  endWidth: {\n    min: 25,\n    max: 100,\n    \"default\": 80\n  } // Width of triangular ends\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HourglassEllipseShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/HourglassEllipse.js?");

/***/ }),

/***/ "./src/shapes/IncreasingRadialShape.js":
/*!*********************************************!*\
  !*** ./src/shapes/IncreasingRadialShape.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar IncreasingRadialShape = /*#__PURE__*/function (_Shape) {\n  function IncreasingRadialShape() {\n    _classCallCheck(this, IncreasingRadialShape);\n    return _callSuper(this, IncreasingRadialShape, arguments);\n  }\n  _inherits(IncreasingRadialShape, _Shape);\n  return _createClass(IncreasingRadialShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var startAngle = -Math.PI / 2 + this.rotation * Math.PI / 180; // Start from top\n      var spreadRad = this.spread * Math.PI / 180;\n      for (var i = 0; i < this.lineCount; i++) {\n        // Calculate progression (0 to 1)\n        var progress = i / (this.lineCount - 1);\n\n        // Calculate angle using spread parameter\n        var angle = startAngle + spreadRad * progress;\n\n        // Calculate increasing radius (kept constant for perfect circle)\n        var radius = this.minRadius;\n\n        // Calculate start point (always at center)\n        var x1 = 0;\n        var y1 = 0;\n\n        // Calculate end point\n        var x2 = radius * Math.cos(angle);\n        var y2 = radius * Math.sin(angle);\n\n        // Calculate increasing thickness\n        var thickness = this.minThickness + (this.maxThickness - this.minThickness) * progress;\n        lines.push(\"<line \\n                x1=\\\"\".concat(x1, \"\\\" \\n                y1=\\\"\").concat(y1, \"\\\" \\n                x2=\\\"\").concat(x2, \"\\\" \\n                y2=\\\"\").concat(y2, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(IncreasingRadialShape, \"parameters\", {\n  minRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  lineCount: {\n    min: 4,\n    max: 72,\n    \"default\": 26\n  },\n  minThickness: {\n    min: 1,\n    max: 10,\n    \"default\": 1\n  },\n  maxThickness: {\n    min: 1,\n    max: 20,\n    \"default\": 13\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'butt'\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  // Overall rotation\n  spread: {\n    min: 0,\n    max: 360,\n    \"default\": 360\n  } // How far lines spread around circle\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IncreasingRadialShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/IncreasingRadialShape.js?");

/***/ }),

/***/ "./src/shapes/Keyhole.js":
/*!*******************************!*\
  !*** ./src/shapes/Keyhole.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar KeyholeShape = /*#__PURE__*/function (_Shape) {\n  function KeyholeShape() {\n    _classCallCheck(this, KeyholeShape);\n    return _callSuper(this, KeyholeShape, arguments);\n  }\n  _inherits(KeyholeShape, _Shape);\n  return _createClass(KeyholeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var shapes = [];\n\n      // Generate the outer circular top part\n      shapes.push(\"<circle \\n            cx=\\\"\".concat(this.circleOffset, \"\\\" \\n            cy=\\\"\").concat(-this.slotLength / 2, \"\\\" \\n            r=\\\"\").concat(this.circleRadius, \"\\\"\\n            fill=\\\"white\\\"\\n        />\"));\n\n      // Inner circle (hole)\n      if (this.innerCircleRadius > 0) {\n        shapes.push(\"<circle \\n                cx=\\\"\".concat(this.circleOffset, \"\\\" \\n                cy=\\\"\").concat(-this.slotLength / 2, \"\\\" \\n                r=\\\"\").concat(this.innerCircleRadius, \"\\\"\\n                fill=\\\"black\\\"\\n            />\"));\n      }\n\n      // Generate the straight slot using a path\n      var slotPath = \"\\n            M \".concat(-this.slotTopWidth / 2 + this.circleOffset, \" \").concat(-this.slotLength / 2, \"\\n            L \").concat(-this.slotBottomWidth / 2, \" \").concat(this.slotLength / 2, \"\\n            L \").concat(this.slotBottomWidth / 2, \" \").concat(this.slotLength / 2, \"\\n            L \").concat(this.slotTopWidth / 2 + this.circleOffset, \" \").concat(-this.slotLength / 2, \"\\n            Z\");\n      shapes.push(\"<path \\n            d=\\\"\".concat(slotPath, \"\\\"\\n            fill=\\\"white\\\"\\n        />\"));\n      return shapes.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(KeyholeShape, \"parameters\", {\n  circleRadius: {\n    min: 10,\n    max: 50,\n    \"default\": 40\n  },\n  slotLength: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  slotTopWidth: {\n    min: 5,\n    max: 50,\n    \"default\": 20\n  },\n  slotBottomWidth: {\n    min: 5,\n    max: 50,\n    \"default\": 30\n  },\n  circleOffset: {\n    min: -30,\n    max: 30,\n    \"default\": 0\n  },\n  innerCircleRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 25\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyholeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Keyhole.js?");

/***/ }),

/***/ "./src/shapes/KochCurve.js":
/*!*********************************!*\
  !*** ./src/shapes/KochCurve.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar KochCurve = /*#__PURE__*/function (_Shape) {\n  function KochCurve() {\n    _classCallCheck(this, KochCurve);\n    return _callSuper(this, KochCurve, arguments);\n  }\n  _inherits(KochCurve, _Shape);\n  return _createClass(KochCurve, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var startSize = this.baseSize;\n\n      // Create base shape - an equilateral triangle\n      var height = startSize * Math.sqrt(3) / 2;\n      var startPoints = [{\n        x: -startSize / 2,\n        y: height / 3\n      }, {\n        x: startSize / 2,\n        y: height / 3\n      }, {\n        x: 0,\n        y: -height * 2 / 3\n      }];\n\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n\n      // Generate the Koch snowflake\n      var paths = [];\n      for (var i = 0; i < 3; i++) {\n        var start = startPoints[i];\n        var end = startPoints[(i + 1) % 3];\n        var segmentPoints = this.generateKochSegment(start.x, start.y, end.x, end.y, this.iterations, this.outwardFactor, this.segmentRatio);\n        var pathData = \"M \".concat(segmentPoints[0].x, \" \").concat(segmentPoints[0].y);\n        if (this.roundness > 0 && segmentPoints.length > 2) {\n          // Create a smoother curve if roundness is enabled\n          for (var j = 1; j < segmentPoints.length - 1; j++) {\n            var cp1 = segmentPoints[j];\n            var p2 = segmentPoints[j + 1];\n            var prevPoint = segmentPoints[j - 1];\n            var curPoint = segmentPoints[j];\n            var nextPoint = segmentPoints[j + 1];\n\n            // Blend between straight lines and curves based on roundness\n            if (this.roundness > 0) {\n              var tension = this.roundness * 0.4;\n              var dx1 = curPoint.x - prevPoint.x;\n              var dy1 = curPoint.y - prevPoint.y;\n              var dx2 = nextPoint.x - curPoint.x;\n              var dy2 = nextPoint.y - curPoint.y;\n              var cp1x = curPoint.x - dx1 * tension;\n              var cp1y = curPoint.y - dy1 * tension;\n              var cp2x = curPoint.x + dx2 * tension;\n              var cp2y = curPoint.y + dy2 * tension;\n              pathData += \" C \".concat(cp1x, \",\").concat(cp1y, \" \").concat(cp2x, \",\").concat(cp2y, \" \").concat(nextPoint.x, \",\").concat(nextPoint.y);\n              j++; // Skip the next point as we've already used it\n            } else {\n              pathData += \" L \".concat(curPoint.x, \",\").concat(curPoint.y);\n            }\n          }\n\n          // Add the last point if we haven't already\n          if (segmentPoints.length % 2 === 0) {\n            var lastPoint = segmentPoints[segmentPoints.length - 1];\n            pathData += \" L \".concat(lastPoint.x, \",\").concat(lastPoint.y);\n          }\n        } else {\n          // Use straight lines\n          for (var _j = 1; _j < segmentPoints.length; _j++) {\n            pathData += \" L \".concat(segmentPoints[_j].x, \",\").concat(segmentPoints[_j].y);\n          }\n        }\n        paths.push(pathData);\n      }\n      return \"<path \\n            d=\\\"\".concat(paths.join(' '), \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }, {\n    key: \"generateKochSegment\",\n    value: function generateKochSegment(x1, y1, x2, y2, depth, outwardFactor, segmentRatio) {\n      if (depth <= 0) {\n        return [{\n          x: x1,\n          y: y1\n        }, {\n          x: x2,\n          y: y2\n        }];\n      }\n\n      // Calculate the points\n      var points = [];\n\n      // First point\n      points.push({\n        x: x1,\n        y: y1\n      });\n\n      // Koch curve construction\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var dist = Math.sqrt(dx * dx + dy * dy);\n\n      // Calculate segment ratio\n      var baseRatio = segmentRatio;\n\n      // Point at 1/3 of the distance\n      var p1x = x1 + dx * baseRatio;\n      var p1y = y1 + dy * baseRatio;\n\n      // Point at 2/3 of the distance\n      var p3x = x1 + dx * (1 - baseRatio);\n      var p3y = y1 + dy * (1 - baseRatio);\n\n      // The apex of the equilateral triangle\n      var angle = Math.atan2(dy, dx) - Math.PI / 2; // Perpendicular to the line\n      var apexDist = dist * baseRatio * outwardFactor;\n      var p2x = (p1x + p3x) / 2 + Math.cos(angle) * apexDist;\n      var p2y = (p1y + p3y) / 2 + Math.sin(angle) * apexDist;\n\n      // Recursively compute the four line segments\n      var segment1 = this.generateKochSegment(x1, y1, p1x, p1y, depth - 1, outwardFactor, segmentRatio);\n      var segment2 = this.generateKochSegment(p1x, p1y, p2x, p2y, depth - 1, outwardFactor, segmentRatio);\n      var segment3 = this.generateKochSegment(p2x, p2y, p3x, p3y, depth - 1, outwardFactor, segmentRatio);\n      var segment4 = this.generateKochSegment(p3x, p3y, x2, y2, depth - 1, outwardFactor, segmentRatio);\n\n      // Combine segments (avoid duplicates)\n      points.push.apply(points, _toConsumableArray(segment1.slice(1)));\n      points.push.apply(points, _toConsumableArray(segment2.slice(1)));\n      points.push.apply(points, _toConsumableArray(segment3.slice(1)));\n      points.push.apply(points, _toConsumableArray(segment4.slice(1)));\n      return points;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(KochCurve, \"parameters\", {\n  iterations: {\n    min: 1,\n    max: 5,\n    \"default\": 3\n  },\n  baseSize: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  outwardFactor: {\n    min: 0.1,\n    max: 1.5,\n    \"default\": 0.58\n  },\n  segmentRatio: {\n    min: 0.25,\n    max: 0.45,\n    \"default\": 0.33\n  },\n  roundness: {\n    min: 0,\n    max: 1,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 8,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KochCurve);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/KochCurve.js?");

/***/ }),

/***/ "./src/shapes/LanternShape.js":
/*!************************************!*\
  !*** ./src/shapes/LanternShape.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LanternShape = /*#__PURE__*/function (_Shape) {\n  function LanternShape() {\n    _classCallCheck(this, LanternShape);\n    return _callSuper(this, LanternShape, arguments);\n  }\n  _inherits(LanternShape, _Shape);\n  return _createClass(LanternShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Generate center circle with outline instead of fill\n      var circle = \"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(this.radius, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n        />\");\n\n      // Calculate positions for left and right arcs with gap consideration\n      var leftArc = this.createArc(-90 + this.arcStart, this.arcLength, -this.gap / 2);\n      var rightArc = this.createArc(90 + this.arcStart, this.arcLength, this.gap / 2);\n      return \"\\n            \".concat(circle, \"\\n            \").concat(leftArc, \"\\n            \").concat(rightArc, \"\\n        \");\n    }\n  }, {\n    key: \"createArc\",\n    value: function createArc(baseAngle, arcLength, offset) {\n      var startAngle = (baseAngle - arcLength / 2) * (Math.PI / 180);\n      var endAngle = (baseAngle + arcLength / 2) * (Math.PI / 180);\n\n      // Add offset to arc position\n      var arcCenterX = offset;\n      var startX = arcCenterX + this.arcRadius * Math.cos(startAngle);\n      var startY = this.arcRadius * Math.sin(startAngle);\n      var endX = arcCenterX + this.arcRadius * Math.cos(endAngle);\n      var endY = this.arcRadius * Math.sin(endAngle);\n      var largeArcFlag = arcLength > 180 ? 1 : 0;\n      return \"<path \\n            d=\\\"M \".concat(startX, \" \").concat(startY, \" A \").concat(this.arcRadius, \" \").concat(this.arcRadius, \" 0 \").concat(largeArcFlag, \" 1 \").concat(endX, \" \").concat(endY, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            fill=\\\"none\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LanternShape, \"parameters\", {\n  radius: {\n    min: 20,\n    max: 100,\n    \"default\": 31\n  },\n  arcRadius: {\n    min: 30,\n    max: 120,\n    \"default\": 51\n  },\n  thickness: {\n    min: 1,\n    max: 20,\n    \"default\": 8\n  },\n  arcStart: {\n    min: -90,\n    max: 90,\n    \"default\": -90\n  },\n  arcLength: {\n    min: 10,\n    max: 180,\n    \"default\": 60\n  },\n  gap: {\n    min: 0,\n    max: 100,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LanternShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LanternShape.js?");

/***/ }),

/***/ "./src/shapes/LayeredBlob.js":
/*!***********************************!*\
  !*** ./src/shapes/LayeredBlob.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LayeredBlobShape = /*#__PURE__*/function (_Shape) {\n  function LayeredBlobShape() {\n    _classCallCheck(this, LayeredBlobShape);\n    return _callSuper(this, LayeredBlobShape, arguments);\n  }\n  _inherits(LayeredBlobShape, _Shape);\n  return _createClass(LayeredBlobShape, [{\n    key: \"_toRad\",\n    value: function _toRad(deg) {\n      return deg * (Math.PI / 180.0);\n    }\n  }, {\n    key: \"_divide\",\n    value: function _divide(count) {\n      // Ensure count is a positive integer\n      var safeCount = Math.max(1, Math.floor(count));\n      var deg = 360 / safeCount;\n      return Array(safeCount).fill(0).map(function (_, i) {\n        return i * deg;\n      });\n    }\n  }, {\n    key: \"_randomDoubleGenerator\",\n    value: function _randomDoubleGenerator(s) {\n      var mask = 0xffffffff;\n      var m_w = 123456789 + s & mask;\n      var m_z = 987654321 - s & mask;\n      return function () {\n        m_z = 36969 * (m_z & 65535) + (m_z >>> 16) & mask;\n        m_w = 18000 * (m_w & 65535) + (m_w >>> 16) & mask;\n        var result = (m_z << 16) + (m_w & 65535) >>> 0;\n        result /= 4294967296;\n        return result;\n      };\n    }\n  }, {\n    key: \"_magicPoint\",\n    value: function _magicPoint(value, min, max) {\n      var radius = min + value * (max - min);\n      if (radius > max) {\n        radius = radius - min;\n      } else if (radius < min) {\n        radius = radius + min;\n      }\n      return radius;\n    }\n  }, {\n    key: \"_point\",\n    value: function _point(origin, radius, degree) {\n      var skewRad = this._toRad(this.skew);\n      var angle = this._toRad(degree) + skewRad;\n      var x = origin + radius * Math.cos(angle);\n      var y = origin + radius * Math.sin(angle);\n      return [Math.round(x), Math.round(y)];\n    }\n  }, {\n    key: \"_createPoints\",\n    value: function _createPoints(size, minGrowth, edgesCount, seed) {\n      var _this = this;\n      // Ensure edgesCount is valid\n      var safeEdgesCount = Math.max(3, Math.floor(edgesCount));\n      var outerRad = Math.max(1, size / 2);\n      var innerRad = Math.max(1, minGrowth * (outerRad / 10));\n      var center = 0; // Centered at origin for SVG viewBox\n      var slices = this._divide(safeEdgesCount);\n      var seedValue = seed || Math.floor(this.random() * 99999);\n      var randVal = this._randomDoubleGenerator(seedValue);\n      return slices.map(function (degree) {\n        var radius = _this._magicPoint(randVal(), innerRad, outerRad);\n        return _this._point(center, radius, degree);\n      });\n    }\n  }, {\n    key: \"_createSvgPath\",\n    value: function _createSvgPath(points) {\n      var svgPath = '';\n      var mid = [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2];\n      svgPath += \"M\".concat(mid[0], \",\").concat(mid[1]);\n      for (var i = 0; i < points.length; i++) {\n        var p1 = points[(i + 1) % points.length];\n        var p2 = points[(i + 2) % points.length];\n        var nextMid = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\n        svgPath += \"Q\".concat(p1[0], \",\").concat(p1[1], \",\").concat(nextMid[0], \",\").concat(nextMid[1]);\n      }\n      return svgPath + 'Z';\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var baseSize = 100;\n\n      // Ensure layers is valid\n      var safeLayers = Math.max(1, Math.min(5, Math.floor(this.layers)));\n\n      // Generate multiple layers with decreasing size\n      for (var i = 0; i < safeLayers; i++) {\n        var size = Math.max(10, baseSize * (1 - i * 0.2));\n        var points = this._createPoints(size * 2, this.growth, this.edges, i);\n        var pathString = this._createSvgPath(points);\n        paths.push(\"<path \\n                d=\\\"\".concat(pathString, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            />\"));\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredBlobShape, \"parameters\", {\n  edges: {\n    min: 3,\n    max: 12,\n    \"default\": 5\n  },\n  layers: {\n    min: 1,\n    max: 5,\n    \"default\": 5\n  },\n  growth: {\n    min: 2,\n    max: 10,\n    \"default\": 6\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 5\n  },\n  skew: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredBlobShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredBlob.js?");

/***/ }),

/***/ "./src/shapes/LayeredBlobsMaskShape.js":
/*!*********************************************!*\
  !*** ./src/shapes/LayeredBlobsMaskShape.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LayeredBlobsMaskShape = /*#__PURE__*/function (_Shape) {\n  function LayeredBlobsMaskShape() {\n    _classCallCheck(this, LayeredBlobsMaskShape);\n    return _callSuper(this, LayeredBlobsMaskShape, arguments);\n  }\n  _inherits(LayeredBlobsMaskShape, _Shape);\n  return _createClass(LayeredBlobsMaskShape, [{\n    key: \"toRad\",\n    value: function toRad(deg) {\n      return deg * (Math.PI / 180.0);\n    }\n  }, {\n    key: \"divide\",\n    value: function divide(count) {\n      var deg = 360.0 / count;\n      return Array.from({\n        length: count\n      }, function (_, i) {\n        return i * deg;\n      });\n    }\n  }, {\n    key: \"randomDouble\",\n    value: function randomDouble(seed) {\n      var mask = 0xffffffff;\n      var m_w = 123456789 + seed & mask;\n      var m_z = 987654321 - seed & mask;\n      return function () {\n        m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;\n        m_w = 18000 * (m_w & 65535) + (m_w >> 16) & mask;\n        var result = (m_z << 16) + (m_w & 65535) >> 0;\n        return result / 0xffffffff;\n      };\n    }\n  }, {\n    key: \"magicPoint\",\n    value: function magicPoint(value, min, max) {\n      // Base radius calculation\n      var radius = min + value * (max - min);\n      if (this.amplitude > 0) {\n        // Calculate wave effects\n        var range = max - min;\n        var safeAmplitude = Math.min(this.amplitude, 4.5); // Cap amplitude to prevent extreme values\n\n        var primaryWave = Math.sin(this.currentAngle * this.frequency) * safeAmplitude * range * 0.4;\n        var secondaryWave = Math.sin(this.currentAngle * this.frequency * 2.7) * safeAmplitude * range * 0.15;\n        var tertiaryWave = Math.sin(this.currentAngle * this.frequency * 0.5) * safeAmplitude * range * 0.1;\n\n        // Add waves to radius with safety factor\n        radius += primaryWave + secondaryWave + tertiaryWave;\n      }\n\n      // Proper bounds handling - ensure radius stays within valid range\n      if (radius > max) {\n        radius = max; // Simply cap at maximum\n      } else if (radius < min) {\n        radius = min; // Simply cap at minimum\n      }\n      return radius;\n    }\n  }, {\n    key: \"point\",\n    value: function point(centerX, centerY, radius, degree) {\n      var skewRad = this.toRad(this.skew);\n      var angle = this.toRad(degree) + skewRad;\n      var x = centerX + radius * Math.cos(angle);\n      var y = centerY + radius * Math.sin(angle);\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"createPoints\",\n    value: function createPoints(size, minGrowth, edgesCount, seed) {\n      var _this = this;\n      var outerRad = size / 2;\n      var innerRad = minGrowth * (outerRad / 10);\n      var centerX = 0;\n      var centerY = 0;\n      var slices = this.divide(edgesCount);\n      var randVal = this.randomDouble(seed || this.seed);\n      return slices.map(function (degree) {\n        _this.currentAngle = _this.toRad(degree);\n        var radius = _this.magicPoint(randVal(), innerRad, outerRad);\n        return _this.point(centerX, centerY, radius, degree);\n      });\n    }\n  }, {\n    key: \"generateBlobPath\",\n    value: function generateBlobPath() {\n      var points = this.createPoints(this.radius * 2, this.growth, this.edges, this.seed);\n      if (points.length < 3) {\n        // Ensure we have enough points for a valid shape\n        return \"M0,\".concat(-this.radius, \" A\").concat(this.radius, \",\").concat(this.radius, \" 0 1,1 0,\").concat(this.radius, \" A\").concat(this.radius, \",\").concat(this.radius, \" 0 1,1 0,\").concat(-this.radius);\n      }\n      try {\n        // Generate path with proper error handling\n        var pathCommands = [];\n\n        // Calculate first midpoint safely\n        var start = {\n          x: (points[0].x + points[1].x) / 2,\n          y: (points[0].y + points[1].y) / 2\n        };\n        pathCommands.push(\"M\".concat(start.x.toFixed(2), \",\").concat(start.y.toFixed(2)));\n        for (var i = 0; i < points.length; i++) {\n          var p1 = points[(i + 1) % points.length];\n          var p2 = points[(i + 2) % points.length];\n\n          // Ensure all points are valid\n          if (isNaN(p1.x) || isNaN(p1.y) || isNaN(p2.x) || isNaN(p2.y)) {\n            continue;\n          }\n          var mid = {\n            x: (p1.x + p2.x) / 2,\n            y: (p1.y + p2.y) / 2\n          };\n          pathCommands.push(\"Q\".concat(p1.x.toFixed(2), \",\").concat(p1.y.toFixed(2), \",\").concat(mid.x.toFixed(2), \",\").concat(mid.y.toFixed(2)));\n        }\n        pathCommands.push('Z');\n        return pathCommands.join('');\n      } catch (error) {\n        // Fallback to a circle if path generation fails\n        return \"M0,\".concat(-this.radius, \" A\").concat(this.radius, \",\").concat(this.radius, \" 0 1,1 0,\").concat(this.radius, \" A\").concat(this.radius, \",\").concat(this.radius, \" 0 1,1 0,\").concat(-this.radius);\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Create unique IDs for the SVG elements\n      var outerClipId = \"outerClip_\".concat(Math.floor(this.random() * 1000000));\n      var innerClipId = \"innerClip_\".concat(Math.floor(this.random() * 1000000));\n\n      // Generate the blob path for the outer boundary\n      var blobPathData = this.generateBlobPath();\n\n      // Define the SVG elements\n      var elements = [];\n\n      // Definitions section\n      elements.push('<defs>');\n\n      // Clip path for the blob shape (outer boundary)\n      elements.push(\"<clipPath id=\\\"\".concat(outerClipId, \"\\\">\"));\n      elements.push(\"<path d=\\\"\".concat(blobPathData, \"\\\" />\"));\n      elements.push('</clipPath>');\n\n      // Create a \"donut\" shape that clips out the inner circle\n      elements.push(\"<clipPath id=\\\"\".concat(innerClipId, \"\\\">\"));\n      elements.push(\"<path d=\\\"\".concat(blobPathData, \"\\\" />\"));\n      elements.push(\"<circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\".concat(this.innerRadius, \"\\\" fill=\\\"black\\\" />\"));\n      elements.push('</clipPath>');\n      elements.push('</defs>');\n\n      // Generate the lines with both clipping paths applied\n      // This results in lines visible only in the \"donut\" area between inner and outer boundaries\n      elements.push(\"<g clip-path=\\\"url(#\".concat(innerClipId, \")\\\">\"));\n\n      // Generate radial lines extending beyond the blob\n      var angleStep = 2 * Math.PI / this.lines;\n      var skewRad = this.skew * Math.PI / 180;\n      for (var i = 0; i < this.lines; i++) {\n        var angle = i * angleStep;\n        var skewedAngle = angle + skewRad;\n\n        // Extended line from origin to beyond the blob boundary\n        var x2 = Math.cos(skewedAngle) * this.radius * 2;\n        var y2 = Math.sin(skewedAngle) * this.radius * 2;\n        elements.push(\"<line \\n                x1=\\\"0\\\" \\n                y1=\\\"0\\\" \\n                x2=\\\"\".concat(x2, \"\\\" \\n                y2=\\\"\").concat(y2, \"\\\" \\n                stroke=\\\"white\\\" \\n                stroke-width=\\\"\").concat(this.thickness, \"\\\" \\n            />\"));\n      }\n      elements.push('</g>');\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredBlobsMaskShape, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 120\n  },\n  innerRadius: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  lines: {\n    min: 30,\n    max: 300,\n    \"default\": 100\n  },\n  edges: {\n    min: 4,\n    max: 16,\n    \"default\": 10\n  },\n  growth: {\n    min: 3,\n    max: 6,\n    \"default\": 5\n  },\n  amplitude: {\n    min: 0,\n    max: 5,\n    \"default\": 5\n  },\n  frequency: {\n    min: 0.5,\n    max: 4,\n    \"default\": 6.0\n  },\n  thickness: {\n    min: 1,\n    max: 3,\n    \"default\": 1\n  },\n  skew: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredBlobsMaskShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredBlobsMaskShape.js?");

/***/ }),

/***/ "./src/shapes/LayeredChevron.js":
/*!**************************************!*\
  !*** ./src/shapes/LayeredChevron.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LayeredChevron = /*#__PURE__*/function (_Shape) {\n  function LayeredChevron() {\n    _classCallCheck(this, LayeredChevron);\n    return _callSuper(this, LayeredChevron, arguments);\n  }\n  _inherits(LayeredChevron, _Shape);\n  return _createClass(LayeredChevron, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var baseSize = 100;\n      for (var layer = 0; layer < this.layers; layer++) {\n        var currentSize = baseSize - layer * this.spacing;\n        if (currentSize <= 0) continue;\n\n        // Calculate chevron points\n        var top = {\n          x: center.x,\n          y: center.y - currentSize\n        };\n        var bottomLeft = {\n          x: center.x - currentSize,\n          y: center.y + currentSize\n        };\n        var bottomRight = {\n          x: center.x + currentSize,\n          y: center.y + currentSize\n        };\n        var leftPoint = {\n          x: center.x - currentSize * this.pointiness,\n          y: center.y\n        };\n        var rightPoint = {\n          x: center.x + currentSize * this.pointiness,\n          y: center.y\n        };\n\n        // Draw left side of chevron\n        lines.push(\"<line \\n                x1=\\\"\".concat(top.x, \"\\\" \\n                y1=\\\"\").concat(top.y, \"\\\" \\n                x2=\\\"\").concat(leftPoint.x, \"\\\" \\n                y2=\\\"\").concat(leftPoint.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n        lines.push(\"<line \\n                x1=\\\"\".concat(leftPoint.x, \"\\\" \\n                y1=\\\"\").concat(leftPoint.y, \"\\\" \\n                x2=\\\"\").concat(bottomLeft.x, \"\\\" \\n                y2=\\\"\").concat(bottomLeft.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n\n        // Draw right side of chevron\n        lines.push(\"<line \\n                x1=\\\"\".concat(top.x, \"\\\" \\n                y1=\\\"\").concat(top.y, \"\\\" \\n                x2=\\\"\").concat(rightPoint.x, \"\\\" \\n                y2=\\\"\").concat(rightPoint.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n        lines.push(\"<line \\n                x1=\\\"\".concat(rightPoint.x, \"\\\" \\n                y1=\\\"\").concat(rightPoint.y, \"\\\" \\n                x2=\\\"\").concat(bottomRight.x, \"\\\" \\n                y2=\\\"\").concat(bottomRight.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredChevron, \"parameters\", {\n  layers: {\n    min: 2,\n    max: 8,\n    \"default\": 4\n  },\n  spacing: {\n    min: 10,\n    max: 50,\n    \"default\": 25\n  },\n  pointiness: {\n    min: 0.2,\n    max: 0.8,\n    \"default\": 0.5\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredChevron);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredChevron.js?");

/***/ }),

/***/ "./src/shapes/LayeredCubeShape.js":
/*!****************************************!*\
  !*** ./src/shapes/LayeredCubeShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LayeredCubeShape = /*#__PURE__*/function (_Shape) {\n  function LayeredCubeShape() {\n    _classCallCheck(this, LayeredCubeShape);\n    return _callSuper(this, LayeredCubeShape, arguments);\n  }\n  _inherits(LayeredCubeShape, _Shape);\n  return _createClass(LayeredCubeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var elements = [];\n      var maxSize = this.size;\n\n      // Convert rotation angles to radians\n      var rotX = this.rotationX * Math.PI / 180;\n      var rotY = this.rotationY * Math.PI / 180;\n      var rotZ = this.rotationZ * Math.PI / 180;\n\n      // Define the edges of a cube (pairs of vertex indices)\n      var edges = [[0, 1], [1, 2], [2, 3], [3, 0],\n      // back face\n      [4, 5], [5, 6], [6, 7], [7, 4],\n      // front face\n      [0, 4], [1, 5], [2, 6], [3, 7] // connecting edges\n      ];\n\n      // Create group for all cubes\n      elements.push(\"<g stroke=\\\"white\\\" stroke-width=\\\"\".concat(this.thickness, \"\\\" fill=\\\"none\\\" stroke-linejoin=\\\"round\\\" stroke-linecap=\\\"round\\\">\"));\n\n      // Generate layers from outside to inside\n      var _loop = function _loop() {\n        // Calculate the size for this layer\n        var size = maxSize - layer * _this.spacing * 2;\n\n        // Skip if the layer would be too small\n        if (size <= 0) return 1; // continue\n        var halfSize = size / 2;\n\n        // Define the vertices of a cube centered at origin\n        var vertices = [[-halfSize, -halfSize, -halfSize],\n        // 0: back bottom left\n        [halfSize, -halfSize, -halfSize],\n        // 1: back bottom right\n        [halfSize, halfSize, -halfSize],\n        // 2: back top right\n        [-halfSize, halfSize, -halfSize],\n        // 3: back top left\n        [-halfSize, -halfSize, halfSize],\n        // 4: front bottom left\n        [halfSize, -halfSize, halfSize],\n        // 5: front bottom right\n        [halfSize, halfSize, halfSize],\n        // 6: front top right\n        [-halfSize, halfSize, halfSize] // 7: front top left\n        ];\n\n        // Apply 3D rotations and projection to 2D\n        var projectedVertices = vertices.map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 3),\n            x = _ref2[0],\n            y = _ref2[1],\n            z = _ref2[2];\n          // Apply rotation around X axis (pitch)\n          var x1 = x;\n          var y1 = y * Math.cos(rotX) - z * Math.sin(rotX);\n          var z1 = y * Math.sin(rotX) + z * Math.cos(rotX);\n\n          // Apply rotation around Y axis (yaw)\n          var x2 = x1 * Math.cos(rotY) + z1 * Math.sin(rotY);\n          var y2 = y1;\n          var z2 = -x1 * Math.sin(rotY) + z1 * Math.cos(rotY);\n\n          // Apply rotation around Z axis (roll)\n          var x3 = x2 * Math.cos(rotZ) - y2 * Math.sin(rotZ);\n          var y3 = x2 * Math.sin(rotZ) + y2 * Math.cos(rotZ);\n          var z3 = z2;\n          return {\n            x: Math.round(x3 * 1000) / 1000,\n            y: Math.round(y3 * 1000) / 1000,\n            z: Math.round(z3 * 1000) / 1000\n          };\n        });\n\n        // Sort edges by average z-depth for proper rendering order\n        var sortedEdges = [].concat(edges).sort(function (a, b) {\n          var avgZA = (projectedVertices[a[0]].z + projectedVertices[a[1]].z) / 2;\n          var avgZB = (projectedVertices[b[0]].z + projectedVertices[b[1]].z) / 2;\n          return avgZB - avgZA; // Draw back-to-front\n        });\n\n        // Process edges to form continuous paths\n        var remainingEdges = _toConsumableArray(sortedEdges);\n        var connectedPaths = [];\n        while (remainingEdges.length > 0) {\n          var currentPath = [remainingEdges[0]];\n          remainingEdges.splice(0, 1);\n          var foundConnection = true;\n          while (foundConnection) {\n            foundConnection = false;\n\n            // Look for an edge that connects to the last vertex in our current path\n            var lastEdge = currentPath[currentPath.length - 1];\n            var lastVertex = lastEdge[1];\n            for (var i = 0; i < remainingEdges.length; i++) {\n              // If this edge starts with our last vertex\n              if (remainingEdges[i][0] === lastVertex) {\n                currentPath.push(remainingEdges[i]);\n                remainingEdges.splice(i, 1);\n                foundConnection = true;\n                break;\n              }\n              // If this edge ends with our last vertex (need to reverse it)\n              else if (remainingEdges[i][1] === lastVertex) {\n                currentPath.push([remainingEdges[i][1], remainingEdges[i][0]]);\n                remainingEdges.splice(i, 1);\n                foundConnection = true;\n                break;\n              }\n            }\n          }\n          connectedPaths.push(currentPath);\n        }\n\n        // Draw each connected path\n        for (var _i = 0, _connectedPaths = connectedPaths; _i < _connectedPaths.length; _i++) {\n          var path = _connectedPaths[_i];\n          var pathData = path.map(function (edge, i) {\n            var start = projectedVertices[edge[0]];\n            var end = projectedVertices[edge[1]];\n            return \"\".concat(i === 0 ? 'M' : 'L').concat(start.x, \",\").concat(start.y, \" L\").concat(end.x, \",\").concat(end.y);\n          }).join(' ');\n          elements.push(\"<path d=\\\"\".concat(pathData, \"\\\" />\"));\n        }\n      };\n      for (var layer = 0; layer < this.layers; layer++) {\n        if (_loop()) continue;\n      }\n\n      // Close the group\n      elements.push(\"</g>\");\n      return elements.join('');\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredCubeShape, \"parameters\", {\n  size: {\n    min: 10,\n    max: 100,\n    \"default\": 100\n  },\n  layers: {\n    min: 2,\n    max: 20,\n    \"default\": 5\n  },\n  spacing: {\n    min: 1,\n    max: 20,\n    \"default\": 10\n  },\n  thickness: {\n    min: 0.5,\n    max: 5,\n    \"default\": 3\n  },\n  rotationX: {\n    min: -60,\n    max: 60,\n    \"default\": 45\n  },\n  rotationY: {\n    min: -60,\n    max: 60,\n    \"default\": 45\n  },\n  rotationZ: {\n    min: -60,\n    max: 60,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredCubeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredCubeShape.js?");

/***/ }),

/***/ "./src/shapes/LayeredFlowShape.js":
/*!****************************************!*\
  !*** ./src/shapes/LayeredFlowShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\n/* harmony import */ var _perlin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../perlin.js */ \"./src/perlin.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar LayeredFlowShape = /*#__PURE__*/function (_Shape) {\n  function LayeredFlowShape() {\n    _classCallCheck(this, LayeredFlowShape);\n    return _callSuper(this, LayeredFlowShape, arguments);\n  }\n  _inherits(LayeredFlowShape, _Shape);\n  return _createClass(LayeredFlowShape, [{\n    key: \"getNoise\",\n    value: function getNoise(x, y) {\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      try {\n        var value = _perlin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].noise(x * this.noiseScale + this.seed, y * this.noiseScale + this.seed, z * this.noiseScale + this.seed);\n        return isNaN(value) ? 0 : value;\n      } catch (e) {\n        return 0;\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var rotationRad = this.rotation * Math.PI / 180;\n      var tiltRad = this.tilt * Math.PI / 180;\n      var height = Math.max(1, this.innerRadius * 2);\n      var sliceSpacing = height / Math.max(1, this.layers - 1);\n      for (var i = 0; i < this.layers; i++) {\n        var sliceHeight = -this.innerRadius + i * sliceSpacing;\n        var path = this.generateSlicePath(sliceHeight, rotationRad, tiltRad);\n        if (path) {\n          elements.push(\"<path \\n                    d=\\\"\".concat(path, \"\\\" \\n                    stroke=\\\"white\\\" \\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\" \\n                    fill=\\\"none\\\"\\n                    stroke-linejoin=\\\"round\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\"));\n        }\n      }\n      return elements.join('');\n    }\n  }, {\n    key: \"generateSlicePath\",\n    value: function generateSlicePath(sliceHeight, rotationY, tiltX) {\n      var points = [];\n      var steps = 100;\n      var safeInnerRadius = Math.max(0.1, this.innerRadius);\n      var heightRatio = sliceHeight / safeInnerRadius;\n      var sqrtArg = Math.max(0, 1 - heightRatio * heightRatio);\n      var maxRadius = this.radius * Math.sqrt(sqrtArg);\n      for (var i = 0; i <= steps; i++) {\n        var angle = i / steps * Math.PI * 2;\n        var cos = Math.cos(angle);\n        var sin = Math.sin(angle);\n        var r = maxRadius;\n        var noiseValue = 0;\n        noiseValue += this.getNoise(cos * this.flowFactor, sin * this.flowFactor, heightRatio) * this.noiseStrength;\n        noiseValue += this.getNoise(cos * this.flowFactor * 2.5, sin * this.flowFactor * 2.5, heightRatio * 2) * this.noiseStrength * 0.5;\n        var flowAngle = angle + this.getNoise(cos * 0.5, sin * 0.5, heightRatio * 0.5) * Math.PI * this.heightVariation;\n        var flowCos = Math.cos(flowAngle);\n        var flowSin = Math.sin(flowAngle);\n        noiseValue += this.getNoise(cos + flowCos * 0.5, sin + flowSin * 0.5, heightRatio) * this.noiseStrength * 0.7;\n        var heightFactor = 1 - Math.abs(heightRatio) * (1 - this.heightVariation);\n        r = Math.max(0.1, r * (1 + noiseValue * heightFactor));\n        var x = cos * r;\n        var y = sin * r;\n        var z = sliceHeight;\n        var rotX = x * Math.cos(rotationY) - z * Math.sin(rotationY);\n        var rotZ = x * Math.sin(rotationY) + z * Math.cos(rotationY);\n        var tiltY = y * Math.cos(tiltX) - rotZ * Math.sin(tiltX);\n        var tiltZ = y * Math.sin(tiltX) + rotZ * Math.cos(tiltX);\n        var perspective = 0.001;\n        var denom = 1 - tiltZ * perspective;\n        if (Math.abs(denom) < 0.0001) continue;\n        var projX = rotX / denom;\n        var projY = tiltY / denom;\n        if (isFinite(projX) && isFinite(projY)) {\n          points.push([projX, projY]);\n        }\n      }\n      if (points.length < 3) return '';\n      return this.createPath(points);\n    }\n  }, {\n    key: \"createPath\",\n    value: function createPath(points) {\n      var pathData = '';\n      var validStart = false;\n      for (var i = 0; i < points.length; i++) {\n        if (!isNaN(points[i][0]) && !isNaN(points[i][1])) {\n          if (!validStart) {\n            pathData = \"M\".concat(points[i][0], \",\").concat(points[i][1]);\n            validStart = true;\n          } else {\n            pathData += \" L\".concat(points[i][0], \",\").concat(points[i][1]);\n          }\n        }\n      }\n      if (!validStart) return '';\n      pathData += ' Z';\n      return pathData;\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredFlowShape, \"parameters\", {\n  layers: {\n    min: 5,\n    max: 50,\n    \"default\": 32\n  },\n  radius: {\n    min: 20,\n    max: 80,\n    \"default\": 80\n  },\n  innerRadius: {\n    min: 5,\n    max: 100,\n    \"default\": 53\n  },\n  noiseScale: {\n    min: 0.05,\n    max: 1.0,\n    \"default\": 0.35\n  },\n  noiseStrength: {\n    min: 0.0,\n    max: 1.0,\n    \"default\": 0.60\n  },\n  flowFactor: {\n    min: 0.1,\n    max: 5,\n    \"default\": 3\n  },\n  thickness: {\n    min: 0.5,\n    max: 3,\n    \"default\": 1.20\n  },\n  heightVariation: {\n    min: 0.1,\n    max: 1,\n    \"default\": 0.70\n  },\n  rotation: {\n    min: 0,\n    max: 360,\n    \"default\": 360\n  },\n  tilt: {\n    min: 0,\n    max: 90,\n    \"default\": 33\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredFlowShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredFlowShape.js?");

/***/ }),

/***/ "./src/shapes/LayeredMountains.js":
/*!****************************************!*\
  !*** ./src/shapes/LayeredMountains.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\n/* harmony import */ var _perlin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../perlin.js */ \"./src/perlin.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar LayeredMountains = /*#__PURE__*/function (_Shape) {\n  function LayeredMountains() {\n    _classCallCheck(this, LayeredMountains);\n    return _callSuper(this, LayeredMountains, arguments);\n  }\n  _inherits(LayeredMountains, _Shape);\n  return _createClass(LayeredMountains, [{\n    key: \"getNoise\",\n    value: function getNoise(x, y) {\n      return _perlin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].noise(x * this.noiseScale + this.seed, y * this.noiseScale + this.seed);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var radius = this.radius,\n        layers = this.layers,\n        amplitude = this.amplitude,\n        thickness = this.thickness,\n        curvature = this.curvature;\n\n      // Add circular border\n      elements.push(\"<circle\\n            cx=\\\"0\\\"\\n            cy=\\\"0\\\"\\n            r=\\\"\".concat(radius, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n\n      // Create clipping path\n      var clipId = \"clip-\".concat(Math.floor(Math.random() * 10000));\n      elements.push(\"\\n            <defs>\\n                <clipPath id=\\\"\".concat(clipId, \"\\\">\\n                    <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(radius, \"\\\" />\\n                </clipPath>\\n            </defs>\\n        \"));\n\n      // Container with clipping\n      elements.push(\"<g clip-path=\\\"url(#\".concat(clipId, \")\\\">\"));\n\n      // Create waves that flow across the circle\n      for (var layer = 0; layer < layers; layer++) {\n        // Layer position (vertical offset)\n        var layerOffset = -radius + radius * 2 * (layer + 0.5) / layers;\n\n        // Calculate wave parameters based on layer\n        var layerRatio = layer / (layers - 1);\n        var waveAmplitude = amplitude * (0.5 + layerRatio * 0.5);\n\n        // Create curved path that flows from left to right\n        var pathData = this.generateWavePath(radius, layerOffset, waveAmplitude, curvature, layerRatio);\n        elements.push(\"<path\\n                d=\\\"\".concat(pathData, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      }\n      elements.push(\"</g>\");\n      return elements.join('');\n    }\n  }, {\n    key: \"generateWavePath\",\n    value: function generateWavePath(radius, baseY, amplitude, curvature, layerRatio) {\n      var points = [];\n      var steps = 100;\n      var diameter = radius * 2;\n\n      // Calculate control points for smooth wave\n      // Left edge starting point (outside circle)\n      points.push([-radius * 1.5, baseY]);\n\n      // Calculate midpoints with increasing/decreasing effect\n      for (var i = 0; i <= steps; i++) {\n        var x = -radius + i / steps * diameter;\n        var xRatio = (x + radius) / diameter; // 0 to 1 across the circle\n\n        // Apply curve transformation\n        var curveEffect = Math.sin(xRatio * Math.PI) * curvature;\n\n        // Apply decreasing noise from top to bottom\n        var noiseContribution = this.getNoise(xRatio * 3, layerRatio) * amplitude * (1 - 0.7 * layerRatio);\n\n        // For lower layers, have more upward curve, for upper layers, more downward curve\n        var directionFactor = layerRatio * 2 - 1; // -1 to 1\n        var y = baseY - curveEffect * radius * 0.5 * directionFactor - noiseContribution;\n        points.push([x, y]);\n      }\n\n      // Right edge ending point (outside circle)\n      points.push([radius * 1.5, baseY]);\n\n      // Build SVG path\n      var pathData = \"M\".concat(points[0][0], \",\").concat(points[0][1]);\n\n      // Add points\n      for (var _i = 1; _i < points.length; _i++) {\n        pathData += \" L\".concat(points[_i][0], \",\").concat(points[_i][1]);\n      }\n      return pathData;\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredMountains, \"parameters\", {\n  layers: {\n    min: 3,\n    max: 15,\n    \"default\": 15\n  },\n  radius: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  amplitude: {\n    min: 5,\n    max: 150,\n    \"default\": 150\n  },\n  noiseScale: {\n    min: 0.1,\n    max: 1.5,\n    \"default\": 1.5\n  },\n  seed: {\n    min: 0,\n    max: 1000,\n    \"default\": 42\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  curvature: {\n    min: 0.1,\n    max: 1,\n    \"default\": 0.8\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredMountains);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredMountains.js?");

/***/ }),

/***/ "./src/shapes/LayeredPolygon.js":
/*!**************************************!*\
  !*** ./src/shapes/LayeredPolygon.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LayeredPolygon = /*#__PURE__*/function (_Shape) {\n  function LayeredPolygon() {\n    _classCallCheck(this, LayeredPolygon);\n    return _callSuper(this, LayeredPolygon, arguments);\n  }\n  _inherits(LayeredPolygon, _Shape);\n  return _createClass(LayeredPolygon, [{\n    key: \"generatePolygonPoints\",\n    value: function generatePolygonPoints(radius, vertexCount) {\n      var rotationOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var points = [];\n      var angleStep = 2 * Math.PI / vertexCount;\n\n      // Generate points for each vertex\n      for (var i = 0; i < vertexCount; i++) {\n        var angle = i * angleStep + rotationOffset;\n        var x = radius * Math.cos(angle);\n        var y = radius * Math.sin(angle);\n        points.push([x, y]);\n      }\n      return points;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var currentRadius = this.innerSize;\n      this.vertices = Math.round(this.vertices);\n\n      // Generate each layer\n      for (var layer = 0; layer < this.layers; layer++) {\n        // Generate multiple polygons per layer based on density\n        for (var d = 0; d < this.density; d++) {\n          var rotationOffset = d * 2 * Math.PI / (this.density * this.vertices);\n          var points = this.generatePolygonPoints(currentRadius, this.vertices, rotationOffset);\n\n          // Create path for the polygon\n          // Start with the first point\n          var pathData = \"M \".concat(points[0][0], \",\").concat(points[0][1]);\n\n          // Add lines to each subsequent point\n          for (var i = 1; i < points.length; i++) {\n            pathData += \" L \".concat(points[i][0], \",\").concat(points[i][1]);\n          }\n\n          // Close the path by connecting back to the first point\n          pathData += \" Z\";\n          paths.push(\"<path \\n                    d=\\\"\".concat(pathData, \"\\\"\\n                    fill=\\\"none\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linecap=\\\"square\\\"\\n                    stroke-linejoin=\\\"miter\\\"\\n                />\"));\n        }\n\n        // Increment radius for next layer\n        currentRadius += this.sizeStep;\n      }\n      return \"<g>\".concat(paths.join(''), \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LayeredPolygon, \"parameters\", {\n  vertices: {\n    min: 3,\n    max: 10,\n    \"default\": 6\n  },\n  layers: {\n    min: 2,\n    max: 5,\n    \"default\": 4\n  },\n  innerSize: {\n    min: 30,\n    max: 60,\n    \"default\": 13\n  },\n  sizeStep: {\n    min: 20,\n    max: 40,\n    \"default\": 20\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 6\n  },\n  density: {\n    min: 1,\n    max: 5,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayeredPolygon);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LayeredPolygon.js?");

/***/ }),

/***/ "./src/shapes/LeafVeinsShape.js":
/*!**************************************!*\
  !*** ./src/shapes/LeafVeinsShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LeafVeinsShape = /*#__PURE__*/function (_Shape) {\n  function LeafVeinsShape() {\n    _classCallCheck(this, LeafVeinsShape);\n    return _callSuper(this, LeafVeinsShape, arguments);\n  }\n  _inherits(LeafVeinsShape, _Shape);\n  return _createClass(LeafVeinsShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var scale = 1;\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Draw midrib\n      var startY = center.y + this.length / 2; // Inverted Y coordinates\n      var endY = center.y - this.length / 2;\n      paths.push(\"<line \\n            x1=\\\"\".concat(center.x, \"\\\" \\n            y1=\\\"\").concat(startY, \"\\\" \\n            x2=\\\"\").concat(center.x, \"\\\" \\n            y2=\\\"\").concat(endY, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n        />\"));\n\n      // Draw veins on both sides\n      for (var i = 0; i < this.veins; i++) {\n        var progress = i / (this.veins - 1);\n        var y = startY - progress * this.length; // Inverted Y calculation\n\n        // Convert vein angle to radians (negative angle to invert direction)\n        var angleRad = -this.veinAngle * (Math.PI / 180.0);\n\n        // Calculate vein length based on leaf shape (longer in middle)\n        var veinLength = this.width * Math.sin(Math.PI * progress);\n\n        // Calculate control points for quadratic curves\n        var leftStart = {\n          x: center.x,\n          y: y\n        };\n        var leftEnd = {\n          x: center.x - veinLength * Math.cos(angleRad),\n          y: y + veinLength * Math.sin(angleRad)\n        };\n        var leftControl = {\n          x: leftStart.x - veinLength * this.curvature,\n          y: leftStart.y + veinLength * this.curvature * 0.5\n        };\n        var rightEnd = {\n          x: center.x + veinLength * Math.cos(angleRad),\n          y: y + veinLength * Math.sin(angleRad)\n        };\n        var rightControl = {\n          x: leftStart.x + veinLength * this.curvature,\n          y: leftStart.y + veinLength * this.curvature * 0.5\n        };\n\n        // Draw left vein using quadratic curve\n        paths.push(\"<path \\n                d=\\\"M \".concat(leftStart.x, \" \").concat(leftStart.y, \" Q \").concat(leftControl.x, \" \").concat(leftControl.y, \" \").concat(leftEnd.x, \" \").concat(leftEnd.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n\n        // Draw right vein using quadratic curve\n        paths.push(\"<path \\n                d=\\\"M \".concat(leftStart.x, \" \").concat(leftStart.y, \" Q \").concat(rightControl.x, \" \").concat(rightControl.y, \" \").concat(rightEnd.x, \" \").concat(rightEnd.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LeafVeinsShape, \"parameters\", {\n  length: {\n    min: 100,\n    max: 250,\n    \"default\": 180\n  },\n  // Overall length of the leaf\n  width: {\n    min: 50,\n    max: 150,\n    \"default\": 100\n  },\n  // Width of the leaf\n  veins: {\n    min: 4,\n    max: 12,\n    \"default\": 8\n  },\n  // Number of vein pairs\n  curvature: {\n    min: 0,\n    max: 1,\n    \"default\": 0.6\n  },\n  // How much the veins curve\n  veinAngle: {\n    min: 20,\n    max: 70,\n    \"default\": 45\n  },\n  // Angle of veins from midrib\n  thickness: {\n    min: 1,\n    max: 5,\n    \"default\": 3\n  } // Line thickness\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LeafVeinsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LeafVeinsShape.js?");

/***/ }),

/***/ "./src/shapes/LineGrid.js":
/*!********************************!*\
  !*** ./src/shapes/LineGrid.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LineGrid = /*#__PURE__*/function (_Shape) {\n  function LineGrid() {\n    _classCallCheck(this, LineGrid);\n    return _callSuper(this, LineGrid, arguments);\n  }\n  _inherits(LineGrid, _Shape);\n  return _createClass(LineGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var cellWidth = this.size / this.columns;\n      var cellHeight = this.size / this.rows;\n      var startX = -this.size / 2;\n      var startY = -this.size / 2;\n\n      // Calculate base line length from the smaller cell dimension\n      var baseLength = Math.min(cellWidth, cellHeight) * this.lengthRatio;\n      var halfLength = baseLength / 2;\n\n      // Generate grid of lines\n      for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n          var centerX = startX + j * cellWidth + cellWidth / 2;\n          var centerY = startY + i * cellHeight + cellHeight / 2;\n\n          // Create line centered at cell position with rotation\n          lines.push(\"<line \\n                    x1=\\\"-\".concat(halfLength, \"\\\" \\n                    y1=\\\"0\\\"\\n                    x2=\\\"\").concat(halfLength, \"\\\" \\n                    y2=\\\"0\\\"\\n                    transform=\\\"translate(\").concat(centerX, \" \").concat(centerY, \") rotate(\").concat(this.rotation, \")\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                />\"));\n        }\n      }\n      return \"<g>\".concat(lines.join(''), \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LineGrid, \"parameters\", {\n  size: {\n    min: 100,\n    max: 250,\n    \"default\": 200\n  },\n  rows: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  columns: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  lengthRatio: {\n    min: 0.2,\n    max: 2,\n    \"default\": 0.8\n  },\n  rotation: {\n    min: 0,\n    max: 360,\n    \"default\": 45\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 6\n  },\n  lineCap: {\n    options: ['butt', 'round', 'square'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LineGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LineGrid.js?");

/***/ }),

/***/ "./src/shapes/LinesBurst.js":
/*!**********************************!*\
  !*** ./src/shapes/LinesBurst.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LinesBurst = /*#__PURE__*/function (_Shape) {\n  function LinesBurst() {\n    _classCallCheck(this, LinesBurst);\n    return _callSuper(this, LinesBurst, arguments);\n  }\n  _inherits(LinesBurst, _Shape);\n  return _createClass(LinesBurst, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG for consistent results with the same seed\n      this.resetRNG();\n      var lines = [];\n      var rotationRad = this.rotation * Math.PI / 180;\n      var angleStep = 2 * Math.PI / this.points;\n      for (var i = 0; i < this.points; i++) {\n        // Calculate angle for this line\n        var angle = i * angleStep + rotationRad;\n\n        // Calculate line length with variation\n        var variation = 1 + (this.random() * 2 - 1) * this.lengthVariation;\n        var lineLength = this.radius * variation;\n\n        // Calculate start and end coordinates\n        // Start slightly away from center to avoid the central circle effect\n        var startX = Math.cos(angle) * (this.radius * 0.05);\n        var startY = Math.sin(angle) * (this.radius * 0.05);\n        var endX = Math.cos(angle) * lineLength;\n        var endY = Math.sin(angle) * lineLength;\n\n        // Create the line element\n        lines.push(\"<line \\n                x1=\\\"\".concat(startX, \"\\\" \\n                y1=\\\"\").concat(startY, \"\\\" \\n                x2=\\\"\").concat(endX, \"\\\" \\n                y2=\\\"\").concat(endY, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n            />\"));\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LinesBurst, \"parameters\", {\n  radius: {\n    min: 20,\n    max: 100,\n    \"default\": 80\n  },\n  points: {\n    min: 6,\n    max: 24,\n    \"default\": 12\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  lengthVariation: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.3\n  },\n  rotation: {\n    min: 0,\n    max: 360,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LinesBurst);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LinesBurst.js?");

/***/ }),

/***/ "./src/shapes/LissajousCurve.js":
/*!**************************************!*\
  !*** ./src/shapes/LissajousCurve.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LissajousShape = /*#__PURE__*/function (_Shape) {\n  function LissajousShape() {\n    _classCallCheck(this, LissajousShape);\n    return _callSuper(this, LissajousShape, arguments);\n  }\n  _inherits(LissajousShape, _Shape);\n  return _createClass(LissajousShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 80;\n      var phaseRad = this.phaseShift * Math.PI / 180;\n      var segments = 128; // Increased for smoother interpolation\n      var tension = 0.3; // Controls curve tightness\n      var pathParts = [];\n\n      // Pre-calculate points for better control point estimation\n      var points = [];\n      for (var i = 0; i <= segments + 1; i++) {\n        var t = i / segments * 2 * Math.PI;\n        var x = scale * Math.sin(this.frequencyX * t + phaseRad);\n        var y = scale * Math.sin(this.frequencyY * t);\n\n        // Ensure we have valid numbers\n        points.push({\n          x: isNaN(x) ? 0 : x,\n          y: isNaN(y) ? 0 : y,\n          t: t\n        });\n      }\n\n      // Calculate smooth curve using optimized cubic Bzier curves\n      for (var _i = 0; _i < segments; _i++) {\n        var p0 = points[_i];\n        var p1 = points[_i + 1];\n\n        // Calculate derivatives for smooth tangents\n        var dx0 = scale * this.frequencyX * Math.cos(this.frequencyX * p0.t + phaseRad);\n        var dy0 = scale * this.frequencyY * Math.cos(this.frequencyY * p0.t);\n        var dx1 = scale * this.frequencyX * Math.cos(this.frequencyX * p1.t + phaseRad);\n        var dy1 = scale * this.frequencyY * Math.cos(this.frequencyY * p1.t);\n\n        // Calculate control point distances with dynamic tension\n        var dist = Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2)) * tension;\n\n        // Normalize tangent vectors with safety checks\n        var len0 = Math.sqrt(dx0 * dx0 + dy0 * dy0);\n        var len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n\n        // Calculate control points with safety checks to prevent NaN\n        var cp1x = void 0,\n          cp1y = void 0,\n          cp2x = void 0,\n          cp2y = void 0;\n        if (len0 > 0.0001) {\n          cp1x = p0.x + dx0 * dist / len0;\n          cp1y = p0.y + dy0 * dist / len0;\n        } else {\n          // Fallback if tangent length is too small\n          cp1x = p0.x;\n          cp1y = p0.y;\n        }\n        if (len1 > 0.0001) {\n          cp2x = p1.x - dx1 * dist / len1;\n          cp2y = p1.y - dy1 * dist / len1;\n        } else {\n          // Fallback if tangent length is too small\n          cp2x = p1.x;\n          cp2y = p1.y;\n        }\n\n        // Ensure all values are valid numbers\n        cp1x = isNaN(cp1x) ? p0.x : cp1x;\n        cp1y = isNaN(cp1y) ? p0.y : cp1y;\n        cp2x = isNaN(cp2x) ? p1.x : cp2x;\n        cp2y = isNaN(cp2y) ? p1.y : cp2y;\n        if (_i === 0) {\n          pathParts.push(\"M\".concat(p0.x, \",\").concat(p0.y));\n        }\n        pathParts.push(\"C\".concat(cp1x, \",\").concat(cp1y, \" \").concat(cp2x, \",\").concat(cp2y, \" \").concat(p1.x, \",\").concat(p1.y));\n      }\n\n      // Close the path smoothly\n      pathParts.push(\"Z\");\n      return \"<path \\n            d=\\\"\".concat(pathParts.join(' '), \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n            fill=\\\"none\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LissajousShape, \"parameters\", {\n  thickness: {\n    min: 2,\n    max: 24,\n    \"default\": 7\n  },\n  frequencyX: {\n    min: 1,\n    max: 12,\n    \"default\": 4\n  },\n  frequencyY: {\n    min: 1,\n    max: 12,\n    \"default\": 3\n  },\n  phaseShift: {\n    min: 0,\n    max: 360,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LissajousShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LissajousCurve.js?");

/***/ }),

/***/ "./src/shapes/LogarithmicDots.js":
/*!***************************************!*\
  !*** ./src/shapes/LogarithmicDots.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LogarithmicDots = /*#__PURE__*/function (_Shape) {\n  function LogarithmicDots() {\n    _classCallCheck(this, LogarithmicDots);\n    return _callSuper(this, LogarithmicDots, arguments);\n  }\n  _inherits(LogarithmicDots, _Shape);\n  return _createClass(LogarithmicDots, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var dots = [];\n      var angleIncrement = 2 * Math.PI / this.density;\n      var rotationRad = this.rotation * Math.PI / 180;\n      var currentRadius = this.dotSize * 2;\n      var angle = 0;\n      var spiralCount = 0;\n      var maxRadius = 100; // Based on viewBox size\n\n      while (currentRadius < maxRadius && spiralCount < 200) {\n        for (var i = 0; i < this.density; i++) {\n          var theta = angle + i * angleIncrement + rotationRad;\n          var x = currentRadius * Math.cos(theta);\n          var y = currentRadius * Math.sin(theta);\n          dots.push(\"<circle \\n                    cx=\\\"\".concat(x, \"\\\" \\n                    cy=\\\"\").concat(y, \"\\\" \\n                    r=\\\"\").concat(this.dotSize / 2, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n        currentRadius *= this.growthRate;\n        angle += angleIncrement / 2;\n        spiralCount++;\n      }\n      return dots.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LogarithmicDots, \"parameters\", {\n  growthRate: {\n    min: 1.1,\n    max: 2.0,\n    \"default\": 1.2\n  },\n  density: {\n    min: 8,\n    max: 32,\n    \"default\": 16\n  },\n  dotSize: {\n    min: 4,\n    max: 20,\n    \"default\": 6\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LogarithmicDots);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LogarithmicDots.js?");

/***/ }),

/***/ "./src/shapes/LotusShape.js":
/*!**********************************!*\
  !*** ./src/shapes/LotusShape.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LotusShape = /*#__PURE__*/function (_Shape) {\n  function LotusShape() {\n    _classCallCheck(this, LotusShape);\n    return _callSuper(this, LotusShape, arguments);\n  }\n  _inherits(LotusShape, _Shape);\n  return _createClass(LotusShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Ensure points is an integer\n      var pointsInt = Math.round(this.points);\n\n      // Convert rotation to radians\n      var rotationRad = this.rotation * Math.PI / 180;\n\n      // Calculate radii - adjusted to fit 200x200 viewBox\n      var outerRadius = 90; // slightly reduced to ensure fit with curvature\n      var innerRadius = this.innerRadius * outerRadius;\n      for (var i = 0; i < pointsInt; i++) {\n        var angle1 = i * 2 * Math.PI / pointsInt + rotationRad;\n        var angle2 = (i + 1) * 2 * Math.PI / pointsInt + rotationRad;\n        var angleMid = (angle1 + angle2) / 2;\n\n        // Outer points\n        var outer1 = {\n          x: center.x + outerRadius * Math.cos(angle1),\n          y: center.y + outerRadius * Math.sin(angle1)\n        };\n        var outer2 = {\n          x: center.x + outerRadius * Math.cos(angle2),\n          y: center.y + outerRadius * Math.sin(angle2)\n        };\n\n        // Control point for outer curve\n        var outerControl = {\n          x: center.x + outerRadius * (1 + this.curvature) * Math.cos(angleMid),\n          y: center.y + outerRadius * (1 + this.curvature) * Math.sin(angleMid)\n        };\n\n        // Inner points\n        var inner1 = {\n          x: center.x + innerRadius * Math.cos(angle1),\n          y: center.y + innerRadius * Math.sin(angle1)\n        };\n        var inner2 = {\n          x: center.x + innerRadius * Math.cos(angle2),\n          y: center.y + innerRadius * Math.sin(angle2)\n        };\n\n        // Control point for inner curve\n        var innerControl = {\n          x: center.x + innerRadius * (1 - this.curvature) * Math.cos(angleMid),\n          y: center.y + innerRadius * (1 - this.curvature) * Math.sin(angleMid)\n        };\n\n        // Draw the petal segment using a path\n        paths.push(\"<path \\n                d=\\\"M \".concat(outer1.x, \" \").concat(outer1.y, \" \\n                   Q \").concat(outerControl.x, \" \").concat(outerControl.y, \" \").concat(outer2.x, \" \").concat(outer2.y, \"\\n                   L \").concat(inner2.x, \" \").concat(inner2.y, \"\\n                   Q \").concat(innerControl.x, \" \").concat(innerControl.y, \" \").concat(inner1.x, \" \").concat(inner1.y, \"\\n                   Z\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linejoin=\\\"round\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LotusShape, \"parameters\", {\n  points: {\n    min: 3,\n    max: 10,\n    \"default\": 6\n  },\n  innerRadius: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  curvature: {\n    min: 0,\n    max: 0.6,\n    \"default\": 0.2\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LotusShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/LotusShape.js?");

/***/ }),

/***/ "./src/shapes/MazeShape.js":
/*!*********************************!*\
  !*** ./src/shapes/MazeShape.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar MazeShape = /*#__PURE__*/function (_Shape) {\n  function MazeShape() {\n    _classCallCheck(this, MazeShape);\n    return _callSuper(this, MazeShape, arguments);\n  }\n  _inherits(MazeShape, _Shape);\n  return _createClass(MazeShape, [{\n    key: \"generateMaze\",\n    value: function generateMaze() {\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n\n      // Initialize grid\n      var grid = [];\n      for (var y = 0; y < this.gridSize; y++) {\n        grid[y] = [];\n        for (var x = 0; x < this.gridSize; x++) {\n          grid[y][x] = {\n            visited: false,\n            walls: {\n              top: true,\n              right: true,\n              bottom: true,\n              left: true\n            }\n          };\n        }\n      }\n\n      // Start DFS from random cell\n      var stack = [];\n      var cy = 0;\n      var cx = 0;\n      grid[cy][cx].visited = true;\n\n      // DFS to create perfect maze\n      while (true) {\n        var neighbors = [];\n\n        // Check neighbors\n        if (cy > 0 && !grid[cy - 1][cx].visited) neighbors.push({\n          y: cy - 1,\n          x: cx,\n          dir: 'top'\n        });\n        if (cx < this.gridSize - 1 && !grid[cy][cx + 1].visited) neighbors.push({\n          y: cy,\n          x: cx + 1,\n          dir: 'right'\n        });\n        if (cy < this.gridSize - 1 && !grid[cy + 1][cx].visited) neighbors.push({\n          y: cy + 1,\n          x: cx,\n          dir: 'bottom'\n        });\n        if (cx > 0 && !grid[cy][cx - 1].visited) neighbors.push({\n          y: cy,\n          x: cx - 1,\n          dir: 'left'\n        });\n        if (neighbors.length > 0) {\n          // Choose random neighbor\n          var idx = Math.floor(this.random() * neighbors.length);\n          var next = neighbors[idx];\n\n          // Remove walls between current and chosen\n          if (next.dir === 'top') {\n            grid[cy][cx].walls.top = false;\n            grid[next.y][next.x].walls.bottom = false;\n          } else if (next.dir === 'right') {\n            grid[cy][cx].walls.right = false;\n            grid[next.y][next.x].walls.left = false;\n          } else if (next.dir === 'bottom') {\n            grid[cy][cx].walls.bottom = false;\n            grid[next.y][next.x].walls.top = false;\n          } else if (next.dir === 'left') {\n            grid[cy][cx].walls.left = false;\n            grid[next.y][next.x].walls.right = false;\n          }\n\n          // Push current position to stack\n          stack.push({\n            y: cy,\n            x: cx\n          });\n\n          // Move to next cell\n          cy = next.y;\n          cx = next.x;\n          grid[cy][cx].visited = true;\n        } else if (stack.length > 0) {\n          // Backtrack\n          var pos = stack.pop();\n          cy = pos.y;\n          cx = pos.x;\n        } else {\n          // Done\n          break;\n        }\n      }\n\n      // Add entry and exit\n      grid[0][0].walls.top = false;\n      grid[this.gridSize - 1][this.gridSize - 1].walls.bottom = false;\n      return grid;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var maze = this.generateMaze();\n      var lines = [];\n      var totalSize = 200;\n      var usableSize = totalSize * 0.8; // 80% of 200\n      var margin = (totalSize - usableSize) / 2;\n      var cellSize = usableSize / this.gridSize;\n      var offset = -100 + margin;\n\n      // Draw walls\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          var cell = maze[y][x];\n          var left = offset + x * cellSize;\n          var top = offset + y * cellSize;\n          var right = left + cellSize;\n          var bottom = top + cellSize;\n          if (cell.walls.top) {\n            lines.push(\"<line x1=\\\"\".concat(left, \"\\\" y1=\\\"\").concat(top, \"\\\" x2=\\\"\").concat(right, \"\\\" y2=\\\"\").concat(top, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.lineWidth, \"\\\" stroke-linecap=\\\"square\\\" />\"));\n          }\n          if (cell.walls.right) {\n            lines.push(\"<line x1=\\\"\".concat(right, \"\\\" y1=\\\"\").concat(top, \"\\\" x2=\\\"\").concat(right, \"\\\" y2=\\\"\").concat(bottom, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.lineWidth, \"\\\" stroke-linecap=\\\"square\\\" />\"));\n          }\n          if (cell.walls.bottom) {\n            lines.push(\"<line x1=\\\"\".concat(left, \"\\\" y1=\\\"\").concat(bottom, \"\\\" x2=\\\"\").concat(right, \"\\\" y2=\\\"\").concat(bottom, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.lineWidth, \"\\\" stroke-linecap=\\\"square\\\" />\"));\n          }\n          if (cell.walls.left) {\n            lines.push(\"<line x1=\\\"\".concat(left, \"\\\" y1=\\\"\").concat(top, \"\\\" x2=\\\"\").concat(left, \"\\\" y2=\\\"\").concat(bottom, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.lineWidth, \"\\\" stroke-linecap=\\\"square\\\" />\"));\n          }\n        }\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MazeShape, \"parameters\", {\n  gridSize: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  lineWidth: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MazeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MazeShape.js?");

/***/ }),

/***/ "./src/shapes/MeepleShape.js":
/*!***********************************!*\
  !*** ./src/shapes/MeepleShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar MeepleShape = /*#__PURE__*/function (_Shape) {\n  function MeepleShape() {\n    _classCallCheck(this, MeepleShape);\n    return _callSuper(this, MeepleShape, arguments);\n  }\n  _inherits(MeepleShape, _Shape);\n  return _createClass(MeepleShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 1;\n      var centerX = 0;\n      var centerY = 0;\n\n      // Calculate scaled dimensions\n      var bodyWidth = this.bodyWidth * scale;\n      var bodyHeight = this.bodyHeight * scale;\n      var headSize = this.headSize * scale;\n      var shoulderWidth = this.shoulderWidth * scale;\n      var legSpread = this.legSpread * scale;\n\n      // Create path points\n      var points = [// Start at bottom left leg\n      \"\".concat(centerX - bodyWidth / 2 - legSpread, \",\").concat(centerY + bodyHeight / 2), // Left side up to shoulder\n      \"\".concat(centerX - shoulderWidth / 2, \",\").concat(centerY - bodyHeight / 6), // Left shoulder to neck\n      \"\".concat(centerX - headSize / 2, \",\").concat(centerY - bodyHeight / 6), // Head left side\n      \"\".concat(centerX - headSize / 2, \",\").concat(centerY - bodyHeight / 2), // Head top\n      \"\".concat(centerX + headSize / 2, \",\").concat(centerY - bodyHeight / 2), // Head right side\n      \"\".concat(centerX + headSize / 2, \",\").concat(centerY - bodyHeight / 6), // Right shoulder\n      \"\".concat(centerX + shoulderWidth / 2, \",\").concat(centerY - bodyHeight / 6), // Right side down to leg\n      \"\".concat(centerX + bodyWidth / 2 + legSpread, \",\").concat(centerY + bodyHeight / 2)];\n      return \"<path \\n            d=\\\"M \".concat(points[0], \" L \").concat(points[1], \" L \").concat(points[2], \" L \").concat(points[3], \" L \").concat(points[4], \" L \").concat(points[5], \" L \").concat(points[6], \" L \").concat(points[7], \" Z\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MeepleShape, \"parameters\", {\n  bodyWidth: {\n    min: 40,\n    max: 200,\n    \"default\": 100\n  },\n  bodyHeight: {\n    min: 40,\n    max: 200,\n    \"default\": 120\n  },\n  headSize: {\n    min: 20,\n    max: 100,\n    \"default\": 50\n  },\n  shoulderWidth: {\n    min: 40,\n    max: 250,\n    \"default\": 160\n  },\n  legSpread: {\n    min: 0,\n    max: 60,\n    \"default\": 30\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MeepleShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MeepleShape.js?");

/***/ }),

/***/ "./src/shapes/MeshGridShape.js":
/*!*************************************!*\
  !*** ./src/shapes/MeshGridShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar MeshGridShape = /*#__PURE__*/function (_Shape) {\n  function MeshGridShape() {\n    _classCallCheck(this, MeshGridShape);\n    return _callSuper(this, MeshGridShape, arguments);\n  }\n  _inherits(MeshGridShape, _Shape);\n  return _createClass(MeshGridShape, [{\n    key: \"noise\",\n    value:\n    // Enhanced noise function with better distribution\n    function noise(x, y) {\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      // Use the seed but don't modify it directly\n      var seed = this.seed;\n      // More harmonious frequency components\n      var p1 = Math.sin((x + y * 0.7) * 0.13 + seed * 0.31);\n      var p2 = Math.sin((x * 1.1 - y * 0.5) * 0.23 + seed * 1.51);\n      var p3 = Math.cos((x * 0.81 + y * 0.62) * 0.19 + seed * 0.47);\n      var p4 = Math.sin((x * 0.31 + y * 1.1) * 0.18 + seed * 0.69);\n\n      // Weight components for better distribution\n      return p1 * 0.35 + p2 * 0.25 + p3 * 0.22 + p4 * 0.18;\n    }\n\n    // Smoothed noise function for high quality\n  }, {\n    key: \"smoothedNoise\",\n    value: function smoothedNoise(x, y) {\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      // Skip smoothing if smoothness is at minimum\n      if (this.smoothness <= 1) return this.noise(x, y, z);\n\n      // Get surrounding noise values\n      var smoothingRadius = Math.min(this.smoothness * 0.1, 0.8);\n      var sum = 0;\n      var count = 0;\n\n      // Higher quality sampling for smoothed noise\n      var sampleCount = Math.max(3, Math.floor(this.smoothness));\n      for (var sx = -smoothingRadius; sx <= smoothingRadius; sx += smoothingRadius * 2 / (sampleCount - 1)) {\n        for (var sy = -smoothingRadius; sy <= smoothingRadius; sy += smoothingRadius * 2 / (sampleCount - 1)) {\n          sum += this.noise(x + sx, y + sy, z);\n          count++;\n        }\n      }\n      return sum / count;\n    }\n\n    // Adaptive distance attenuation\n  }, {\n    key: \"getDistanceAttenuation\",\n    value: function getDistanceAttenuation(x, y) {\n      // Use dynamic boundary based on grid parameters\n      var maxDistance = 140 + this.gridSize * 3;\n      var distance = Math.sqrt(x * x + y * y);\n\n      // More natural quadratic falloff\n      var normalizedDistance = Math.min(1, Math.pow(distance / maxDistance, 1.5));\n      if (this.fadeEdges > 0) {\n        var fadeAmount = this.fadeEdges / 100;\n        // Smoother transition curve\n        return Math.max(0, 1 - Math.pow(normalizedDistance * fadeAmount, 1.3));\n      }\n      return 1 - normalizedDistance * 0.2;\n    }\n\n    // Enhanced distortion with boundary protection and smoother transitions\n  }, {\n    key: \"distortPoint\",\n    value: function distortPoint(x, y) {\n      var attenuation = this.getDistanceAttenuation(x, y);\n\n      // Calculate bounds-aware distortion limit\n      var viewBoxBoundary = 190;\n      var distanceToEdgeX = viewBoxBoundary - Math.abs(x);\n      var distanceToEdgeY = viewBoxBoundary - Math.abs(y);\n      var distanceToBoundary = Math.min(distanceToEdgeX, distanceToEdgeY);\n\n      // Adaptive distortion strength\n      var safetyFactor = 0.6;\n      var maxAllowedDistortion = Math.max(5, distanceToBoundary * safetyFactor);\n\n      // Scale distortion based on parameter and limits\n      var effectiveDistortion = Math.min(this.distortion * attenuation, maxAllowedDistortion);\n\n      // Enhanced flow field with natural curvature\n      var baseAngle = Math.atan2(y, x);\n      var radiusRatio = Math.min(1, Math.sqrt(x * x + y * y) / 160);\n      var adaptiveFlowStrength = 0.25 + radiusRatio * 0.1;\n\n      // Calculate offset with smoothed noise for higher quality\n      var noiseX = this.smoothedNoise(x / this.noiseScale + Math.cos(baseAngle * 1.3) * adaptiveFlowStrength, y / this.noiseScale + Math.sin(baseAngle * 1.3) * adaptiveFlowStrength, 1.0) * effectiveDistortion;\n      var noiseY = this.smoothedNoise(x / this.noiseScale + Math.cos(baseAngle * 1.8) * adaptiveFlowStrength, y / this.noiseScale + Math.sin(baseAngle * 1.8) * adaptiveFlowStrength, 2.5) * effectiveDistortion;\n      return {\n        x: x + noiseX,\n        y: y + noiseY\n      };\n    }\n  }, {\n    key: \"generateRadialGrid\",\n    value: function generateRadialGrid() {\n      var lines = [];\n\n      // Calculate optimal parameters for radial grid\n      var viewBoxSize = 400;\n      var safeRadius = viewBoxSize / 2 * 0.85;\n      var maxRadius = Math.min(this.gridSize * this.cellSize, safeRadius);\n\n      // Higher segment count for smooth circles\n      var segmentMultiplier = Math.max(3, Math.min(12, Math.floor(this.gridSize * 0.75)));\n      var radialSegments = 36 + segmentMultiplier * 4;\n\n      // Adaptive circle count based on grid size\n      var targetCircleCount = Math.max(4, this.gridSize + 1);\n      var effectiveCellSize = maxRadius / targetCircleCount;\n\n      // Generate concentric circles with adaptive spacing\n      var circles = [];\n      for (var i = 1; i <= targetCircleCount; i++) {\n        // Use non-linear spacing for more interesting results\n        var ratio = i / targetCircleCount;\n        var r = maxRadius * Math.pow(ratio, 0.9);\n        var circlePoints = [];\n        for (var j = 0; j <= radialSegments; j++) {\n          var angle = j / radialSegments * Math.PI * 2;\n          var x = Math.cos(angle) * r;\n          var y = Math.sin(angle) * r;\n          var distorted = this.distortPoint(x, y);\n          circlePoints.push(distorted);\n        }\n        circles.push(circlePoints);\n      }\n\n      // Draw concentric circles with high-quality paths\n      for (var _i = 0, _circles = circles; _i < _circles.length; _i++) {\n        var _circlePoints = _circles[_i];\n        for (var _i2 = 0; _i2 < _circlePoints.length - 1; _i2++) {\n          // Skip some points for optimization when lines are very close\n          if (_i2 % Math.max(1, Math.floor(radialSegments / 120)) !== 0 && _i2 !== _circlePoints.length - 2) continue;\n          lines.push(\"<line \\n                    x1=\\\"\".concat(_circlePoints[_i2].x, \"\\\" \\n                    y1=\\\"\").concat(_circlePoints[_i2].y, \"\\\" \\n                    x2=\\\"\").concat(_circlePoints[_i2 + 1].x, \"\\\" \\n                    y2=\\\"\").concat(_circlePoints[_i2 + 1].y, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.lineThickness, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\"));\n        }\n      }\n\n      // Draw radial lines with adaptive spacing\n      var targetRadialLineCount = Math.max(12, this.gridSize * 3);\n      var radialLineSpacing = Math.ceil(radialSegments / targetRadialLineCount);\n      for (var a = 0; a < radialSegments; a += radialLineSpacing) {\n        var radialPoints = [];\n        for (var _r = 0; _r < circles.length; _r++) {\n          radialPoints.push(circles[_r][a]);\n        }\n\n        // Draw radial lines\n        for (var _i3 = 0; _i3 < radialPoints.length - 1; _i3++) {\n          lines.push(\"<line \\n                    x1=\\\"\".concat(radialPoints[_i3].x, \"\\\" \\n                    y1=\\\"\").concat(radialPoints[_i3].y, \"\\\" \\n                    x2=\\\"\").concat(radialPoints[_i3 + 1].x, \"\\\" \\n                    y2=\\\"\").concat(radialPoints[_i3 + 1].y, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.lineThickness, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\"));\n        }\n      }\n      return lines.join('');\n    }\n  }, {\n    key: \"generateSquareGrid\",\n    value: function generateSquareGrid() {\n      var lines = [];\n\n      // Calculate optimal grid parameters\n      var viewBoxSize = 400;\n      var safeSize = viewBoxSize * 0.84 / 2;\n\n      // Use symmetric grid by default for centering\n      var halfGridCount = this.gridSize;\n      var cellSize = Math.min(this.cellSize, safeSize / halfGridCount);\n\n      // Generate grid points with precise centering\n      var grid = [];\n      for (var i = -halfGridCount; i <= halfGridCount; i++) {\n        var row = [];\n        var y = i * cellSize;\n        for (var j = -halfGridCount; j <= halfGridCount; j++) {\n          var x = j * cellSize;\n          var distorted = this.distortPoint(x, y);\n          row.push(distorted);\n        }\n        grid.push(row);\n      }\n\n      // Draw horizontal lines with high-quality rendering\n      for (var _i4 = 0; _i4 < grid.length; _i4++) {\n        for (var _j = 0; _j < grid[_i4].length - 1; _j++) {\n          var p1 = grid[_i4][_j];\n          var p2 = grid[_i4][_j + 1];\n\n          // Calculate distance-based thickness variation\n          var centerDistance = Math.sqrt(Math.pow((p1.x + p2.x) / 2, 2) + Math.pow((p1.y + p2.y) / 2, 2));\n\n          // Smoother thickness transition\n          var adjustedThickness = this.lineThickness * (1 - Math.min(0.35, Math.pow(centerDistance / 420, 1.2)));\n          lines.push(\"<line \\n                    x1=\\\"\".concat(p1.x, \"\\\" \\n                    y1=\\\"\").concat(p1.y, \"\\\" \\n                    x2=\\\"\").concat(p2.x, \"\\\" \\n                    y2=\\\"\").concat(p2.y, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(adjustedThickness, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\"));\n        }\n      }\n\n      // Draw vertical lines with same high-quality approach\n      for (var _j2 = 0; _j2 < grid[0].length; _j2++) {\n        for (var _i5 = 0; _i5 < grid.length - 1; _i5++) {\n          var _p = grid[_i5][_j2];\n          var _p2 = grid[_i5 + 1][_j2];\n          var _centerDistance = Math.sqrt(Math.pow((_p.x + _p2.x) / 2, 2) + Math.pow((_p.y + _p2.y) / 2, 2));\n          var _adjustedThickness = this.lineThickness * (1 - Math.min(0.35, Math.pow(_centerDistance / 420, 1.2)));\n          lines.push(\"<line \\n                    x1=\\\"\".concat(_p.x, \"\\\" \\n                    y1=\\\"\").concat(_p.y, \"\\\" \\n                    x2=\\\"\").concat(_p2.x, \"\\\" \\n                    y2=\\\"\").concat(_p2.y, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(_adjustedThickness, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\"));\n        }\n      }\n      return lines.join('');\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n      if (this.gridStyle === 'radial') {\n        return this.generateRadialGrid();\n      } else {\n        return this.generateSquareGrid();\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MeshGridShape, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 5,\n    \"default\": 5\n  },\n  cellSize: {\n    min: 10,\n    max: 30,\n    \"default\": 18\n  },\n  distortion: {\n    min: 25,\n    max: 100,\n    \"default\": 55\n  },\n  noiseScale: {\n    min: 5,\n    max: 12,\n    \"default\": 6\n  },\n  lineThickness: {\n    min: 1,\n    max: 4,\n    \"default\": 1.5\n  },\n  gridStyle: {\n    options: ['square', 'radial'],\n    \"default\": 'radial'\n  },\n  fadeEdges: {\n    min: 0,\n    max: 100,\n    \"default\": 60\n  },\n  // seed is now inherited from Shape class\n  smoothness: {\n    min: 1,\n    max: 10,\n    \"default\": 6\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MeshGridShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MeshGridShape.js?");

/***/ }),

/***/ "./src/shapes/MessageBubble.js":
/*!*************************************!*\
  !*** ./src/shapes/MessageBubble.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar MessageBubble = /*#__PURE__*/function (_Shape) {\n  function MessageBubble() {\n    _classCallCheck(this, MessageBubble);\n    return _callSuper(this, MessageBubble, arguments);\n  }\n  _inherits(MessageBubble, _Shape);\n  return _createClass(MessageBubble, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var width = this.width;\n      var height = this.height;\n      var cornerRadius = Math.min(this.cornerRadius, Math.min(width, height) / 3);\n      var tailSize = this.tailSize;\n\n      // Calculate bounds\n      var halfWidth = width / 2;\n      var halfHeight = height / 2;\n\n      // Calculate tail position (0 is center, -50/50 is left/right edge)\n      var tailPosRatio = this.tailPosition / 100;\n      var tailX = tailPosRatio * (halfWidth - cornerRadius - tailSize / 2);\n\n      // Build path for bubble\n      var pathData = '';\n\n      // Top edge with corners\n      pathData += \"M \".concat(-halfWidth + cornerRadius, \" \").concat(-halfHeight);\n      pathData += \" L \".concat(halfWidth - cornerRadius, \" \").concat(-halfHeight);\n      pathData += \" Q \".concat(halfWidth, \" \").concat(-halfHeight, \" \").concat(halfWidth, \" \").concat(-halfHeight + cornerRadius);\n\n      // Right edge with corner\n      pathData += \" L \".concat(halfWidth, \" \").concat(halfHeight - cornerRadius);\n      pathData += \" Q \".concat(halfWidth, \" \").concat(halfHeight, \" \").concat(halfWidth - cornerRadius, \" \").concat(halfHeight);\n\n      // Bottom edge with tail and corners\n      if (tailSize > 0) {\n        // Bottom edge to tail start\n        pathData += \" L \".concat(tailX + tailSize / 2, \" \").concat(halfHeight);\n\n        // Tail\n        pathData += \" L \".concat(tailX, \" \").concat(halfHeight + tailSize);\n        pathData += \" L \".concat(tailX - tailSize / 2, \" \").concat(halfHeight);\n      }\n\n      // Finish bottom edge\n      pathData += \" L \".concat(-halfWidth + cornerRadius, \" \").concat(halfHeight);\n      pathData += \" Q \".concat(-halfWidth, \" \").concat(halfHeight, \" \").concat(-halfWidth, \" \").concat(halfHeight - cornerRadius);\n\n      // Left edge with corner\n      pathData += \" L \".concat(-halfWidth, \" \").concat(-halfHeight + cornerRadius);\n      pathData += \" Q \".concat(-halfWidth, \" \").concat(-halfHeight, \" \").concat(-halfWidth + cornerRadius, \" \").concat(-halfHeight);\n\n      // Close the path\n      pathData += ' Z';\n      return \"<path\\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"none\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MessageBubble, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  height: {\n    min: 50,\n    max: 150,\n    \"default\": 100\n  },\n  cornerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 20\n  },\n  tailSize: {\n    min: 15,\n    max: 40,\n    \"default\": 25\n  },\n  tailPosition: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MessageBubble);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MessageBubble.js?");

/***/ }),

/***/ "./src/shapes/MetaBall.js":
/*!********************************!*\
  !*** ./src/shapes/MetaBall.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar MetaBall = /*#__PURE__*/function (_Shape) {\n  function MetaBall() {\n    _classCallCheck(this, MetaBall);\n    return _callSuper(this, MetaBall, arguments);\n  }\n  _inherits(MetaBall, _Shape);\n  return _createClass(MetaBall, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var maxRadius = 100;\n      var normalizedRadius = this.radius / 150.0 * maxRadius;\n      var twistRad = this.twist * Math.PI / 180;\n\n      // Generate the shape points\n      var steps = 100;\n      var points = [];\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps;\n        var angle = 2 * Math.PI * t;\n\n        // Calculate radius with lobes\n        var r = normalizedRadius * (1 + this.lobeSize * Math.cos(2 * angle + twistRad));\n        var x = r * Math.cos(angle);\n        var y = r * Math.sin(angle);\n        points.push(\"\".concat(x, \",\").concat(y));\n      }\n\n      // Create the SVG polygon\n      return \"<path \\n            d=\\\"M \".concat(points[0], \" L \").concat(points.slice(1).join(' L '), \" Z\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MetaBall, \"parameters\", {\n  radius: {\n    min: 40,\n    max: 150,\n    \"default\": 100\n  },\n  lobeSize: {\n    min: 0.2,\n    max: 0.8,\n    \"default\": 0.5\n  },\n  twist: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MetaBall);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MetaBall.js?");

/***/ }),

/***/ "./src/shapes/MetaBalls.js":
/*!*********************************!*\
  !*** ./src/shapes/MetaBalls.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar MetaBalls = /*#__PURE__*/function (_Shape) {\n  function MetaBalls() {\n    _classCallCheck(this, MetaBalls);\n    return _callSuper(this, MetaBalls, arguments);\n  }\n  _inherits(MetaBalls, _Shape);\n  return _createClass(MetaBalls, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG before generating the shape\n      this.resetRNG();\n\n      // Generate ball positions and radiuses\n      var balls = this.generateBalls();\n\n      // Create the metaball path\n      var pathData = this.createMetaballPath(balls);\n\n      // Create the SVG elements\n      return this.createSVGElements(balls, pathData);\n    }\n\n    // No longer needed - using the inherited random() method\n    // seededRandom is replaced with a wrapper that maintains the same interface\n  }, {\n    key: \"seededRandom\",\n    value: function seededRandom(max, min) {\n      var rnd = this.random();\n      if (min === undefined && max === undefined) {\n        return rnd;\n      }\n      if (min === undefined) {\n        min = 0;\n      }\n      return min + rnd * (max - min);\n    }\n  }, {\n    key: \"generateBalls\",\n    value: function generateBalls() {\n      var balls = [];\n      var angleStep = 2 * Math.PI / this.ballCount;\n      for (var i = 0; i < this.ballCount; i++) {\n        // Add slight variation to angle for organic look, but controlled by seed\n        var angleVariation = this.seededRandom(-0.1, 0.1);\n        var angle = i * angleStep + angleVariation;\n\n        // Calculate position based on spacing parameter with subtle variation\n        var distanceFactor = this.seededRandom(0.9, 1.1);\n        var distanceVariation = this.spacing * 0.5 * distanceFactor;\n        var x = Math.cos(angle) * distanceVariation;\n        var y = Math.sin(angle) * distanceVariation;\n\n        // Calculate radius between min and max with controlled variation\n        var radiusRange = this.maxRadius - this.minRadius;\n        var radiusFactor = this.seededRandom(0.6, 0.8);\n        var radius = this.minRadius + radiusRange * radiusFactor;\n        balls.push({\n          x: x,\n          y: y,\n          r: radius,\n          c: [x, y] // Center coordinates as array for calculations\n        });\n      }\n      return balls;\n    }\n  }, {\n    key: \"createMetaballPath\",\n    value: function createMetaballPath(balls) {\n      // We need at least 3 balls to create a smooth metaball\n      if (balls.length < 2) return null;\n      var pathData = '';\n      for (var i = 0; i < balls.length; i++) {\n        // Take current ball and next two balls to create curves\n        var circles = [balls[i], balls[(i + 1) % balls.length], balls[(i + 2) % balls.length]];\n\n        // Calculate points and handles for metaball path between first and second ball\n        var pointsAndHandles = this.curvesBetweenCircles(circles[0].r, circles[1].r, circles[0].c, circles[1].c, this.handleSize, this.tension);\n\n        // If we couldn't calculate curves (e.g., circles too close), skip\n        if (!pointsAndHandles) continue;\n\n        // Calculate for the next pair, to draw arch\n        var next = this.curvesBetweenCircles(circles[1].r, circles[2].r, circles[1].c, circles[2].c, this.handleSize, this.tension);\n\n        // If we couldn't calculate next curves, skip\n        if (!next) continue;\n\n        // Set the starting point of the path ONLY if it's the first valid segment\n        if (pathData === '') {\n          pathData += \"M \".concat(pointsAndHandles.p[1][0], \",\").concat(pointsAndHandles.p[1][1], \" \");\n        }\n\n        // Draw bezier curve and arc\n        pathData += \"C \".concat(pointsAndHandles.h[1][0], \",\").concat(pointsAndHandles.h[1][1], \" \");\n        pathData += \"\".concat(pointsAndHandles.h[3][0], \",\").concat(pointsAndHandles.h[3][1], \" \");\n        pathData += \"\".concat(pointsAndHandles.p[3][0], \",\").concat(pointsAndHandles.p[3][1], \" \");\n        pathData += \"A \".concat(next.r1, \",\").concat(next.r1, \" 1 0 1 \").concat(next.p[1][0], \",\").concat(next.p[1][1], \" \");\n      }\n\n      // Close the path if we have a valid path\n      if (pathData !== '') {\n        pathData += 'Z';\n      }\n      return pathData;\n    }\n  }, {\n    key: \"createSVGElements\",\n    value: function createSVGElements(balls, pathData) {\n      var svg = '';\n\n      // Add the main metaball path if it exists\n      if (pathData && pathData !== '') {\n        svg += \"<path \\n                d=\\\"\".concat(pathData, \"\\\" \\n                fill=\\\"white\\\" \\n                stroke=\\\"none\\\" \\n            />\");\n      }\n      return svg;\n    }\n\n    // Math utility functions\n  }, {\n    key: \"dist\",\n    value: function dist(point1, point2) {\n      return Math.sqrt(Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2));\n    }\n  }, {\n    key: \"angle\",\n    value: function angle(point1, point2) {\n      return Math.atan2(point1[1] - point2[1], point1[0] - point2[0]);\n    }\n  }, {\n    key: \"getVector\",\n    value: function getVector(center, angle, radius) {\n      return [center[0] + radius * Math.cos(angle), center[1] + radius * Math.sin(angle)];\n    }\n\n    /**\n     * Calculates curves between two circles for metaball effect\n     * Based on Metaball script by SATO Hiroyuki\n     */\n  }, {\n    key: \"curvesBetweenCircles\",\n    value: function curvesBetweenCircles(radius1, radius2, center1, center2) {\n      var handleSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2.4;\n      var v = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.5;\n      var HALF_PI = Math.PI / 2;\n      var d = this.dist(center1, center2);\n      var u1 = 0,\n        u2 = 0;\n\n      // Check if the circles are too close or far apart\n      if (radius1 === 0 || radius2 === 0 || d <= Math.abs(radius1 - radius2)) {\n        return null;\n      }\n\n      // Calculate angles when circles intersect\n      if (d < radius1 + radius2) {\n        u1 = Math.acos((radius1 * radius1 + d * d - radius2 * radius2) / (2 * radius1 * d));\n        u2 = Math.acos((radius2 * radius2 + d * d - radius1 * radius1) / (2 * radius2 * d));\n      }\n\n      // Calculate all the angles\n      var angleBetweenCenters = this.angle(center2, center1);\n      var maxSpread = Math.acos((radius1 - radius2) / d);\n      var angle1 = angleBetweenCenters + u1 + (maxSpread - u1) * v;\n      var angle2 = angleBetweenCenters - u1 - (maxSpread - u1) * v;\n      var angle3 = angleBetweenCenters + Math.PI - u2 - (Math.PI - u2 - maxSpread) * v;\n      var angle4 = angleBetweenCenters - Math.PI + u2 + (Math.PI - u2 - maxSpread) * v;\n\n      // Calculate points\n      var p1 = this.getVector(center1, angle1, radius1);\n      var p2 = this.getVector(center1, angle2, radius1);\n      var p3 = this.getVector(center2, angle3, radius2);\n      var p4 = this.getVector(center2, angle4, radius2);\n\n      // Define handle length by the distance between both ends of the curve\n      var totalRadius = radius1 + radius2;\n      var d2Base = Math.min(v * handleSize, this.dist(p1, p3) / totalRadius);\n\n      // Take into account when circles are overlapping\n      var d2 = d2Base * Math.min(1, d * 2 / (radius1 + radius2));\n      var r1 = radius1 * d2;\n      var r2 = radius2 * d2;\n\n      // Calculate handle points\n      var h1 = this.getVector(p1, angle1 - HALF_PI, r1);\n      var h2 = this.getVector(p2, angle2 + HALF_PI, r1);\n      var h3 = this.getVector(p3, angle3 + HALF_PI, r2);\n      var h4 = this.getVector(p4, angle4 - HALF_PI, r2);\n      return {\n        p: [p1, p2, p3, p4],\n        h: [h1, h2, h3, h4],\n        escaped: d > radius1,\n        r: radius2,\n        r1: radius1\n      };\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MetaBalls, \"parameters\", {\n  ballCount: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  minRadius: {\n    min: 10,\n    max: 40,\n    \"default\": 35\n  },\n  maxRadius: {\n    min: 20,\n    max: 80,\n    \"default\": 25\n  },\n  spacing: {\n    min: 60,\n    max: 120,\n    \"default\": 100\n  },\n  handleSize: {\n    min: 0.5,\n    max: 3.5,\n    \"default\": 2.0\n  },\n  tension: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MetaBalls);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MetaBalls.js?");

/***/ }),

/***/ "./src/shapes/Meteor.js":
/*!******************************!*\
  !*** ./src/shapes/Meteor.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar Meteor = /*#__PURE__*/function (_Shape) {\n  function Meteor() {\n    _classCallCheck(this, Meteor);\n    return _callSuper(this, Meteor, arguments);\n  }\n  _inherits(Meteor, _Shape);\n  return _createClass(Meteor, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var maxRadius = this.radius;\n\n      // Define a unique ID for the mask\n      var maskId = \"Meteor-mask-\".concat(Date.now());\n\n      // Create a clip path/mask to cut off the bottom of the shape\n      elements.push(\"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <rect x=\\\"-200\\\" y=\\\"-200\\\" width=\\\"400\\\" height=\\\"400\\\" fill=\\\"white\\\"/>\\n                    <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(maxRadius, \"\\\" fill=\\\"black\\\"/>\\n                </mask>\\n            </defs>\\n        \"));\n\n      // Create a group for all the arcs and lines with the mask applied\n      elements.push(\"<g mask=\\\"url(#\".concat(maskId, \")\\\">\"));\n\n      // Calculate adaptive gap based on radius and lineCount\n      var adaptiveGap = maxRadius / (this.lineCount - 0.5);\n\n      // Create each concentric arc with vertical lines\n      for (var i = 0; i < this.lineCount; i++) {\n        var currentRadius = maxRadius - i * adaptiveGap;\n        if (currentRadius <= 0) continue;\n\n        // Add the semicircular arc\n        elements.push(\"\\n                <path\\n                    d=\\\"M \".concat(-currentRadius, \",0 \\n                       A \").concat(currentRadius, \" \").concat(currentRadius, \" 0 0 1 \").concat(currentRadius, \",0\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    fill=\\\"none\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\\n            \"));\n\n        // Add left vertical line (extends beyond bottom for clean masking)\n        elements.push(\"\\n                <line\\n                    x1=\\\"\".concat(-currentRadius, \"\\\"\\n                    y1=\\\"0\\\"\\n                    x2=\\\"\").concat(-currentRadius, \"\\\"\\n                    y2=\\\"\").concat(this.bottomExtend, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\\n            \"));\n\n        // Add right vertical line (extends beyond bottom for clean masking)\n        elements.push(\"\\n                <line\\n                    x1=\\\"\".concat(currentRadius, \"\\\"\\n                    y1=\\\"0\\\"\\n                    x2=\\\"\").concat(currentRadius, \"\\\"\\n                    y2=\\\"\").concat(this.bottomExtend, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.strokeWidth, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                />\\n            \"));\n      }\n\n      // Close the group\n      elements.push(\"</g>\");\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(Meteor, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 90,\n    \"default\": 50\n  },\n  lineCount: {\n    min: 3,\n    max: 8,\n    \"default\": 3\n  },\n  strokeWidth: {\n    min: 1,\n    max: 20,\n    \"default\": 10\n  },\n  gap: {\n    min: 10,\n    max: 40,\n    \"default\": 18\n  },\n  bottomExtend: {\n    min: 80,\n    max: 150,\n    \"default\": 70\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Meteor);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Meteor.js?");

/***/ }),

/***/ "./src/shapes/MirroredCurveShape.js":
/*!******************************************!*\
  !*** ./src/shapes/MirroredCurveShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar MirroredCurveShape = /*#__PURE__*/function (_Shape) {\n  function MirroredCurveShape() {\n    _classCallCheck(this, MirroredCurveShape);\n    return _callSuper(this, MirroredCurveShape, arguments);\n  }\n  _inherits(MirroredCurveShape, _Shape);\n  return _createClass(MirroredCurveShape, [{\n    key: \"round\",\n    value: function round(num) {\n      return Math.round(num * 1000) / 1000;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate dimensions\n      var halfSize = this.round(this.size / 2);\n      var halfHeight = this.round(this.height / 2);\n      var r = this.round(this.curveRadius);\n      var controlPoint = this.round(r * 0.5522847498307936);\n      var gapOffset = this.round(this.gap / 2);\n\n      // Define points for the right half\n      var rightPoints = {\n        start: [gapOffset, -halfHeight + r],\n        topCurve: [[gapOffset, -halfHeight + controlPoint], [gapOffset + controlPoint, -halfHeight], [gapOffset + r, -halfHeight]],\n        topEdge: [halfSize, -halfHeight],\n        rightEdge: [halfSize, halfHeight - r],\n        bottomCurve: [[halfSize, halfHeight - controlPoint], [halfSize - controlPoint, halfHeight], [halfSize - r, halfHeight]],\n        bottomEdge: [gapOffset, halfHeight]\n      };\n\n      // Create right path\n      var rightPath = [\"M \".concat(rightPoints.start[0], \" \").concat(rightPoints.start[1]), \"C \".concat(rightPoints.topCurve.map(function (p) {\n        return \"\".concat(p[0], \" \").concat(p[1]);\n      }).join(' ')), \"H \".concat(rightPoints.topEdge[0]), \"V \".concat(rightPoints.rightEdge[1]), \"C \".concat(rightPoints.bottomCurve.map(function (p) {\n        return \"\".concat(p[0], \" \").concat(p[1]);\n      }).join(' ')), \"H \".concat(rightPoints.bottomEdge[0]), \"V \".concat(rightPoints.start[1]), 'Z'].join(' ');\n\n      // Define points for the left half (mirrored)\n      var leftPoints = {\n        start: [-gapOffset, -halfHeight + r],\n        topCurve: [[-gapOffset, -halfHeight + controlPoint], [-gapOffset - controlPoint, -halfHeight], [-gapOffset - r, -halfHeight]],\n        topEdge: [-halfSize, -halfHeight],\n        leftEdge: [-halfSize, halfHeight - r],\n        bottomCurve: [[-halfSize, halfHeight - controlPoint], [-halfSize + controlPoint, halfHeight], [-halfSize + r, halfHeight]],\n        bottomEdge: [-gapOffset, halfHeight]\n      };\n\n      // Create left path\n      var leftPath = [\"M \".concat(leftPoints.start[0], \" \").concat(leftPoints.start[1]), \"C \".concat(leftPoints.topCurve.map(function (p) {\n        return \"\".concat(p[0], \" \").concat(p[1]);\n      }).join(' ')), \"H \".concat(leftPoints.topEdge[0]), \"V \".concat(leftPoints.leftEdge[1]), \"C \".concat(leftPoints.bottomCurve.map(function (p) {\n        return \"\".concat(p[0], \" \").concat(p[1]);\n      }).join(' ')), \"H \".concat(leftPoints.bottomEdge[0]), \"V \".concat(leftPoints.start[1]), 'Z'].join(' ');\n      return \"\\n            <path d=\\\"\".concat(leftPath, \"\\\" fill=\\\"white\\\" />\\n            <path d=\\\"\").concat(rightPath, \"\\\" fill=\\\"white\\\" />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MirroredCurveShape, \"parameters\", {\n  size: {\n    min: 60,\n    max: 200,\n    \"default\": 120\n  },\n  height: {\n    min: 40,\n    max: 300,\n    \"default\": 120\n  },\n  curveRadius: {\n    min: 10,\n    max: 60,\n    \"default\": 40\n  },\n  gap: {\n    min: 0,\n    max: 50,\n    \"default\": 10\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MirroredCurveShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MirroredCurveShape.js?");

/***/ }),

/***/ "./src/shapes/ModulatedGridShape.js":
/*!******************************************!*\
  !*** ./src/shapes/ModulatedGridShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ModulatedGridShape = /*#__PURE__*/function (_Shape) {\n  function ModulatedGridShape() {\n    _classCallCheck(this, ModulatedGridShape);\n    return _callSuper(this, ModulatedGridShape, arguments);\n  }\n  _inherits(ModulatedGridShape, _Shape);\n  return _createClass(ModulatedGridShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Ensure parameters are valid\n      var horizontalUnits = Math.max(2, Math.round(this.horizontalUnits));\n      var verticalUnits = Math.max(2, Math.round(this.verticalUnits));\n      var padding = Math.max(0, this.padding);\n\n      // Calculate grid dimensions\n      var availableWidth = 200 - padding * 2;\n      var availableHeight = 200 - padding * 2;\n      var unitWidth = availableWidth / horizontalUnits;\n      var unitHeight = availableHeight / verticalUnits;\n      var totalWidth = unitWidth * horizontalUnits;\n      var totalHeight = unitHeight * verticalUnits;\n\n      // Center the pattern\n      var offsetX = -totalWidth / 2;\n      var offsetY = -totalHeight / 2;\n\n      // Create pattern grid (true = filled, false = empty)\n      var grid = Array(verticalUnits).fill().map(function () {\n        return Array(horizontalUnits).fill(false);\n      });\n\n      // Apply the selected pattern\n      this.applyPattern(grid, horizontalUnits, verticalUnits);\n\n      // Generate rectangles from the grid\n      var rectangles = [];\n      for (var row = 0; row < verticalUnits; row++) {\n        for (var col = 0; col < horizontalUnits; col++) {\n          if (grid[row][col]) {\n            var x = offsetX + col * unitWidth;\n            var y = offsetY + row * unitHeight;\n            rectangles.push(\"M\".concat(x, \",\").concat(y, \" h\").concat(unitWidth, \" v\").concat(unitHeight, \" h\").concat(-unitWidth, \" Z\"));\n          }\n        }\n      }\n      return \"<path d=\\\"\".concat(rectangles.join(' '), \"\\\" fill=\\\"white\\\" />\");\n    }\n  }, {\n    key: \"applyPattern\",\n    value: function applyPattern(grid, horizontalUnits, verticalUnits) {\n      var symmetryType = Math.round(this.symmetry);\n      var variationType = Math.round(this.variation);\n\n      // Determine pattern type based on variation parameter\n      switch (variationType) {\n        case 0:\n          // Checkerboard\n          for (var row = 0; row < verticalUnits; row++) {\n            for (var col = 0; col < horizontalUnits; col++) {\n              grid[row][col] = (row + col) % 2 === 0;\n            }\n          }\n          break;\n        case 1:\n          // Modulated columns\n          for (var _row = 0; _row < verticalUnits; _row++) {\n            for (var _col = 0; _col < horizontalUnits; _col++) {\n              // Create a pattern where only specific columns have cells on certain rows\n              grid[_row][_col] = _col % 2 === 0 && _row % 3 !== 1 || _col % 2 === 1 && _row % 3 === 1;\n            }\n          }\n          break;\n        case 2: // Simple block pattern\n        default:\n          // Pattern based on position in grid - minimal but interesting\n          for (var _row2 = 0; _row2 < verticalUnits; _row2++) {\n            for (var _col2 = 0; _col2 < horizontalUnits; _col2++) {\n              grid[_row2][_col2] = (_col2 + Math.floor(_row2 / 2)) % 2 === 0;\n            }\n          }\n          break;\n      }\n\n      // Apply symmetry if needed\n      if (symmetryType > 0) {\n        this.applySymmetry(grid, horizontalUnits, verticalUnits, symmetryType);\n      }\n    }\n  }, {\n    key: \"applySymmetry\",\n    value: function applySymmetry(grid, horizontalUnits, verticalUnits, symmetryType) {\n      // Make a copy of the original grid\n      var originalGrid = grid.map(function (row) {\n        return _toConsumableArray(row);\n      });\n      if (symmetryType === 1) {\n        // Horizontal symmetry\n        var midRow = Math.floor(verticalUnits / 2);\n        for (var row = 0; row < midRow; row++) {\n          for (var col = 0; col < horizontalUnits; col++) {\n            // Mirror the top half to bottom half\n            grid[verticalUnits - 1 - row][col] = originalGrid[row][col];\n          }\n        }\n      } else {\n        // Full symmetry (horizontal and vertical)\n        var _midRow = Math.floor(verticalUnits / 2);\n        var midCol = Math.floor(horizontalUnits / 2);\n\n        // Copy top-left quadrant to other quadrants\n        for (var _row3 = 0; _row3 < _midRow; _row3++) {\n          for (var _col3 = 0; _col3 < midCol; _col3++) {\n            // Mirror to top-right\n            grid[_row3][horizontalUnits - 1 - _col3] = originalGrid[_row3][_col3];\n\n            // Mirror to bottom-left\n            grid[verticalUnits - 1 - _row3][_col3] = originalGrid[_row3][_col3];\n\n            // Mirror to bottom-right\n            grid[verticalUnits - 1 - _row3][horizontalUnits - 1 - _col3] = originalGrid[_row3][_col3];\n          }\n        }\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ModulatedGridShape, \"parameters\", {\n  horizontalUnits: {\n    min: 3,\n    max: 8,\n    \"default\": 4\n  },\n  verticalUnits: {\n    min: 3,\n    max: 8,\n    \"default\": 4\n  },\n  padding: {\n    min: 10,\n    max: 40,\n    \"default\": 20\n  },\n  symmetry: {\n    min: 0,\n    max: 2,\n    \"default\": 1\n  },\n  variation: {\n    min: 0,\n    max: 2,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ModulatedGridShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ModulatedGridShape.js?");

/***/ }),

/***/ "./src/shapes/MoleculeShape.js":
/*!*************************************!*\
  !*** ./src/shapes/MoleculeShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar MoleculeShape = /*#__PURE__*/function (_Shape) {\n  function MoleculeShape() {\n    _classCallCheck(this, MoleculeShape);\n    return _callSuper(this, MoleculeShape, arguments);\n  }\n  _inherits(MoleculeShape, _Shape);\n  return _createClass(MoleculeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Generate node positions\n      var nodes = [];\n      var nodeCount = Math.round(this.nodes);\n      var rotationRad = this.rotation * Math.PI / 180;\n      var center = {\n        x: 0,\n        y: 0\n      };\n      for (var i = 0; i < nodeCount; i++) {\n        var angle = i * 2 * Math.PI / nodeCount + rotationRad;\n        var x = Math.cos(angle) * this.spread;\n        var y = Math.sin(angle) * this.spread;\n        nodes.push({\n          x: x,\n          y: y\n        });\n      }\n\n      // Create SVG elements for nodes and connections\n      var elements = [];\n\n      // Add connecting lines from center to each node\n      nodes.forEach(function (node) {\n        elements.push(\"<line \\n                x1=\\\"\".concat(center.x, \"\\\" \\n                y1=\\\"\").concat(center.y, \"\\\" \\n                x2=\\\"\").concat(node.x, \"\\\" \\n                y2=\\\"\").concat(node.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(_this.nodeSize / 3, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      });\n\n      // Add connecting lines between adjacent nodes\n      for (var _i = 0; _i < nodes.length; _i++) {\n        var start = nodes[_i];\n        var end = nodes[(_i + 1) % nodes.length];\n        elements.push(\"<line \\n                x1=\\\"\".concat(start.x, \"\\\" \\n                y1=\\\"\").concat(start.y, \"\\\" \\n                x2=\\\"\").concat(end.x, \"\\\" \\n                y2=\\\"\").concat(end.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.nodeSize / 3, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      }\n\n      // Add circles for each node\n      nodes.forEach(function (node) {\n        elements.push(\"<circle \\n                cx=\\\"\".concat(node.x, \"\\\" \\n                cy=\\\"\").concat(node.y, \"\\\" \\n                r=\\\"\").concat(_this.nodeSize / 1.5, \"\\\"\\n                fill=\\\"white\\\"\\n            />\"));\n      });\n\n      // Add center node\n      elements.push(\"<circle \\n            cx=\\\"\".concat(center.x, \"\\\" \\n            cy=\\\"\").concat(center.y, \"\\\" \\n            r=\\\"\").concat(this.centerSize / 2, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.nodeSize / 3, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MoleculeShape, \"parameters\", {\n  nodeSize: {\n    min: 5,\n    max: 40,\n    \"default\": 15\n  },\n  nodes: {\n    min: 4,\n    max: 12,\n    \"default\": 6\n  },\n  spread: {\n    min: 20,\n    max: 120,\n    \"default\": 80\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  centerSize: {\n    min: 5,\n    max: 30,\n    \"default\": 10\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MoleculeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MoleculeShape.js?");

/***/ }),

/***/ "./src/shapes/MondrianShape.js":
/*!*************************************!*\
  !*** ./src/shapes/MondrianShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar MondrianShape = /*#__PURE__*/function (_Shape) {\n  function MondrianShape() {\n    _classCallCheck(this, MondrianShape);\n    return _callSuper(this, MondrianShape, arguments);\n  }\n  _inherits(MondrianShape, _Shape);\n  return _createClass(MondrianShape, [{\n    key: \"subdivideRect\",\n    value: function subdivideRect(rect, depth, maxDepth) {\n      if (depth >= maxDepth) return [rect];\n      var isVertical = rect.width > rect.height;\n      var spacing = this.spacing;\n      if (isVertical) {\n        var splitX = rect.x + rect.width * this.ratio;\n        var leftRect = {\n          x: rect.x,\n          y: rect.y,\n          width: splitX - rect.x - spacing / 2,\n          height: rect.height\n        };\n        var rightRect = {\n          x: splitX + spacing / 2,\n          y: rect.y,\n          width: rect.x + rect.width - splitX - spacing / 2,\n          height: rect.height\n        };\n        if (leftRect.width > rightRect.width) {\n          return [].concat(_toConsumableArray(this.subdivideRect(leftRect, depth + 1, maxDepth)), [rightRect]);\n        } else {\n          return [leftRect].concat(_toConsumableArray(this.subdivideRect(rightRect, depth + 1, maxDepth)));\n        }\n      } else {\n        var splitY = rect.y + rect.height * this.ratio;\n        var topRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: splitY - rect.y - spacing / 2\n        };\n        var bottomRect = {\n          x: rect.x,\n          y: splitY + spacing / 2,\n          width: rect.width,\n          height: rect.y + rect.height - splitY - spacing / 2\n        };\n        if (topRect.height > bottomRect.height) {\n          return [].concat(_toConsumableArray(this.subdivideRect(topRect, depth + 1, maxDepth)), [bottomRect]);\n        } else {\n          return [topRect].concat(_toConsumableArray(this.subdivideRect(bottomRect, depth + 1, maxDepth)));\n        }\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Calculate base rectangle size (80% of available space)\n      var size = 160; // 80% of 400 (viewBox size)\n      var baseRect = {\n        x: -size / 2,\n        y: -size / 2,\n        width: size,\n        height: size\n      };\n\n      // Generate subdivided rectangles\n      var rectangles = this.subdivideRect(baseRect, 0, this.complexity);\n\n      // Create SVG elements for each rectangle\n      var elements = rectangles.map(function (rect) {\n        return \"\\n            <rect \\n                x=\\\"\".concat(rect.x, \"\\\" \\n                y=\\\"\").concat(rect.y, \"\\\" \\n                width=\\\"\").concat(rect.width, \"\\\" \\n                height=\\\"\").concat(rect.height, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(_this.thickness, \"\\\"\\n            />\");\n      });\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MondrianShape, \"parameters\", {\n  complexity: {\n    min: 2,\n    max: 8,\n    \"default\": 4\n  },\n  // Number of subdivisions\n  spacing: {\n    min: 0,\n    max: 25,\n    \"default\": 0\n  },\n  // Gap between rectangles\n  ratio: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  },\n  // Split ratio variation\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  } // Line thickness\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MondrianShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MondrianShape.js?");

/***/ }),

/***/ "./src/shapes/MultiRadialLinesShape.js":
/*!*********************************************!*\
  !*** ./src/shapes/MultiRadialLinesShape.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar MultiRadialLinesShape = /*#__PURE__*/function (_Shape) {\n  function MultiRadialLinesShape() {\n    _classCallCheck(this, MultiRadialLinesShape);\n    return _callSuper(this, MultiRadialLinesShape, arguments);\n  }\n  _inherits(MultiRadialLinesShape, _Shape);\n  return _createClass(MultiRadialLinesShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var angleStep = 2 * Math.PI / this.lineCount;\n\n      // Calculate all ring radii\n      var radii = [];\n      for (var ring = 0; ring < this.ringCount; ring++) {\n        radii.push(this.innerRadius + ring * this.ringSpacing);\n      }\n\n      // Generate lines for each ring\n      for (var _ring = 0; _ring < this.ringCount - 1; _ring++) {\n        var startRadius = radii[_ring];\n        var endRadius = radii[_ring + 1];\n        for (var i = 0; i < this.lineCount; i++) {\n          var baseAngle = i * angleStep;\n\n          // Show lines based on alternating pattern\n          // For even-numbered rings, show even-indexed lines\n          // For odd-numbered rings, show odd-indexed lines\n          if (i % 2 === _ring % 2) {\n            var x1 = startRadius * Math.cos(baseAngle);\n            var y1 = startRadius * Math.sin(baseAngle);\n            var x2 = endRadius * Math.cos(baseAngle);\n            var y2 = endRadius * Math.sin(baseAngle);\n            lines.push(\"<line \\n                        x1=\\\"\".concat(x1, \"\\\" \\n                        y1=\\\"\").concat(y1, \"\\\" \\n                        x2=\\\"\").concat(x2, \"\\\" \\n                        y2=\\\"\").concat(y2, \"\\\"\\n                        stroke=\\\"white\\\"\\n                        stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                        stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                    />\"));\n          }\n        }\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(MultiRadialLinesShape, \"parameters\", {\n  innerRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 25\n  },\n  ringSpacing: {\n    min: 10,\n    max: 100,\n    \"default\": 20\n  },\n  ringCount: {\n    min: 2,\n    max: 6,\n    \"default\": 4\n  },\n  lineCount: {\n    min: 3,\n    max: 48,\n    \"default\": 40\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 5\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'butt'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MultiRadialLinesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/MultiRadialLinesShape.js?");

/***/ }),

/***/ "./src/shapes/NestedCrossShape.js":
/*!****************************************!*\
  !*** ./src/shapes/NestedCrossShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar NestedCrossShape = /*#__PURE__*/function (_Shape) {\n  function NestedCrossShape() {\n    _classCallCheck(this, NestedCrossShape);\n    return _callSuper(this, NestedCrossShape, arguments);\n  }\n  _inherits(NestedCrossShape, _Shape);\n  return _createClass(NestedCrossShape, [{\n    key: \"calculateAdaptiveParameters\",\n    value: function calculateAdaptiveParameters() {\n      var baseSize = Math.max(this.armLength + this.armWidth / 2, this.armWidth + this.armLength / 2) + this.thickness;\n      var effectiveSpacing = this.spacing + this.thickness;\n      var maxSize = baseSize + (this.count - 1) * effectiveSpacing;\n      var maxAllowedSize = this.viewBoxHalf * 0.8;\n      var scale = maxSize > maxAllowedSize ? maxAllowedSize / maxSize : 1;\n      this.adaptiveArmLength = this.armLength * scale;\n      this.adaptiveArmWidth = this.armWidth * scale;\n      this.adaptiveSpacing = this.spacing * scale;\n      this.adaptiveThickness = this.thickness * scale;\n      this.adaptiveBaseRadius = this.baseRadius * scale;\n      this.adaptiveRadiusGrowth = this.radiusGrowth * scale;\n      var maxSafeSize = this.viewBoxHalf * 0.8;\n      var maxRepetitions = Math.floor((maxSafeSize - baseSize * scale) / (effectiveSpacing * scale)) + 1;\n      this.adaptiveCount = Math.min(this.count, maxRepetitions);\n    }\n  }, {\n    key: \"calculateCornerRadius\",\n    value: function calculateCornerRadius(repetition) {\n      // Calculate the cross dimensions for this repetition\n      var size = repetition * (this.adaptiveSpacing + this.adaptiveThickness);\n      var halfWidth = this.adaptiveArmWidth / 2 + size;\n      var fullLength = this.adaptiveArmLength + size;\n\n      // Calculate the maximum safe radius that won't break the cross shape\n      var maxSafeRadius = Math.min(halfWidth, (fullLength - halfWidth) / 2);\n\n      // Use both baseRadius and radiusGrowth to calculate desired radius\n      var desiredRadius = this.adaptiveBaseRadius + repetition * this.adaptiveRadiusGrowth;\n\n      // Return the smaller of desired and safe radius\n      return Math.min(desiredRadius, maxSafeRadius);\n    }\n  }, {\n    key: \"generateCross\",\n    value: function generateCross(repetition) {\n      var size = repetition * (this.adaptiveSpacing + this.adaptiveThickness);\n      var halfWidth = this.adaptiveArmWidth / 2 + size;\n      var fullLength = this.adaptiveArmLength + size;\n\n      // Get the calculated radius for this repetition\n      var cornerRadius = this.calculateCornerRadius(repetition);\n\n      // Helper function to create arc segments\n      var createArc = function createArc(startX, startY, radiusX, radiusY, largeArc, sweep, endX, endY) {\n        return \"A \".concat(radiusX, \" \").concat(radiusY, \" 0 \").concat(largeArc, \" \").concat(sweep, \" \").concat(endX, \" \").concat(endY);\n      };\n\n      // Create the path\n      var path = [// Starting point (top-left of vertical arm)\n      \"M \".concat(-halfWidth, \" \").concat(-fullLength + cornerRadius),\n      // Top arm left corner\n      createArc(-halfWidth, -fullLength + cornerRadius, cornerRadius, cornerRadius, 0, 1, -halfWidth + cornerRadius, -fullLength), // Top arm\n      \"L \".concat(halfWidth - cornerRadius, \" \").concat(-fullLength), createArc(halfWidth - cornerRadius, -fullLength, cornerRadius, cornerRadius, 0, 1, halfWidth, -fullLength + cornerRadius), // Right arm top\n      \"L \".concat(halfWidth, \" \").concat(-halfWidth), \"L \".concat(fullLength - cornerRadius, \" \").concat(-halfWidth), createArc(fullLength - cornerRadius, -halfWidth, cornerRadius, cornerRadius, 0, 1, fullLength, -halfWidth + cornerRadius), // Right arm\n      \"L \".concat(fullLength, \" \").concat(halfWidth - cornerRadius), createArc(fullLength, halfWidth - cornerRadius, cornerRadius, cornerRadius, 0, 1, fullLength - cornerRadius, halfWidth), // Bottom arm right\n      \"L \".concat(halfWidth, \" \").concat(halfWidth), \"L \".concat(halfWidth, \" \").concat(fullLength - cornerRadius), createArc(halfWidth, fullLength - cornerRadius, cornerRadius, cornerRadius, 0, 1, halfWidth - cornerRadius, fullLength), // Bottom arm\n      \"L \".concat(-halfWidth + cornerRadius, \" \").concat(fullLength), createArc(-halfWidth + cornerRadius, fullLength, cornerRadius, cornerRadius, 0, 1, -halfWidth, fullLength - cornerRadius), // Left arm bottom\n      \"L \".concat(-halfWidth, \" \").concat(halfWidth), \"L \".concat(-fullLength + cornerRadius, \" \").concat(halfWidth), createArc(-fullLength + cornerRadius, halfWidth, cornerRadius, cornerRadius, 0, 1, -fullLength, halfWidth - cornerRadius), // Left arm\n      \"L \".concat(-fullLength, \" \").concat(-halfWidth + cornerRadius), createArc(-fullLength, -halfWidth + cornerRadius, cornerRadius, cornerRadius, 0, 1, -fullLength + cornerRadius, -halfWidth), // Close the shape\n      \"L \".concat(-halfWidth, \" \").concat(-halfWidth), 'Z'];\n      return path.join(' ');\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      this.viewBoxHalf = 200;\n      this.calculateAdaptiveParameters();\n      return Array.from({\n        length: this.adaptiveCount\n      }, function (_, i) {\n        return \"<path \\n                d=\\\"\".concat(_this.generateCross(i), \"\\\" \\n                fill=\\\"none\\\" \\n                stroke=\\\"white\\\" \\n                stroke-width=\\\"\").concat(_this.adaptiveThickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\");\n      }).join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(NestedCrossShape, \"parameters\", {\n  armLength: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  armWidth: {\n    min: 0,\n    max: 100,\n    \"default\": 7\n  },\n  count: {\n    min: 1,\n    max: 24,\n    \"default\": 5\n  },\n  spacing: {\n    min: 5,\n    max: 30,\n    \"default\": 5\n  },\n  thickness: {\n    min: 0.5,\n    max: 5,\n    \"default\": 2.2\n  },\n  baseRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 50\n  },\n  radiusGrowth: {\n    min: 0,\n    max: 20,\n    \"default\": 12\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NestedCrossShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/NestedCrossShape.js?");

/***/ }),

/***/ "./src/shapes/NestedSquares.js":
/*!*************************************!*\
  !*** ./src/shapes/NestedSquares.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar NestedSquaresShape = /*#__PURE__*/function (_Shape) {\n  function NestedSquaresShape() {\n    _classCallCheck(this, NestedSquaresShape);\n    return _callSuper(this, NestedSquaresShape, arguments);\n  }\n  _inherits(NestedSquaresShape, _Shape);\n  return _createClass(NestedSquaresShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Start with the outermost path\n      var pathData = '';\n      var innerScale = Math.cos(Math.PI / 4); // Scale factor for 45 rotation\n\n      for (var i = 0; i < this.count; i++) {\n        var currentSize = this.size - i * this.spacing;\n        if (currentSize <= 0) break;\n\n        // Scale alternating squares\n        if (i % 2 !== 0) {\n          currentSize *= innerScale;\n        }\n\n        // Each square rotates 45 more than the previous\n        var rotation = 45 * i;\n\n        // Add outer boundary of current shape\n        pathData += this.getSquarePath(currentSize, rotation);\n      }\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n            fill-rule=\\\"evenodd\\\"\\n        />\");\n    }\n  }, {\n    key: \"getSquarePath\",\n    value: function getSquarePath(size, rotation) {\n      var halfSize = size / 2;\n      var angleRad = rotation * Math.PI / 180;\n      var cos = Math.cos(angleRad);\n      var sin = Math.sin(angleRad);\n\n      // Calculate corners\n      var points = [[-halfSize, -halfSize], [halfSize, -halfSize], [halfSize, halfSize], [-halfSize, halfSize]].map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        return [x * cos - y * sin, x * sin + y * cos];\n      });\n\n      // Create path moving clockwise for outer shapes, counter-clockwise for cutouts\n      var _points = _slicedToArray(points, 4),\n        p1 = _points[0],\n        p2 = _points[1],\n        p3 = _points[2],\n        p4 = _points[3];\n      return \" M \".concat(p1[0], \",\").concat(p1[1], \" L \").concat(p2[0], \",\").concat(p2[1], \" L \").concat(p3[0], \",\").concat(p3[1], \" L \").concat(p4[0], \",\").concat(p4[1], \" Z\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(NestedSquaresShape, \"parameters\", {\n  size: {\n    min: 100,\n    max: 200,\n    \"default\": 150\n  },\n  count: {\n    min: 1,\n    max: 6,\n    \"default\": 2\n  },\n  spacing: {\n    min: 10,\n    max: 50,\n    \"default\": 25\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NestedSquaresShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/NestedSquares.js?");

/***/ }),

/***/ "./src/shapes/NestedTriangles.js":
/*!***************************************!*\
  !*** ./src/shapes/NestedTriangles.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar NestedTrianglesShape = /*#__PURE__*/function (_Shape) {\n  function NestedTrianglesShape() {\n    _classCallCheck(this, NestedTrianglesShape);\n    return _callSuper(this, NestedTrianglesShape, arguments);\n  }\n  _inherits(NestedTrianglesShape, _Shape);\n  return _createClass(NestedTrianglesShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var triangles = [];\n      var heightFactor = Math.sqrt(3) / 2;\n\n      // Base size calculations\n      var outerSize = this.maxSize;\n      var height = outerSize * heightFactor;\n\n      // Calculate spacing reduction for each level\n      var reduction = this.spacing / Math.cos(Math.PI / 6);\n      for (var i = 0; i < this.count; i++) {\n        var currentSize = outerSize - i * reduction * 2;\n        if (currentSize <= 0) break;\n        var currentHeight = currentSize * heightFactor;\n        var halfWidth = currentSize / 2;\n        var halfHeight = currentHeight / 2;\n\n        // Calculate progressive offset based on triangle position\n        // First triangle (i=0) gets no offset, last triangle gets full offset\n        var progressiveOffset = i === 0 ? 0 : this.yOffset * (i / (this.count - 1));\n        var points = [\"0,\".concat(-halfHeight + progressiveOffset), // top\n        \"\".concat(halfWidth, \",\").concat(halfHeight + progressiveOffset), // bottom right\n        \"\".concat(-halfWidth, \",\").concat(halfHeight + progressiveOffset) // bottom left\n        ];\n        triangles.push(\"<polygon \\n                points=\\\"\".concat(points.join(' '), \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            />\"));\n      }\n      return triangles.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(NestedTrianglesShape, \"parameters\", {\n  count: {\n    min: 2,\n    max: 12,\n    \"default\": 4\n  },\n  spacing: {\n    min: 5,\n    max: 40,\n    \"default\": 25\n  },\n  maxSize: {\n    min: 100,\n    max: 300,\n    \"default\": 169\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 6\n  },\n  yOffset: {\n    min: -200,\n    max: 200,\n    \"default\": 24\n  } // Pattern shift parameter\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NestedTrianglesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/NestedTriangles.js?");

/***/ }),

/***/ "./src/shapes/NodedRect.js":
/*!*********************************!*\
  !*** ./src/shapes/NodedRect.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar NodedRect = /*#__PURE__*/function (_Shape) {\n  function NodedRect() {\n    _classCallCheck(this, NodedRect);\n    return _callSuper(this, NodedRect, arguments);\n  }\n  _inherits(NodedRect, _Shape);\n  return _createClass(NodedRect, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n      var boardW = this.boardWidth * scale;\n      var boardH = this.boardHeight * scale;\n      var traceThickness = this.traceThickness * scale;\n      var nodeRadius = this.nodeRadius * scale;\n      var spacing = this.spacing * scale;\n\n      // Calculate grid dimensions\n      var cols = Math.floor(boardW / spacing);\n      var rows = Math.floor(boardH / spacing);\n      var gridWidth = cols * spacing;\n      var gridHeight = rows * spacing;\n      var offsetX = -gridWidth / 2;\n      var offsetY = -gridHeight / 2;\n\n      // Generate node positions\n      var nodePositions = [];\n      for (var row = 0; row <= rows; row++) {\n        for (var col = 0; col <= cols; col++) {\n          var x = offsetX + col * spacing;\n          var y = offsetY + row * spacing;\n          nodePositions.push({\n            x: x,\n            y: y\n          });\n        }\n      }\n      var gridCols = cols + 1;\n      var elements = [];\n\n      // Draw traces\n      for (var _row = 0; _row <= rows; _row++) {\n        for (var _col = 0; _col <= cols; _col++) {\n          var index = _row * gridCols + _col;\n          var current = nodePositions[index];\n\n          // Horizontal traces\n          if (_col < cols) {\n            var rightNeighbor = nodePositions[index + 1];\n            elements.push(\"<line\\n                       x1=\\\"\".concat(current.x, \"\\\"\\n                       y1=\\\"\").concat(current.y, \"\\\"\\n                       x2=\\\"\").concat(rightNeighbor.x, \"\\\"\\n                       y2=\\\"\").concat(rightNeighbor.y, \"\\\"\\n                       stroke=\\\"white\\\"\\n                       stroke-width=\\\"\").concat(traceThickness, \"\\\"\\n                   />\"));\n          }\n\n          // Vertical traces\n          if (_row < rows) {\n            var bottomNeighbor = nodePositions[index + gridCols];\n            elements.push(\"<line\\n                       x1=\\\"\".concat(current.x, \"\\\"\\n                       y1=\\\"\").concat(current.y, \"\\\"\\n                       x2=\\\"\").concat(bottomNeighbor.x, \"\\\"\\n                       y2=\\\"\").concat(bottomNeighbor.y, \"\\\"\\n                       stroke=\\\"white\\\"\\n                       stroke-width=\\\"\").concat(traceThickness, \"\\\"\\n                   />\"));\n          }\n\n          // Diagonal traces\n          if (_col < cols && _row < rows) {\n            var bottomRight = nodePositions[index + gridCols + 1];\n            elements.push(\"<line\\n                       x1=\\\"\".concat(current.x, \"\\\"\\n                       y1=\\\"\").concat(current.y, \"\\\"\\n                       x2=\\\"\").concat(bottomRight.x, \"\\\"\\n                       y2=\\\"\").concat(bottomRight.y, \"\\\"\\n                       stroke=\\\"white\\\"\\n                       stroke-width=\\\"\").concat(traceThickness, \"\\\"\\n                   />\"));\n          }\n          if (_col > 0 && _row < rows) {\n            var bottomLeft = nodePositions[index + gridCols - 1];\n            elements.push(\"<line\\n                       x1=\\\"\".concat(current.x, \"\\\"\\n                       y1=\\\"\").concat(current.y, \"\\\"\\n                       x2=\\\"\").concat(bottomLeft.x, \"\\\"\\n                       y2=\\\"\").concat(bottomLeft.y, \"\\\"\\n                       stroke=\\\"white\\\"\\n                       stroke-width=\\\"\").concat(traceThickness, \"\\\"\\n                   />\"));\n          }\n        }\n      }\n\n      // Draw nodes\n      for (var _i = 0, _nodePositions = nodePositions; _i < _nodePositions.length; _i++) {\n        var point = _nodePositions[_i];\n        elements.push(\"<circle\\n               cx=\\\"\".concat(point.x, \"\\\"\\n               cy=\\\"\").concat(point.y, \"\\\"\\n               r=\\\"\").concat(nodeRadius, \"\\\"\\n               fill=\\\"white\\\"\\n           />\"));\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(NodedRect, \"parameters\", {\n  boardWidth: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  boardHeight: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  cornerRadius: {\n    min: 0,\n    max: 60,\n    \"default\": 20\n  },\n  traceThickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  nodeRadius: {\n    min: 2,\n    max: 10,\n    \"default\": 4\n  },\n  spacing: {\n    min: 10,\n    max: 100,\n    \"default\": 50\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NodedRect);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/NodedRect.js?");

/***/ }),

/***/ "./src/shapes/NodesNetworkShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/NodesNetworkShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar NodesNetworkShape = /*#__PURE__*/function (_Shape) {\n  function NodesNetworkShape() {\n    _classCallCheck(this, NodesNetworkShape);\n    return _callSuper(this, NodesNetworkShape, arguments);\n  }\n  _inherits(NodesNetworkShape, _Shape);\n  return _createClass(NodesNetworkShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n      var centerX = 0;\n      var centerY = 0;\n\n      // Scale parameters\n      var boardW = this.boardWidth * scale;\n      var boardH = this.boardHeight * scale;\n      var thickness = this.lineThickness * scale;\n      var nodeR = this.nodeRadius * scale;\n      var chipS = this.chipSize * scale;\n      var elements = [];\n\n      // Main board rectangle\n      var boardX = centerX - boardW / 2;\n      var boardY = centerY - boardH / 2;\n\n      // Central CPU chip\n      var cpuX = centerX - chipS / 2;\n      var cpuY = centerY - chipS / 2;\n      elements.push(\"<rect\\n           x=\\\"\".concat(cpuX, \"\\\"\\n           y=\\\"\").concat(cpuY, \"\\\" \\n           width=\\\"\").concat(chipS, \"\\\"\\n           height=\\\"\").concat(chipS, \"\\\"\\n           stroke=\\\"white\\\"\\n           stroke-width=\\\"\").concat(thickness, \"\\\"\\n           fill=\\\"none\\\"\\n       />\"));\n\n      // Corner chips\n      var cornerOffset = 10 * scale;\n      var cornerChips = [\n      // Top left\n      {\n        x: boardX + cornerOffset,\n        y: boardY + cornerOffset\n      },\n      // Top right  \n      {\n        x: boardX + boardW - chipS - cornerOffset,\n        y: boardY + cornerOffset\n      },\n      // Bottom left\n      {\n        x: boardX + cornerOffset,\n        y: boardY + boardH - chipS - cornerOffset\n      },\n      // Bottom right\n      {\n        x: boardX + boardW - chipS - cornerOffset,\n        y: boardY + boardH - chipS - cornerOffset\n      }];\n\n      // Add corner chips and connection lines\n      cornerChips.forEach(function (pos) {\n        // Add chip\n        elements.push(\"<rect\\n               x=\\\"\".concat(pos.x, \"\\\"\\n               y=\\\"\").concat(pos.y, \"\\\"\\n               width=\\\"\").concat(chipS, \"\\\"\\n               height=\\\"\").concat(chipS, \"\\\"\\n               stroke=\\\"white\\\" \\n               stroke-width=\\\"\").concat(thickness, \"\\\"\\n               fill=\\\"none\\\"\\n           />\"));\n\n        // Connection line from chip center to CPU center\n        var chipCenterX = pos.x + chipS / 2;\n        var chipCenterY = pos.y + chipS / 2;\n        elements.push(\"<line\\n               x1=\\\"\".concat(chipCenterX, \"\\\"\\n               y1=\\\"\").concat(chipCenterY, \"\\\"\\n               x2=\\\"\").concat(centerX, \"\\\"\\n               y2=\\\"\").concat(centerY, \"\\\"\\n               stroke=\\\"white\\\"\\n               stroke-width=\\\"\").concat(thickness, \"\\\"\\n               stroke-linecap=\\\"round\\\"\\n           />\"));\n\n        // Via circle at chip center\n        elements.push(\"<circle\\n               cx=\\\"\".concat(chipCenterX, \"\\\"\\n               cy=\\\"\").concat(chipCenterY, \"\\\"\\n               r=\\\"\").concat(nodeR, \"\\\"\\n               stroke=\\\"white\\\"\\n               stroke-width=\\\"\").concat(thickness, \"\\\"\\n               fill=\\\"none\\\"\\n           />\"));\n      });\n\n      // CPU center via\n      elements.push(\"<circle\\n           cx=\\\"\".concat(centerX, \"\\\"\\n           cy=\\\"\").concat(centerY, \"\\\"\\n           r=\\\"\").concat(nodeR, \"\\\"\\n           stroke=\\\"white\\\"\\n           stroke-width=\\\"\").concat(thickness, \"\\\"\\n           fill=\\\"none\\\"\\n       />\"));\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(NodesNetworkShape, \"parameters\", {\n  boardWidth: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  boardHeight: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  lineThickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  nodeRadius: {\n    min: 2,\n    max: 10,\n    \"default\": 4\n  },\n  chipSize: {\n    min: 20,\n    max: 80,\n    \"default\": 40\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NodesNetworkShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/NodesNetworkShape.js?");

/***/ }),

/***/ "./src/shapes/NotchForm.js":
/*!*********************************!*\
  !*** ./src/shapes/NotchForm.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar NotchForm = /*#__PURE__*/function (_Shape) {\n  function NotchForm() {\n    _classCallCheck(this, NotchForm);\n    return _callSuper(this, NotchForm, arguments);\n  }\n  _inherits(NotchForm, _Shape);\n  return _createClass(NotchForm, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var halfSize = this.size / 2;\n      var sideLength = this.size - this.cornerRadius * 2;\n      var spacing = sideLength / 4; // Divide side into 4 equal parts for 3 notches\n\n      var path = '';\n\n      // Helper to add notched side\n      var addNotchedSide = function addNotchedSide(start, end) {\n        var dx = end.x - start.x;\n        var dy = end.y - start.y;\n        var length = Math.sqrt(dx * dx + dy * dy);\n        var unitX = dx / length;\n        var unitY = dy / length;\n\n        // Perpendicular vector for notch depth\n        var perpX = -unitY;\n        var perpY = unitX;\n\n        // Starting point with first spacing\n        path += \"L \".concat(start.x + spacing * unitX, \" \").concat(start.y + spacing * unitY, \" \");\n\n        // Add three notches at the spacing points\n        for (var i = 0; i < 3; i++) {\n          var notchStart = {\n            x: start.x + spacing * (i + 1) * unitX,\n            y: start.y + spacing * (i + 1) * unitY\n          };\n\n          // Add notch with width\n          path += \"L \".concat(notchStart.x - _this.notchWidth / 2 * unitX, \" \").concat(notchStart.y - _this.notchWidth / 2 * unitY, \" \");\n          path += \"L \".concat(notchStart.x + _this.notchDepth * perpX, \" \").concat(notchStart.y + _this.notchDepth * perpY, \" \");\n          path += \"L \".concat(notchStart.x + _this.notchWidth / 2 * unitX, \" \").concat(notchStart.y + _this.notchWidth / 2 * unitY, \" \");\n        }\n        path += \"L \".concat(end.x, \" \").concat(end.y, \" \");\n      };\n\n      // Start with top-left corner\n      if (this.cornerRadius > 0) {\n        path = \"M \".concat(-halfSize, \" \").concat(-halfSize + this.cornerRadius, \" \");\n        path += \"A \".concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 0 \").concat(-halfSize + this.cornerRadius, \" \").concat(-halfSize, \" \");\n      } else {\n        path = \"M \".concat(-halfSize + this.cornerRadius, \" \").concat(-halfSize, \" \");\n      }\n\n      // Define corner points\n      var topLeft = {\n        x: -halfSize + this.cornerRadius,\n        y: -halfSize\n      };\n      var topRight = {\n        x: halfSize - this.cornerRadius,\n        y: -halfSize\n      };\n      var bottomRight = {\n        x: halfSize - this.cornerRadius,\n        y: halfSize\n      };\n      var bottomLeft = {\n        x: -halfSize + this.cornerRadius,\n        y: halfSize\n      };\n\n      // Add four sides with notches\n      addNotchedSide(topLeft, topRight);\n      if (this.cornerRadius > 0) {\n        path += \"A \".concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 0 \").concat(halfSize, \" \").concat(-halfSize + this.cornerRadius, \" \");\n      }\n      addNotchedSide({\n        x: halfSize,\n        y: -halfSize + this.cornerRadius\n      }, {\n        x: halfSize,\n        y: halfSize - this.cornerRadius\n      });\n      if (this.cornerRadius > 0) {\n        path += \"A \".concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 0 \").concat(halfSize - this.cornerRadius, \" \").concat(halfSize, \" \");\n      }\n      addNotchedSide(bottomRight, bottomLeft);\n      if (this.cornerRadius > 0) {\n        path += \"A \".concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 0 \").concat(-halfSize, \" \").concat(halfSize - this.cornerRadius, \" \");\n      }\n      addNotchedSide({\n        x: -halfSize,\n        y: halfSize - this.cornerRadius\n      }, {\n        x: -halfSize,\n        y: -halfSize + this.cornerRadius\n      });\n\n      // Close path with final corner arc\n      if (this.cornerRadius > 0) {\n        path += \"A \".concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 0 \").concat(-halfSize, \" \").concat(-halfSize + this.cornerRadius, \" \");\n      }\n      path += 'Z';\n      return \"\\n            <path\\n                d=\\\"\".concat(path, \"\\\"\\n                fill=\\\"white\\\"\\n            />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(NotchForm, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  notchDepth: {\n    min: 5,\n    max: 40,\n    \"default\": 20\n  },\n  notchWidth: {\n    min: 10,\n    max: 60,\n    \"default\": 30\n  },\n  cornerRadius: {\n    min: 0,\n    max: 40,\n    \"default\": 15\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NotchForm);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/NotchForm.js?");

/***/ }),

/***/ "./src/shapes/OctagonalFrame.js":
/*!**************************************!*\
  !*** ./src/shapes/OctagonalFrame.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar OctagonalFrameShape = /*#__PURE__*/function (_Shape) {\n  function OctagonalFrameShape() {\n    _classCallCheck(this, OctagonalFrameShape);\n    return _callSuper(this, OctagonalFrameShape, arguments);\n  }\n  _inherits(OctagonalFrameShape, _Shape);\n  return _createClass(OctagonalFrameShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var outerSize = 150;\n      var halfOuter = outerSize / 2;\n\n      // Calculate inner dimensions\n      var innerSize = outerSize * this.innerRatio;\n      var halfInner = innerSize / 2;\n\n      // Calculate corner cuts (ensuring they don't exceed half the size)\n      var outerCut = Math.min(this.cornerSize, outerSize / 2);\n      var innerCut = outerCut * (innerSize / outerSize); // Scale cut for inner shape\n\n      // Create outer octagonal path\n      var outerPath = this.createOctagonPath(-halfOuter, -halfOuter, outerSize, outerSize, outerCut);\n\n      // Create centered inner octagonal path (in reverse direction for cutout)\n      var innerPath = this.createOctagonPath(-halfInner, -halfInner, innerSize, innerSize, innerCut, true // reverse direction for cutout\n      );\n      return \"<path \\n            d=\\\"\".concat(outerPath, \" \").concat(innerPath, \"\\\"\\n            fill=\\\"white\\\"\\n            fill-rule=\\\"evenodd\\\"\\n        />\");\n    }\n  }, {\n    key: \"createOctagonPath\",\n    value: function createOctagonPath(x, y, width, height, cutSize) {\n      var reverse = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      var points = [[x + cutSize, y],\n      // Top edge start\n      [x + width - cutSize, y],\n      // Top edge end\n      [x + width, y + cutSize],\n      // Right top\n      [x + width, y + height - cutSize],\n      // Right bottom\n      [x + width - cutSize, y + height],\n      // Bottom edge end\n      [x + cutSize, y + height],\n      // Bottom edge start\n      [x, y + height - cutSize],\n      // Left bottom\n      [x, y + cutSize] // Left top\n      ];\n      if (reverse) {\n        points.reverse();\n      }\n      var commands = points.map(function (point, i) {\n        return i === 0 ? \"M \".concat(point[0], \" \").concat(point[1]) : \"L \".concat(point[0], \" \").concat(point[1]);\n      });\n      return commands.join(' ') + ' Z';\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OctagonalFrameShape, \"parameters\", {\n  innerRatio: {\n    min: 0.3,\n    max: 0.9,\n    \"default\": 0.65\n  },\n  cornerSize: {\n    min: 5,\n    max: 100,\n    \"default\": 35\n  } // Size of the 45 corner cuts\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OctagonalFrameShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OctagonalFrame.js?");

/***/ }),

/***/ "./src/shapes/OrbitalShape.js":
/*!************************************!*\
  !*** ./src/shapes/OrbitalShape.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar OrbitalShape = /*#__PURE__*/function (_Shape) {\n  function OrbitalShape() {\n    _classCallCheck(this, OrbitalShape);\n    return _callSuper(this, OrbitalShape, arguments);\n  }\n  _inherits(OrbitalShape, _Shape);\n  return _createClass(OrbitalShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.circleCount = Math.round(this.circleCount);\n      var elements = [];\n      var angleStep = 2 * Math.PI / this.circleCount;\n\n      // Draw outer circles and connecting lines\n      for (var i = 0; i < this.circleCount; i++) {\n        var angle = i * angleStep;\n        var nextAngle = (i + 1) % this.circleCount * angleStep;\n\n        // Calculate positions\n        var x = this.spacing * Math.cos(angle);\n        var y = this.spacing * Math.sin(angle);\n        var nextX = this.spacing * Math.cos(nextAngle);\n        var nextY = this.spacing * Math.sin(nextAngle);\n        var innerX = this.innerRadius * Math.cos(angle);\n        var innerY = this.innerRadius * Math.sin(angle);\n\n        // Add outer circle\n        elements.push(\"<circle \\n                cx=\\\"\".concat(x, \"\\\" \\n                cy=\\\"\").concat(y, \"\\\" \\n                r=\\\"\").concat(this.circleSize / 2, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n\n        // Add line to center\n        elements.push(\"<line \\n                x1=\\\"\".concat(x, \"\\\" \\n                y1=\\\"\").concat(y, \"\\\" \\n                x2=\\\"\").concat(innerX, \"\\\" \\n                y2=\\\"\").concat(innerY, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n            />\"));\n\n        // Add connecting line to next circle\n        elements.push(\"<line \\n                x1=\\\"\".concat(x, \"\\\" \\n                y1=\\\"\").concat(y, \"\\\" \\n                x2=\\\"\").concat(nextX, \"\\\" \\n                y2=\\\"\").concat(nextY, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n            />\"));\n      }\n\n      // Add center circle\n      elements.push(\"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(this.circleSize / 2, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(OrbitalShape, \"parameters\", {\n  circleCount: {\n    min: 3,\n    max: 12,\n    \"default\": 4\n  },\n  circleSize: {\n    min: 40,\n    max: 80,\n    \"default\": 40\n  },\n  thickness: {\n    min: 2,\n    max: 10,\n    \"default\": 4\n  },\n  spacing: {\n    min: 25,\n    max: 85,\n    \"default\": 60\n  },\n  innerRadius: {\n    min: 20,\n    max: 60,\n    \"default\": 20\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrbitalShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/OrbitalShape.js?");

/***/ }),

/***/ "./src/shapes/ParallelStripesCircle.js":
/*!*********************************************!*\
  !*** ./src/shapes/ParallelStripesCircle.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ParallelStripesCircle = /*#__PURE__*/function (_Shape) {\n  function ParallelStripesCircle() {\n    _classCallCheck(this, ParallelStripesCircle);\n    return _callSuper(this, ParallelStripesCircle, arguments);\n  }\n  _inherits(ParallelStripesCircle, _Shape);\n  return _createClass(ParallelStripesCircle, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate dimensions\n      var diameter = this.radius * 2;\n\n      // Calculate total height of stripes and gaps\n      var totalStripeHeight = this.lineCount * this.thickness;\n      var totalSpacing = (this.lineCount - 1) * this.spacing;\n      var totalHeight = totalStripeHeight + totalSpacing;\n\n      // Calculate starting Y position based on alignment\n      var startY;\n      switch (this.alignment) {\n        case 'top':\n          startY = -this.radius;\n          break;\n        case 'bottom':\n          startY = -this.radius + (diameter - totalHeight);\n          break;\n        default:\n          // center\n          startY = -totalHeight / 2;\n          break;\n      }\n\n      // Create unique mask ID\n      var maskId = \"stripesMask_\".concat(Math.random().toString(36).substr(2, 9));\n\n      // Generate stripes with uniform spacing\n      var stripes = [];\n      var currentY = startY;\n      for (var i = 0; i < this.lineCount; i++) {\n        stripes.push(\"<rect \\n                x=\\\"\".concat(-this.radius - 1, \"\\\" \\n                y=\\\"\").concat(currentY, \"\\\" \\n                width=\\\"\").concat((this.radius + 1) * 2, \"\\\" \\n                height=\\\"\").concat(this.thickness, \"\\\" \\n                fill=\\\"black\\\" \\n            />\"));\n        currentY += this.thickness + this.spacing;\n      }\n      return \"\\n            <defs>\\n                <clipPath id=\\\"\".concat(maskId, \"\\\">\\n                    <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(this.radius, \"\\\"/>\\n                </clipPath>\\n            </defs>\\n            <g clip-path=\\\"url(#\").concat(maskId, \")\\\">\\n                <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(this.radius, \"\\\" fill=\\\"white\\\" />\\n                \").concat(stripes.join('\\n'), \"\\n            </g>\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ParallelStripesCircle, \"parameters\", {\n  lineCount: {\n    min: 3,\n    max: 20,\n    \"default\": 8\n  },\n  thickness: {\n    min: 1,\n    max: 20,\n    \"default\": 9\n  },\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 90\n  },\n  spacing: {\n    min: 1,\n    max: 50,\n    \"default\": 20\n  },\n  alignment: {\n    options: ['center', 'top', 'bottom'],\n    \"default\": 'center'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelStripesCircle);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ParallelStripesCircle.js?");

/***/ }),

/***/ "./src/shapes/PedestalShape.js":
/*!*************************************!*\
  !*** ./src/shapes/PedestalShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PedestalShape = /*#__PURE__*/function (_Shape) {\n  function PedestalShape() {\n    _classCallCheck(this, PedestalShape);\n    return _callSuper(this, PedestalShape, arguments);\n  }\n  _inherits(PedestalShape, _Shape);\n  return _createClass(PedestalShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate center and scale based on viewBox\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var scale = 0.8;\n\n      // Scale parameters\n      var baseWidth = this.baseWidth * scale;\n      var columnWidth = this.columnWidth * scale;\n      var columnHeight = this.columnHeight * scale;\n      var baseHeight = this.baseHeight * scale;\n      var requestedCornerRadius = this.cornerRadius * scale;\n\n      // Calculate positions\n      var baseLeft = center.x - baseWidth / 2;\n      var baseRight = center.x + baseWidth / 2;\n      var columnLeft = center.x - columnWidth / 2;\n      var columnRight = center.x + columnWidth / 2;\n      var baseBottom = center.y + (columnHeight + baseHeight) / 2;\n      var baseTop = baseBottom - baseHeight;\n      var columnTop = baseTop - columnHeight;\n\n      // Calculate safe corner radius values (can't exceed half of width or height)\n      var baseCornerRadius = Math.min(requestedCornerRadius, baseWidth / 2, baseHeight / 2);\n      var columnCornerRadius = Math.min(requestedCornerRadius, columnWidth / 2, columnHeight / 2);\n\n      // Prepare the path for both shapes\n      var basePath, columnPath;\n      if (baseCornerRadius > 0) {\n        // Rounded base rectangle\n        basePath = \"\\n                M \".concat(baseLeft + baseCornerRadius, \" \").concat(baseTop, \"\\n                h \").concat(baseWidth - 2 * baseCornerRadius, \"\\n                a \").concat(baseCornerRadius, \" \").concat(baseCornerRadius, \" 0 0 1 \").concat(baseCornerRadius, \" \").concat(baseCornerRadius, \"\\n                v \").concat(baseHeight - 2 * baseCornerRadius, \"\\n                a \").concat(baseCornerRadius, \" \").concat(baseCornerRadius, \" 0 0 1 -\").concat(baseCornerRadius, \" \").concat(baseCornerRadius, \"\\n                h -\").concat(baseWidth - 2 * baseCornerRadius, \"\\n                a \").concat(baseCornerRadius, \" \").concat(baseCornerRadius, \" 0 0 1 -\").concat(baseCornerRadius, \" -\").concat(baseCornerRadius, \"\\n                v -\").concat(baseHeight - 2 * baseCornerRadius, \"\\n                a \").concat(baseCornerRadius, \" \").concat(baseCornerRadius, \" 0 0 1 \").concat(baseCornerRadius, \" -\").concat(baseCornerRadius, \"\\n                Z\\n            \");\n      } else {\n        // Non-rounded base rectangle\n        basePath = \"\\n                M \".concat(baseLeft, \" \").concat(baseTop, \"\\n                h \").concat(baseWidth, \"\\n                v \").concat(baseHeight, \"\\n                h -\").concat(baseWidth, \"\\n                v -\").concat(baseHeight, \"\\n                Z\\n            \");\n      }\n      if (columnCornerRadius > 0) {\n        // Rounded column rectangle\n        columnPath = \"\\n                M \".concat(columnLeft + columnCornerRadius, \" \").concat(columnTop, \"\\n                h \").concat(columnWidth - 2 * columnCornerRadius, \"\\n                a \").concat(columnCornerRadius, \" \").concat(columnCornerRadius, \" 0 0 1 \").concat(columnCornerRadius, \" \").concat(columnCornerRadius, \"\\n                v \").concat(columnHeight - 2 * columnCornerRadius, \"\\n                a \").concat(columnCornerRadius, \" \").concat(columnCornerRadius, \" 0 0 1 -\").concat(columnCornerRadius, \" \").concat(columnCornerRadius, \"\\n                h -\").concat(columnWidth - 2 * columnCornerRadius, \"\\n                a \").concat(columnCornerRadius, \" \").concat(columnCornerRadius, \" 0 0 1 -\").concat(columnCornerRadius, \" -\").concat(columnCornerRadius, \"\\n                v -\").concat(columnHeight - 2 * columnCornerRadius, \"\\n                a \").concat(columnCornerRadius, \" \").concat(columnCornerRadius, \" 0 0 1 \").concat(columnCornerRadius, \" -\").concat(columnCornerRadius, \"\\n                Z\\n            \");\n      } else {\n        // Non-rounded column rectangle\n        columnPath = \"\\n                M \".concat(columnLeft, \" \").concat(columnTop, \"\\n                h \").concat(columnWidth, \"\\n                v \").concat(columnHeight, \"\\n                h -\").concat(columnWidth, \"\\n                v -\").concat(columnHeight, \"\\n                Z\\n            \");\n      }\n\n      // Combine both paths into a single path element\n      return \"<path d=\\\"\".concat(basePath.trim(), \" \").concat(columnPath.trim(), \"\\\" fill=\\\"white\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PedestalShape, \"parameters\", {\n  baseWidth: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  columnWidth: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  columnHeight: {\n    min: 50,\n    max: 150,\n    \"default\": 120\n  },\n  baseHeight: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  },\n  cornerRadius: {\n    min: 0,\n    max: 40,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PedestalShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PedestalShape.js?");

/***/ }),

/***/ "./src/shapes/PerspectiveGridShape.js":
/*!********************************************!*\
  !*** ./src/shapes/PerspectiveGridShape.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PerspectiveGridShape = /*#__PURE__*/function (_Shape) {\n  function PerspectiveGridShape() {\n    _classCallCheck(this, PerspectiveGridShape);\n    return _callSuper(this, PerspectiveGridShape, arguments);\n  }\n  _inherits(PerspectiveGridShape, _Shape);\n  return _createClass(PerspectiveGridShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n\n      // Size parameters\n      var width = this.size;\n      var height = this.size;\n      var depth = this.depth;\n\n      // Convert rotation angles to radians\n      var rotX = this.rotationX * Math.PI / 180;\n      var rotY = this.rotationY * Math.PI / 180;\n\n      // Center offset for positioning\n      var halfWidth = width / 2;\n      var halfHeight = height / 2;\n\n      // Calculate actual cell dimensions\n      var cellWidth = (width - (this.columns + 1) * this.spacing) / this.columns;\n      var cellHeight = (height - (this.rows + 1) * this.spacing) / this.rows;\n\n      // Create all cells with 3D coordinates\n      var shapes = [];\n\n      // Create grid cells - proper 3D boxes\n      for (var row = 0; row < this.rows; row++) {\n        for (var col = 0; col < this.columns; col++) {\n          // Calculate position in grid (normalized from -1 to 1)\n          var normalizedCol = col / (this.columns - 1) * 2 - 1;\n          var normalizedRow = row / (this.rows - 1) * 2 - 1;\n\n          // Calculate top-left corner position\n          var x = -halfWidth + this.spacing + col * (cellWidth + this.spacing);\n          var y = -halfHeight + this.spacing + row * (cellHeight + this.spacing);\n\n          // Calculate z-depth based on distance from center\n          // This creates a curved surface effect for better perspective\n          var distanceFromCenter = Math.sqrt(normalizedCol * normalizedCol + normalizedRow * normalizedRow);\n          var cellDepth = depth * Math.min(distanceFromCenter, 1);\n\n          // Create a proper 3D cell with front face and back face\n          var cell = {\n            type: 'box',\n            // Front face (z=0)\n            frontFace: [{\n              x: x,\n              y: y,\n              z: 0\n            },\n            // Top-left front\n            {\n              x: x + cellWidth,\n              y: y,\n              z: 0\n            },\n            // Top-right front\n            {\n              x: x + cellWidth,\n              y: y + cellHeight,\n              z: 0\n            },\n            // Bottom-right front\n            {\n              x: x,\n              y: y + cellHeight,\n              z: 0\n            } // Bottom-left front\n            ],\n            // Back face (z=cellDepth)\n            backFace: [{\n              x: x,\n              y: y,\n              z: cellDepth\n            },\n            // Top-left back\n            {\n              x: x + cellWidth,\n              y: y,\n              z: cellDepth\n            },\n            // Top-right back\n            {\n              x: x + cellWidth,\n              y: y + cellHeight,\n              z: cellDepth\n            },\n            // Bottom-right back\n            {\n              x: x,\n              y: y + cellHeight,\n              z: cellDepth\n            } // Bottom-left back\n            ],\n            avgZ: cellDepth / 2 // for sorting\n          };\n          shapes.push(cell);\n        }\n      }\n\n      // Project points to 2D with improved perspective\n      var projectPoint = function projectPoint(point) {\n        // Make a copy of the point to avoid modifying the original\n        var p = _objectSpread({}, point);\n\n        // Calculate the center of the grid's bounding box\n        var centerX = 0; // We're already centering at origin\n        var centerY = 0;\n        var centerZ = depth / 2; // Center point between front and back\n\n        // Apply rotation around X axis (pitch) centered at the grid's center\n        var y1 = (p.y - centerY) * Math.cos(rotX) - (p.z - centerZ) * Math.sin(rotX) + centerY;\n        var z1 = (p.y - centerY) * Math.sin(rotX) + (p.z - centerZ) * Math.cos(rotX) + centerZ;\n\n        // Apply rotation around Y axis (yaw) centered at the grid's center\n        var x2 = (p.x - centerX) * Math.cos(rotY) + (z1 - centerZ) * Math.sin(rotY) + centerX;\n        var z2 = -(p.x - centerX) * Math.sin(rotY) + (z1 - centerZ) * Math.cos(rotY) + centerZ;\n\n        // Apply perspective projection with adjustable factor\n        var perspectiveFactor = 600; // Adjust for desired perspective strength\n        var scale = perspectiveFactor / (perspectiveFactor + z2);\n        return {\n          x: x2 * scale,\n          y: y1 * scale,\n          z: z2\n        };\n      };\n\n      // Sort shapes back to front for proper rendering\n      shapes.sort(function (a, b) {\n        // Calculate actual z after rotation\n        var aZ = a.avgZ * Math.cos(rotX) * Math.cos(rotY);\n        var bZ = b.avgZ * Math.cos(rotX) * Math.cos(rotY);\n        return bZ - aZ;\n      });\n\n      // Draw all shapes\n      for (var _i = 0, _shapes = shapes; _i < _shapes.length; _i++) {\n        var shape = _shapes[_i];\n        if (shape.type === 'box') {\n          // Project all points of the box\n          var frontFaceProjected = shape.frontFace.map(projectPoint);\n          var backFaceProjected = shape.backFace.map(projectPoint);\n\n          // Draw front face\n          elements.push(\"<path d=\\\"\\n          M\".concat(frontFaceProjected[0].x, \",\").concat(frontFaceProjected[0].y, \"\\n          L\").concat(frontFaceProjected[1].x, \",\").concat(frontFaceProjected[1].y, \"\\n          L\").concat(frontFaceProjected[2].x, \",\").concat(frontFaceProjected[2].y, \"\\n          L\").concat(frontFaceProjected[3].x, \",\").concat(frontFaceProjected[3].y, \"\\n          Z\\n        \\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.thickness, \"\\\" fill=\\\"none\\\" />\"));\n\n          // Draw back face\n          elements.push(\"<path d=\\\"\\n          M\".concat(backFaceProjected[0].x, \",\").concat(backFaceProjected[0].y, \"\\n          L\").concat(backFaceProjected[1].x, \",\").concat(backFaceProjected[1].y, \"\\n          L\").concat(backFaceProjected[2].x, \",\").concat(backFaceProjected[2].y, \"\\n          L\").concat(backFaceProjected[3].x, \",\").concat(backFaceProjected[3].y, \"\\n          Z\\n        \\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.thickness, \"\\\" fill=\\\"none\\\" />\"));\n\n          // Draw connecting edges (between front and back faces)\n          for (var i = 0; i < 4; i++) {\n            elements.push(\"<path d=\\\"\\n            M\".concat(frontFaceProjected[i].x, \",\").concat(frontFaceProjected[i].y, \"\\n            L\").concat(backFaceProjected[i].x, \",\").concat(backFaceProjected[i].y, \"\\n          \\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.thickness, \"\\\" fill=\\\"none\\\" />\"));\n          }\n        } else if (shape.type === 'triangle') {\n          // Project triangle points\n          var projectedPoints = shape.points.map(projectPoint);\n\n          // Draw triangle\n          elements.push(\"<path d=\\\"\\n          M\".concat(projectedPoints[0].x, \",\").concat(projectedPoints[0].y, \"\\n          L\").concat(projectedPoints[1].x, \",\").concat(projectedPoints[1].y, \"\\n          L\").concat(projectedPoints[2].x, \",\").concat(projectedPoints[2].y, \"\\n          Z\\n        \\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.thickness, \"\\\" fill=\\\"none\\\" />\"));\n        }\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PerspectiveGridShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 150,\n    \"default\": 150\n  },\n  rows: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  columns: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  spacing: {\n    min: 0,\n    max: 30,\n    \"default\": 0\n  },\n  depth: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  rotationX: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  rotationY: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PerspectiveGridShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PerspectiveGridShape.js?");

/***/ }),

/***/ "./src/shapes/PieSegments.js":
/*!***********************************!*\
  !*** ./src/shapes/PieSegments.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PieSegmentsShape = /*#__PURE__*/function (_Shape) {\n  function PieSegmentsShape() {\n    _classCallCheck(this, PieSegmentsShape);\n    return _callSuper(this, PieSegmentsShape, arguments);\n  }\n  _inherits(PieSegmentsShape, _Shape);\n  return _createClass(PieSegmentsShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var angleStep = 2 * Math.PI / this.segments;\n      var rotationRad = this.rotation * Math.PI / 180;\n\n      // Add the outer circle\n      elements.push(\"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(this.radius, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n\n      // Add the segments\n      for (var i = 0; i < this.segments; i++) {\n        var angle = i * angleStep + rotationRad;\n        var x = this.radius * Math.cos(angle);\n        var y = this.radius * Math.sin(angle);\n        elements.push(\"<line \\n                x1=\\\"0\\\" \\n                y1=\\\"0\\\" \\n                x2=\\\"\".concat(x, \"\\\" \\n                y2=\\\"\").concat(y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"butt\\\"\\n            />\"));\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PieSegmentsShape, \"parameters\", {\n  segments: {\n    min: 3,\n    max: 32,\n    \"default\": 8\n  },\n  radius: {\n    min: 20,\n    max: 150,\n    \"default\": 100\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PieSegmentsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PieSegments.js?");

/***/ }),

/***/ "./src/shapes/PinwheelShape.js":
/*!*************************************!*\
  !*** ./src/shapes/PinwheelShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PinwheelShape = /*#__PURE__*/function (_Shape) {\n  function PinwheelShape() {\n    _classCallCheck(this, PinwheelShape);\n    return _callSuper(this, PinwheelShape, arguments);\n  }\n  _inherits(PinwheelShape, _Shape);\n  return _createClass(PinwheelShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate center and scale based on viewBox\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var scale = 0.8;\n\n      // Scale parameters\n      var armLength = this.armLength * scale;\n      var centerGap = this.centerGap * scale;\n      var armWidth = this.armWidth * scale;\n      var rotation = 0;\n\n      // Array to store path data for each arm\n      var arms = [];\n\n      // Create four arms of the pinwheel\n      for (var i = 0; i < 4; i++) {\n        var angle = rotation + i * Math.PI / 2;\n\n        // Calculate corner points for each arm\n        var p1 = {\n          x: center.x + centerGap * Math.cos(angle),\n          y: center.y + centerGap * Math.sin(angle)\n        };\n        var p2 = {\n          x: p1.x + armLength * Math.cos(angle),\n          y: p1.y + armLength * Math.sin(angle)\n        };\n        var p3 = {\n          x: p2.x + armWidth * Math.cos(angle + Math.PI / 2),\n          y: p2.y + armWidth * Math.sin(angle + Math.PI / 2)\n        };\n        var p4 = {\n          x: p1.x + armWidth * Math.cos(angle + Math.PI / 2),\n          y: p1.y + armWidth * Math.sin(angle + Math.PI / 2)\n        };\n\n        // Create path data for this arm\n        arms.push(\"M \".concat(p1.x, \" \").concat(p1.y, \" L \").concat(p2.x, \" \").concat(p2.y, \" L \").concat(p3.x, \" \").concat(p3.y, \" L \").concat(p4.x, \" \").concat(p4.y, \" Z\"));\n      }\n      return \"<path d=\\\"\".concat(arms.join(' '), \"\\\" fill=\\\"white\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PinwheelShape, \"parameters\", {\n  armLength: {\n    min: 50,\n    max: 100,\n    \"default\": 120\n  },\n  centerGap: {\n    min: 0,\n    max: 60,\n    \"default\": 0\n  },\n  armWidth: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PinwheelShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PinwheelShape.js?");

/***/ }),

/***/ "./src/shapes/PixelPattern.js":
/*!************************************!*\
  !*** ./src/shapes/PixelPattern.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PixelPattern = /*#__PURE__*/function (_Shape) {\n  function PixelPattern() {\n    _classCallCheck(this, PixelPattern);\n    return _callSuper(this, PixelPattern, arguments);\n  }\n  _inherits(PixelPattern, _Shape);\n  return _createClass(PixelPattern, [{\n    key: \"createSeededRandom\",\n    value: function createSeededRandom(seed) {\n      return function () {\n        seed = (seed * 9301 + 49297) % 233280;\n        return seed / 233280;\n      };\n    }\n  }, {\n    key: \"createGrid\",\n    value: function createGrid() {\n      var grid = [];\n      for (var y = 0; y < this.gridSize; y++) {\n        var row = [];\n        for (var x = 0; x < this.gridSize; x++) {\n          row.push(0);\n        }\n        grid.push(row);\n      }\n      return grid;\n    }\n  }, {\n    key: \"getPositionProbability\",\n    value: function getPositionProbability(x, y) {\n      var center = this.gridSize / 2;\n      var distFromCenter = Math.sqrt(Math.pow(x - center, 2) + Math.pow(y - center, 2));\n      var maxDist = Math.sqrt(2) * center;\n      var normalizedDist = distFromCenter / maxDist;\n      switch (this.patternType) {\n        case 'center-heavy':\n          return this.fillProbability * (1 - normalizedDist);\n        case 'edge-heavy':\n          return this.fillProbability * normalizedDist;\n        case 'uniform':\n          return this.fillProbability;\n        case 'random':\n        default:\n          return this.fillProbability;\n      }\n    }\n  }, {\n    key: \"applySymmetry\",\n    value: function applySymmetry(x, y, value) {\n      var center = Math.floor(this.gridSize / 2);\n      this.grid[y][x] = value;\n      if (this.symmetry === 'radial4') {\n        this.grid[y][this.gridSize - 1 - x] = value;\n        this.grid[this.gridSize - 1 - y][x] = value;\n        this.grid[this.gridSize - 1 - y][this.gridSize - 1 - x] = value;\n        var xFromCenter = x - center;\n        var yFromCenter = y - center;\n        var x90 = center - yFromCenter;\n        var y90 = center + xFromCenter;\n        if (x90 >= 0 && x90 < this.gridSize && y90 >= 0 && y90 < this.gridSize) {\n          this.grid[y90][x90] = value;\n          this.grid[y90][this.gridSize - 1 - x90] = value;\n          this.grid[this.gridSize - 1 - y90][x90] = value;\n          this.grid[this.gridSize - 1 - y90][this.gridSize - 1 - x90] = value;\n        }\n      } else {\n        this.grid[y][this.gridSize - 1 - x] = value;\n        this.grid[this.gridSize - 1 - y][x] = value;\n        this.grid[this.gridSize - 1 - y][this.gridSize - 1 - x] = value;\n        var xc = x - center;\n        var yc = y - center;\n        var positions = [[center + xc, center + yc], [center + yc, center - xc], [center - xc, center - yc], [center - yc, center + xc], [center + yc, center + xc], [center - yc, center - xc], [center + xc, center - yc], [center - xc, center + yc]];\n        for (var _i = 0, _positions = positions; _i < _positions.length; _i++) {\n          var _positions$_i = _slicedToArray(_positions[_i], 2),\n            px = _positions$_i[0],\n            py = _positions$_i[1];\n          if (px >= 0 && px < this.gridSize && py >= 0 && py < this.gridSize) {\n            this.grid[py][px] = value;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"generatePattern\",\n    value: function generatePattern() {\n      var _this = this;\n      var center = Math.floor(this.gridSize / 2);\n      var fillRegion = function fillRegion(x, y) {\n        if (_this.symmetry === 'radial8') {\n          return x >= center && y <= center && x - center >= center - y;\n        } else {\n          return x >= center && y <= center;\n        }\n      };\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          if (fillRegion(x, y)) {\n            var probability = this.getPositionProbability(x, y);\n            if (this.rng() < probability) {\n              this.applySymmetry(x, y, 1);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.gridSize = this.gridSize % 2 === 0 ? this.gridSize + 1 : this.gridSize;\n      this.rng = this.createSeededRandom(this.randomSeed);\n      this.grid = this.createGrid();\n      this.generatePattern();\n      var maxGridSpace = 400 * 0.8;\n      var calculatedPixelSize = maxGridSpace / this.gridSize;\n      var pixelSize = Math.min(this.pixelSize, calculatedPixelSize);\n      var totalGridSize = this.gridSize * pixelSize;\n      var offset = totalGridSize / 2;\n      var pathData = '';\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          if (this.grid[y][x] === 1) {\n            var posX = x * pixelSize - offset;\n            var posY = y * pixelSize - offset;\n            pathData += \"M\".concat(posX, \",\").concat(posY, \" h\").concat(pixelSize, \" v\").concat(pixelSize, \" h-\").concat(pixelSize, \" Z \");\n          }\n        }\n      }\n      return \"<path d=\\\"\".concat(pathData.trim(), \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PixelPattern, \"parameters\", {\n  gridSize: {\n    min: 8,\n    max: 16,\n    \"default\": 12\n  },\n  pixelSize: {\n    min: 5,\n    max: 10,\n    \"default\": 15\n  },\n  fillProbability: {\n    min: 0.3,\n    max: 0.9,\n    \"default\": 0.7\n  },\n  symmetry: {\n    options: ['radial4', 'radial8'],\n    \"default\": 'radial8'\n  },\n  patternType: {\n    options: ['center-heavy', 'edge-heavy', 'uniform', 'random'],\n    \"default\": 'random'\n  },\n  randomSeed: {\n    min: 1,\n    max: 1000,\n    \"default\": 42\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PixelPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PixelPattern.js?");

/***/ }),

/***/ "./src/shapes/Plant.js":
/*!*****************************!*\
  !*** ./src/shapes/Plant.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PlantShape = /*#__PURE__*/function (_Shape) {\n  function PlantShape() {\n    _classCallCheck(this, PlantShape);\n    return _callSuper(this, PlantShape, arguments);\n  }\n  _inherits(PlantShape, _Shape);\n  return _createClass(PlantShape, [{\n    key: \"generateCornerPair\",\n    value: function generateCornerPair(yOffset, isLast) {\n      var verticalExtend = isLast ? 0 : this.spacing;\n\n      // Generate right side segment\n      var rightSegment = \"<path \\n            d=\\\"M 0,\".concat(yOffset + this.cornerRadius, \" \\n               A \").concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 1 \").concat(this.cornerRadius, \",\").concat(yOffset, \" \\n               L \").concat(this.length, \",\").concat(yOffset, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\");\n\n      // Generate left side segment\n      var leftSegment = \"<path \\n            d=\\\"M 0,\".concat(yOffset + this.cornerRadius, \" \\n               A \").concat(this.cornerRadius, \" \").concat(this.cornerRadius, \" 0 0 0 -\").concat(this.cornerRadius, \",\").concat(yOffset, \" \\n               L -\").concat(this.length, \",\").concat(yOffset, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\");\n\n      // Generate vertical segment that connects to the next pair\n      var verticalSegment = isLast ? '' : \"<path \\n            d=\\\"M 0,\".concat(yOffset + this.cornerRadius, \" \\n               L 0,\").concat(yOffset + this.cornerRadius + verticalExtend, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\");\n      return leftSegment + rightSegment + verticalSegment;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var segments = [];\n      var totalHeight = (this.segmentCount - 1) * this.spacing;\n\n      // Generate pairs of segments from bottom to top\n      for (var i = 0; i < this.segmentCount; i++) {\n        var yOffset = -totalHeight + i * this.spacing;\n        var isLast = i === this.segmentCount - 1;\n        segments.push(this.generateCornerPair(yOffset, isLast));\n      }\n      return \"<g transform=\\\"translate(0, \".concat(totalHeight / 2, \")\\\">\").concat(segments.join(''), \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PlantShape, \"parameters\", {\n  cornerRadius: {\n    min: 5,\n    max: 30,\n    \"default\": 30\n  },\n  length: {\n    min: 20,\n    max: 100,\n    \"default\": 90\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 10\n  },\n  segmentCount: {\n    min: 1,\n    max: 6,\n    \"default\": 6\n  },\n  spacing: {\n    min: 5,\n    max: 50,\n    \"default\": 28\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlantShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Plant.js?");

/***/ }),

/***/ "./src/shapes/PlugShape.js":
/*!*********************************!*\
  !*** ./src/shapes/PlugShape.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PlugShape = /*#__PURE__*/function (_Shape) {\n  function PlugShape() {\n    _classCallCheck(this, PlugShape);\n    return _callSuper(this, PlugShape, arguments);\n  }\n  _inherits(PlugShape, _Shape);\n  return _createClass(PlugShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Scale factor to fit within viewBox\n      var scale = 1.5;\n\n      // Calculate dimensions\n      var baseWidth = this.baseWidth * scale;\n      var baseHeight = this.baseHeight * scale;\n      var prongLength = this.prongLength * scale;\n      var prongSpacing = this.prongSpacing * scale;\n      var prongWidth = this.prongWidth * scale;\n      var cornerRadius = this.cornerRadius * scale;\n\n      // Center horizontally, shift up slightly for prongs\n      var baseX = -baseWidth / 2;\n      var baseY = -baseHeight / 2 - prongLength / 3;\n\n      // Prong coordinates\n      var leftProngX = -prongSpacing / 2 - prongWidth;\n      var rightProngX = prongSpacing / 2;\n      var prongY = baseY + baseHeight;\n      return \"\\n            <g fill=\\\"white\\\">\\n                <path \\n                    d=\\\"\\n                        M \".concat(baseX + cornerRadius, \" \").concat(baseY, \"\\n                        h \").concat(baseWidth - 2 * cornerRadius, \"\\n                        q \").concat(cornerRadius, \" 0 \").concat(cornerRadius, \" \").concat(cornerRadius, \"\\n                        v \").concat(baseHeight - 2 * cornerRadius, \"\\n                        q 0 \").concat(cornerRadius, \" -\").concat(cornerRadius, \" \").concat(cornerRadius, \"\\n                        h -\").concat(baseWidth - 2 * cornerRadius, \"\\n                        q -\").concat(cornerRadius, \" 0 -\").concat(cornerRadius, \" -\").concat(cornerRadius, \"\\n                        v -\").concat(baseHeight - 2 * cornerRadius, \"\\n                        q 0 -\").concat(cornerRadius, \" \").concat(cornerRadius, \" -\").concat(cornerRadius, \"\\n                        Z\\n                    \\\"\\n                />\\n                <rect\\n                    x=\\\"\").concat(leftProngX, \"\\\"\\n                    y=\\\"\").concat(prongY, \"\\\"\\n                    width=\\\"\").concat(prongWidth, \"\\\"\\n                    rx=\\\"\").concat(cornerRadius, \"\\\"\\n                    ry=\\\"\").concat(cornerRadius, \"\\\"\\n                    height=\\\"\").concat(prongLength, \"\\\"\\n                />\\n                <rect\\n                    x=\\\"\").concat(rightProngX, \"\\\"\\n                    y=\\\"\").concat(prongY, \"\\\"\\n                    width=\\\"\").concat(prongWidth, \"\\\"\\n                    rx=\\\"\").concat(cornerRadius, \"\\\"\\n                    ry=\\\"\").concat(cornerRadius, \"\\\"\\n                    height=\\\"\").concat(prongLength, \"\\\"\\n                />\\n            </g>\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PlugShape, \"parameters\", {\n  baseWidth: {\n    min: 40,\n    max: 120,\n    \"default\": 80\n  },\n  baseHeight: {\n    min: 30,\n    max: 100,\n    \"default\": 60\n  },\n  prongLength: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  },\n  prongSpacing: {\n    min: 10,\n    max: 50,\n    \"default\": 25\n  },\n  prongWidth: {\n    min: 4,\n    max: 20,\n    \"default\": 8\n  },\n  cornerRadius: {\n    min: 0,\n    max: 20,\n    \"default\": 5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlugShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PlugShape.js?");

/***/ }),

/***/ "./src/shapes/PolarLineBurst.js":
/*!**************************************!*\
  !*** ./src/shapes/PolarLineBurst.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PolarLineBurst = /*#__PURE__*/function (_Shape) {\n  function PolarLineBurst() {\n    _classCallCheck(this, PolarLineBurst);\n    return _callSuper(this, PolarLineBurst, arguments);\n  }\n  _inherits(PolarLineBurst, _Shape);\n  return _createClass(PolarLineBurst, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var baseRotation = this.rotation * Math.PI / 180;\n      var skewRad = this.skew * Math.PI / 180;\n      var quadrantGapRad = this.quadrantGap * Math.PI / 180;\n      var quadrantArcRad = this.quadrantArc * Math.PI / 180;\n\n      // Generate 4 quadrants\n      for (var quadrant = 0; quadrant < 4; quadrant++) {\n        var quadrantRotation = baseRotation + quadrant * (Math.PI / 2 + quadrantGapRad);\n\n        // Generate lines for each quadrant\n        for (var i = 0; i < this.lineCount; i++) {\n          // Calculate base progress (0 to 1)\n          var progress = i / (this.lineCount - 1);\n\n          // Apply spread power for spacing distribution\n          progress = Math.pow(progress, this.spreadPower);\n\n          // Calculate alternating effects if enabled\n          var isAlternate = i % 2 === 1;\n          var lengthMult = 1;\n          var angleOffset = 0;\n          if (this.alternateLines === 'length' && isAlternate) {\n            lengthMult = 0.7;\n          } else if (this.alternateLines === 'spacing' && isAlternate) {\n            angleOffset = quadrantArcRad * 0.1;\n          }\n\n          // Calculate angle within quadrant\n          var angle = quadrantArcRad * progress + angleOffset;\n\n          // Calculate line length with power-based scaling\n          var lengthProgress = Math.pow(progress, this.lengthPower);\n          var lineLength = this.startRadius + (this.size - this.startRadius) * lengthProgress * lengthMult;\n\n          // Apply rotations and skew\n          var totalAngle = quadrantRotation + angle + skewRad * progress;\n          var x = Math.cos(totalAngle) * lineLength;\n          var y = Math.sin(totalAngle) * lineLength;\n          lines.push(\"<line \\n                    x1=\\\"\".concat(Math.cos(totalAngle) * this.startRadius, \"\\\" \\n                    y1=\\\"\").concat(Math.sin(totalAngle) * this.startRadius, \"\\\"\\n                    x2=\\\"\").concat(x, \"\\\"\\n                    y2=\\\"\").concat(y, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                />\"));\n        }\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PolarLineBurst, \"parameters\", {\n  // Core parameters\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  lineCount: {\n    min: 4,\n    max: 50,\n    \"default\": 10\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  },\n  rotation: {\n    min: 0,\n    max: 360,\n    \"default\": 59\n  },\n  // Distribution controls\n  spreadPower: {\n    min: 0.1,\n    max: 4,\n    \"default\": 1\n  },\n  // Controls line spacing distribution\n  lengthPower: {\n    min: 0.1,\n    max: 4,\n    \"default\": 1\n  },\n  // Controls length progression\n\n  // Geometry controls\n  quadrantArc: {\n    min: 1,\n    max: 120,\n    \"default\": 90\n  },\n  // Angle span within each quadrant\n  startRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 25\n  },\n  // Starting radius for lines\n  quadrantGap: {\n    min: 0,\n    max: 90,\n    \"default\": 0\n  },\n  // Gap between quadrants in degrees\n  skew: {\n    min: -45,\n    max: 45,\n    \"default\": 0\n  },\n  // Skew angle for asymmetric shapes\n\n  // Style variations\n  alternateLines: {\n    options: ['none', 'length', 'spacing'],\n    \"default\": 'none'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PolarLineBurst);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PolarLineBurst.js?");

/***/ }),

/***/ "./src/shapes/PolygonalBang.js":
/*!*************************************!*\
  !*** ./src/shapes/PolygonalBang.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PolygonalBang = /*#__PURE__*/function (_Shape) {\n  function PolygonalBang() {\n    _classCallCheck(this, PolygonalBang);\n    return _callSuper(this, PolygonalBang, arguments);\n  }\n  _inherits(PolygonalBang, _Shape);\n  return _createClass(PolygonalBang, [{\n    key: \"generatePoints\",\n    value: function generatePoints() {\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n      this.points = Math.round(this.points);\n      var points = [];\n      var angleStep = 2 * Math.PI / this.points;\n\n      // Generate alternating inner and outer points\n      for (var i = 0; i < this.points; i++) {\n        // Add randomness to angle\n        var angleVariation = angleStep * this.positionChaos * (this.random() - 0.5);\n        var angle = i * angleStep + angleVariation;\n\n        // Create an inner point (valley)\n        var innerRadiusVariation = 1 + this.irregularity * (this.random() - 0.5);\n        var innerPointRadius = this.radius * this.innerRadius * innerRadiusVariation;\n        var innerPoint = {\n          x: innerPointRadius * Math.cos(angle),\n          y: innerPointRadius * Math.sin(angle)\n        };\n\n        // Create an outer point (spike)\n        // Halfway between current angle and next angle\n        var midAngle = angle + angleStep / 2 + angleStep * this.irregularity * (this.random() - 0.5) * 0.5;\n\n        // Spike height varies\n        var spikeHeightVariation = 1 + this.irregularity * (this.random() - 0.5) * 2;\n        var outerPointRadius = this.radius * (1 + this.spikeHeight * spikeHeightVariation);\n        var outerPoint = {\n          x: outerPointRadius * Math.cos(midAngle),\n          y: outerPointRadius * Math.sin(midAngle)\n        };\n\n        // Add points in alternating order\n        points.push(innerPoint);\n        points.push(outerPoint);\n      }\n      return points;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = this.generatePoints();\n      var pathData = '';\n\n      // Create path data\n      points.forEach(function (point, i) {\n        if (i === 0) {\n          pathData += \"M \".concat(point.x, \" \").concat(point.y);\n        } else {\n          pathData += \" L \".concat(point.x, \" \").concat(point.y);\n        }\n      });\n\n      // Close the path\n      pathData += ' Z';\n      return \"<path\\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"none\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PolygonalBang, \"parameters\", {\n  radius: {\n    min: 40,\n    max: 60,\n    \"default\": 60\n  },\n  points: {\n    min: 8,\n    max: 16,\n    \"default\": 12\n  },\n  spikeHeight: {\n    min: 0.2,\n    max: 0.5,\n    \"default\": 0.35\n  },\n  // Shorter spikes relative to base radius\n  innerRadius: {\n    min: 0.6,\n    max: 0.9,\n    \"default\": 0.75\n  },\n  // Large inner circle\n  irregularity: {\n    min: 0.1,\n    max: 0.8,\n    \"default\": 0.4\n  },\n  // Irregularity of the points\n  positionChaos: {\n    min: 0.1,\n    max: 0.4,\n    \"default\": 0.2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PolygonalBang);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PolygonalBang.js?");

/***/ }),

/***/ "./src/shapes/PrismaShape.js":
/*!***********************************!*\
  !*** ./src/shapes/PrismaShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PrismaShape = /*#__PURE__*/function (_Shape) {\n  function PrismaShape() {\n    _classCallCheck(this, PrismaShape);\n    return _callSuper(this, PrismaShape, arguments);\n  }\n  _inherits(PrismaShape, _Shape);\n  return _createClass(PrismaShape, [{\n    key: \"rotatePoint\",\n    value: function rotatePoint(point, center, rotation) {\n      var radians = rotation * Math.PI / 180;\n      var dx = point.x - center.x;\n      var dy = point.y - center.y;\n      var rotatedX = dx * Math.cos(radians) - dy * Math.sin(radians);\n      var rotatedY = dx * Math.sin(radians) + dy * Math.cos(radians);\n      return {\n        x: center.x + rotatedX,\n        y: center.y + rotatedY\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Center point for the shape\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Calculate scaled dimensions\n      var size = this.cubeSize;\n      var pyramidHeight = this.pyramidHeight;\n      var perspective = this.perspective;\n      var frontOffset = size * perspective;\n\n      // Calculate base points for the cube\n      var frontLeft = {\n        x: center.x - size / 2,\n        y: center.y + size / 2\n      };\n      var frontRight = {\n        x: center.x + size / 2,\n        y: center.y + size / 2\n      };\n      var backLeft = {\n        x: frontLeft.x - frontOffset,\n        y: frontLeft.y - frontOffset\n      };\n      var backRight = {\n        x: frontRight.x - frontOffset,\n        y: frontRight.y - frontOffset\n      };\n\n      // Rotate all points\n      var rotatedFrontLeft = this.rotatePoint(frontLeft, center, this.rotation);\n      var rotatedFrontRight = this.rotatePoint(frontRight, center, this.rotation);\n      var rotatedBackLeft = this.rotatePoint(backLeft, center, this.rotation);\n      var rotatedBackRight = this.rotatePoint(backRight, center, this.rotation);\n\n      // Calculate pyramid apex\n      var pyramidApex = this.rotatePoint({\n        x: center.x - frontOffset / 2,\n        y: center.y - pyramidHeight\n      }, center, this.rotation);\n\n      // Generate SVG path commands\n      var paths = [];\n\n      // Cube base (front face)\n      paths.push(\"<path d=\\\"\\n            M \".concat(rotatedFrontLeft.x, \" \").concat(rotatedFrontLeft.y, \"\\n            L \").concat(rotatedFrontRight.x, \" \").concat(rotatedFrontRight.y, \"\\n            L \").concat(rotatedBackRight.x, \" \").concat(rotatedBackRight.y, \"\\n            L \").concat(rotatedBackLeft.x, \" \").concat(rotatedBackLeft.y, \"\\n            Z\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n\n      // Pyramid faces\n      paths.push(\"<path d=\\\"\\n            M \".concat(rotatedFrontLeft.x, \" \").concat(rotatedFrontLeft.y, \"\\n            L \").concat(pyramidApex.x, \" \").concat(pyramidApex.y, \"\\n            L \").concat(rotatedFrontRight.x, \" \").concat(rotatedFrontRight.y, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      paths.push(\"<path d=\\\"\\n            M \".concat(rotatedBackLeft.x, \" \").concat(rotatedBackLeft.y, \"\\n            L \").concat(pyramidApex.x, \" \").concat(pyramidApex.y, \"\\n            L \").concat(rotatedBackRight.x, \" \").concat(rotatedBackRight.y, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PrismaShape, \"parameters\", {\n  cubeSize: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  pyramidHeight: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  perspective: {\n    min: 0.1,\n    max: 0.5,\n    \"default\": 0.3\n  },\n  thickness: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  },\n  rotation: {\n    min: -45,\n    max: 45,\n    \"default\": 15\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PrismaShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PrismaShape.js?");

/***/ }),

/***/ "./src/shapes/PuzzlePieceShape.js":
/*!****************************************!*\
  !*** ./src/shapes/PuzzlePieceShape.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar PuzzlePieceShape = /*#__PURE__*/function (_Shape) {\n  function PuzzlePieceShape() {\n    _classCallCheck(this, PuzzlePieceShape);\n    return _callSuper(this, PuzzlePieceShape, arguments);\n  }\n  _inherits(PuzzlePieceShape, _Shape);\n  return _createClass(PuzzlePieceShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var x = -this.width / 2;\n      var y = -this.height / 2;\n\n      // Calculate notch centers\n      var leftNotchX = x;\n      var leftNotchY = this.notchOffset;\n      var rightNotchX = x + this.width;\n      var rightNotchY = -this.notchOffset;\n\n      // Define the mask that will cut out the notches\n      return \"\\n            <defs>\\n                <mask id=\\\"pieceMask\\\">\\n                    <!-- White rectangle creates the base shape -->\\n                    <rect \\n                        x=\\\"\".concat(x, \"\\\" \\n                        y=\\\"\").concat(y, \"\\\" \\n                        width=\\\"\").concat(this.width, \"\\\" \\n                        height=\\\"\").concat(this.height, \"\\\" \\n                        fill=\\\"white\\\"\\n                    />\\n                    <!-- Black circles create the notch cutouts -->\\n                    <circle \\n                        cx=\\\"\").concat(leftNotchX, \"\\\" \\n                        cy=\\\"\").concat(leftNotchY, \"\\\" \\n                        r=\\\"\").concat(this.notchRadius, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                    <circle \\n                        cx=\\\"\").concat(rightNotchX, \"\\\" \\n                        cy=\\\"\").concat(rightNotchY, \"\\\" \\n                        r=\\\"\").concat(this.notchRadius, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                </mask>\\n            </defs>\\n            \\n            <!-- Main piece with mask applied -->\\n            <rect \\n                x=\\\"\").concat(x, \"\\\" \\n                y=\\\"\").concat(y, \"\\\" \\n                width=\\\"\").concat(this.width, \"\\\" \\n                height=\\\"\").concat(this.height, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.cap, \"\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#pieceMask)\\\"\\n            />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(PuzzlePieceShape, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 160\n  },\n  notchRadius: {\n    min: 10,\n    max: 50,\n    \"default\": 30\n  },\n  notchOffset: {\n    min: 0,\n    max: 50,\n    \"default\": 20\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  cap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PuzzlePieceShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/PuzzlePieceShape.js?");

/***/ }),

/***/ "./src/shapes/QuantumWavesShape.js":
/*!*****************************************!*\
  !*** ./src/shapes/QuantumWavesShape.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\n/* harmony import */ var _perlin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../perlin.js */ \"./src/perlin.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar QuantumWavesShape = /*#__PURE__*/function (_Shape) {\n  function QuantumWavesShape() {\n    _classCallCheck(this, QuantumWavesShape);\n    return _callSuper(this, QuantumWavesShape, arguments);\n  }\n  _inherits(QuantumWavesShape, _Shape);\n  return _createClass(QuantumWavesShape, [{\n    key: \"getNoise\",\n    value: function getNoise(x, y) {\n      return _perlin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].noise(x * this.noiseScale + this.seed, y * this.noiseScale + this.seed);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var streamCount = this.streamCount,\n        streamLength = this.streamLength,\n        dropSpacing = this.dropSpacing,\n        waveAmplitude = this.waveAmplitude,\n        waveFrequency = this.waveFrequency,\n        phaseOffset = this.phaseOffset,\n        noiseScale = this.noiseScale,\n        noiseStrength = this.noiseStrength,\n        dropSize = this.dropSize;\n      var elements = [];\n      var totalWidth = streamCount * dropSpacing;\n      var startX = -totalWidth / 2 + dropSpacing / 2;\n\n      // Calculate how many drops in each stream\n      var dropsPerStream = Math.floor(streamLength / dropSpacing) + 2;\n\n      // Create streams\n      for (var streamIndex = 0; streamIndex < streamCount; streamIndex++) {\n        var baseX = startX + streamIndex * dropSpacing;\n        var streamPhase = phaseOffset * Math.PI / 180 * streamIndex / streamCount;\n\n        // Create drops\n        for (var dropIndex = 0; dropIndex < dropsPerStream; dropIndex++) {\n          // Position along the stream (0-1)\n          var progress = dropIndex / dropsPerStream;\n\n          // Base y position\n          var y = -streamLength / 2 + progress * streamLength;\n\n          // Calculate sine wave offset\n          var sineOffset = waveAmplitude * Math.sin(2 * Math.PI * progress * waveFrequency + streamPhase);\n\n          // Calculate flow region intensity (middle has more flow)\n          var distFromMiddle = Math.abs(progress - 0.5);\n          var flowIntensity = void 0;\n          if (distFromMiddle < 0.2) {\n            // Full flow in middle\n            flowIntensity = 1.0;\n          } else if (distFromMiddle < 0.35) {\n            // Transition zone\n            flowIntensity = 1.0 - (distFromMiddle - 0.2) * 5;\n          } else {\n            // Minimal flow at ends\n            flowIntensity = 0.1;\n          }\n\n          // Add subtle noise to make it more organic\n          var noiseValue = this.getNoise(streamIndex * 0.2, progress * 2);\n\n          // Calculate noise influence (stronger in middle)\n          var noiseOffset = noiseValue * noiseStrength * 0.05 * flowIntensity;\n\n          // Final x position (sine wave + subtle noise)\n          var x = baseX + sineOffset + noiseOffset;\n\n          // Calculate dot size variation\n          var sizeFactor = 1.0;\n\n          // Size variation stronger in high-flow areas\n          if (flowIntensity > 0.5) {\n            var sizeNoise = this.getNoise(streamIndex * 0.3 + 100, progress * 3 + 200);\n\n            // Make dots larger at max wave amplitude\n            var wavePosition = Math.abs(Math.sin(2 * Math.PI * progress * waveFrequency + streamPhase));\n\n            // Combine wave position and noise for size variation\n            var fixedVariation = 0.3; // Built-in variation amount\n            sizeFactor = 1.0 + (wavePosition * 0.7 + sizeNoise * 0.3) * fixedVariation * 2;\n          }\n\n          // Final size with a minimum to prevent negative values\n          var finalSize = Math.max(0.5, dropSize * sizeFactor);\n\n          // Add dot\n          elements.push(\"<circle \\n                    cx=\\\"\".concat(x, \"\\\" \\n                    cy=\\\"\").concat(y, \"\\\" \\n                    r=\\\"\").concat(finalSize / 2, \"\\\" \\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(QuantumWavesShape, \"parameters\", {\n  streamCount: {\n    min: 4,\n    max: 32,\n    \"default\": 12\n  },\n  streamLength: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  dropSpacing: {\n    min: 5,\n    max: 25,\n    \"default\": 11\n  },\n  waveAmplitude: {\n    min: 0,\n    max: 50,\n    \"default\": 30\n  },\n  waveFrequency: {\n    min: 0.1,\n    max: 4,\n    \"default\": 0.5\n  },\n  dropSize: {\n    min: 1,\n    max: 8,\n    \"default\": 5\n  },\n  phaseOffset: {\n    min: -180,\n    max: 180,\n    \"default\": -180\n  },\n  noiseScale: {\n    min: 0.01,\n    max: 0.5,\n    \"default\": 0.31\n  },\n  noiseStrength: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (QuantumWavesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/QuantumWavesShape.js?");

/***/ }),

/***/ "./src/shapes/RadialGridShape.js":
/*!***************************************!*\
  !*** ./src/shapes/RadialGridShape.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RadialGridShape = /*#__PURE__*/function (_Shape) {\n  function RadialGridShape() {\n    _classCallCheck(this, RadialGridShape);\n    return _callSuper(this, RadialGridShape, arguments);\n  }\n  _inherits(RadialGridShape, _Shape);\n  return _createClass(RadialGridShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var circles = [];\n      var gridOffset = (this.gridSize - 1) / 2;\n      var patternCenter = {\n        x: this.patternOffsetX,\n        y: this.patternOffsetY\n      };\n      for (var row = 0; row < this.gridSize; row++) {\n        for (var col = 0; col < this.gridSize; col++) {\n          // Calculate grid position (always centered)\n          var baseX = (col - gridOffset) * this.spacing;\n          var baseY = (row - gridOffset) * this.spacing;\n\n          // Calculate distance from grid center for circle interpolation\n          var distanceFromGridCenter = Math.sqrt(Math.pow(baseX, 2) + Math.pow(baseY, 2));\n          var maxGridDistance = gridOffset * this.spacing;\n\n          // Skip circles outside the rounded grid boundary\n          if (distanceFromGridCenter > maxGridDistance * (1 + this.gridRound)) {\n            continue;\n          }\n\n          // Interpolate position towards circular grid (staying centered)\n          var angle = Math.atan2(baseY, baseX);\n          var interpolationFactor = this.gridRound * Math.min(1, distanceFromGridCenter / maxGridDistance);\n          var x = baseX * (1 - interpolationFactor) + Math.cos(angle) * distanceFromGridCenter * interpolationFactor;\n          var y = baseY * (1 - interpolationFactor) + Math.sin(angle) * distanceFromGridCenter * interpolationFactor;\n\n          // Calculate distance from pattern center for radius scaling\n          var distanceFromPattern = Math.sqrt(Math.pow(x - patternCenter.x, 2) + Math.pow(y - patternCenter.y, 2));\n\n          // Calculate radius based on distance from pattern center\n          var maxDistance = Math.sqrt(2) * (gridOffset * this.spacing);\n          var radiusRatio = Math.max(0, 1 - distanceFromPattern / maxDistance);\n          var radius = this.minRadius + (this.maxRadius - this.minRadius) * Math.pow(radiusRatio, this.radiusFalloff);\n          circles.push(\"<circle \\n                    cx=\\\"\".concat(x, \"\\\" \\n                    cy=\\\"\").concat(y, \"\\\" \\n                    r=\\\"\").concat(radius, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n      }\n      return circles.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RadialGridShape, \"parameters\", {\n  gridSize: {\n    min: 3,\n    max: 6,\n    \"default\": 6\n  },\n  maxRadius: {\n    min: 5,\n    max: 30,\n    \"default\": 15\n  },\n  minRadius: {\n    min: 1,\n    max: 15,\n    \"default\": 2\n  },\n  spacing: {\n    min: 20,\n    max: 60,\n    \"default\": 33\n  },\n  gridRound: {\n    min: 0,\n    max: 1,\n    \"default\": 0.3\n  },\n  patternOffsetX: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  },\n  patternOffsetY: {\n    min: -50,\n    max: 50,\n    \"default\": 0\n  },\n  radiusFalloff: {\n    min: 0.5,\n    max: 2.5,\n    \"default\": 1.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadialGridShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RadialGridShape.js?");

/***/ }),

/***/ "./src/shapes/RadialLines.js":
/*!***********************************!*\
  !*** ./src/shapes/RadialLines.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RadialLinesShape = /*#__PURE__*/function (_Shape) {\n  function RadialLinesShape() {\n    _classCallCheck(this, RadialLinesShape);\n    return _callSuper(this, RadialLinesShape, arguments);\n  }\n  _inherits(RadialLinesShape, _Shape);\n  return _createClass(RadialLinesShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var angleStep = 2 * Math.PI / this.lineCount;\n      var skewRad = this.skew * Math.PI / 180;\n      for (var i = 0; i < this.lineCount; i++) {\n        var baseAngle = i * angleStep;\n\n        // Calculate start point\n        var x1 = this.innerRadius * Math.cos(baseAngle);\n        var y1 = this.innerRadius * Math.sin(baseAngle);\n\n        // Calculate end point with skew\n        var skewedAngle = baseAngle + skewRad;\n        var x2 = this.outerRadius * Math.cos(skewedAngle);\n        var y2 = this.outerRadius * Math.sin(skewedAngle);\n        lines.push(\"<line \\n                x1=\\\"\".concat(x1, \"\\\" \\n                y1=\\\"\").concat(y1, \"\\\" \\n                x2=\\\"\").concat(x2, \"\\\" \\n                y2=\\\"\").concat(y2, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RadialLinesShape, \"parameters\", {\n  innerRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 39\n  },\n  outerRadius: {\n    min: 50,\n    max: 150,\n    \"default\": 77\n  },\n  lineCount: {\n    min: 3,\n    max: 24,\n    \"default\": 12\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'butt'\n  },\n  skew: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadialLinesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RadialLines.js?");

/***/ }),

/***/ "./src/shapes/RadialTriangles.js":
/*!***************************************!*\
  !*** ./src/shapes/RadialTriangles.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RadialTriangles = /*#__PURE__*/function (_Shape) {\n  function RadialTriangles() {\n    _classCallCheck(this, RadialTriangles);\n    return _callSuper(this, RadialTriangles, arguments);\n  }\n  _inherits(RadialTriangles, _Shape);\n  return _createClass(RadialTriangles, [{\n    key: \"generateTriangle\",\n    value: function generateTriangle(angle) {\n      // Convert skew to radians and apply\n      var skewRad = this.skew * Math.PI / 180;\n      var baseAngle = angle + skewRad;\n\n      // Calculate inner point\n      var innerX = this.innerRadius * Math.cos(angle);\n      var innerY = this.innerRadius * Math.sin(angle);\n\n      // Calculate width angle based on sharpness factor\n      var widthAngle = this.width / this.outerRadius * (this.sharpness / 100);\n\n      // Calculate outer points with width spread\n      var leftX = this.outerRadius * Math.cos(baseAngle - widthAngle);\n      var leftY = this.outerRadius * Math.sin(baseAngle - widthAngle);\n      var rightX = this.outerRadius * Math.cos(baseAngle + widthAngle);\n      var rightY = this.outerRadius * Math.sin(baseAngle + widthAngle);\n\n      // Generate path data\n      return \"M \".concat(innerX, \",\").concat(innerY, \" \\n                L \").concat(leftX, \",\").concat(leftY, \" \\n                L \").concat(rightX, \",\").concat(rightY, \" Z\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var triangles = [];\n      var angleStep = 2 * Math.PI / this.count;\n\n      // Generate triangles in radial pattern\n      for (var i = 0; i < this.count; i++) {\n        var angle = i * angleStep;\n        triangles.push(\"<path \\n                d=\\\"\".concat(this.generateTriangle(angle), \"\\\"\\n                fill=\\\"\").concat(this.mode === 'fill' ? 'white' : 'none', \"\\\"\\n                stroke=\\\"\").concat(this.mode === 'stroke' ? 'white' : 'none', \"\\\"\\n                stroke-width=\\\"\").concat(this.mode === 'stroke' ? this.thickness : 0, \"\\\"\\n                stroke-linejoin=\\\"miter\\\"\\n            />\"));\n      }\n      return \"<g>\".concat(triangles.join(''), \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RadialTriangles, \"parameters\", {\n  innerRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 39\n  },\n  outerRadius: {\n    min: 50,\n    max: 150,\n    \"default\": 77\n  },\n  count: {\n    min: 3,\n    max: 16,\n    \"default\": 8\n  },\n  width: {\n    min: 10,\n    max: 60,\n    \"default\": 30\n  },\n  sharpness: {\n    min: 10,\n    max: 90,\n    \"default\": 50\n  },\n  skew: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  },\n  mode: {\n    options: ['fill', 'stroke'],\n    \"default\": 'fill'\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadialTriangles);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RadialTriangles.js?");

/***/ }),

/***/ "./src/shapes/RainbowArcs.js":
/*!***********************************!*\
  !*** ./src/shapes/RainbowArcs.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RainbowArcs = /*#__PURE__*/function (_Shape) {\n  function RainbowArcs() {\n    _classCallCheck(this, RainbowArcs);\n    return _callSuper(this, RainbowArcs, arguments);\n  }\n  _inherits(RainbowArcs, _Shape);\n  return _createClass(RainbowArcs, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n      var radians = function radians(angle) {\n        return angle * Math.PI / 180;\n      };\n\n      // Calculate rotation based on direction - only right angles or 45 angles\n      var rotation = 0;\n      switch (this.direction) {\n        case 'right':\n          rotation = 0;\n          break;\n        case 'down-right':\n          rotation = 45;\n          break;\n        case 'down':\n          rotation = 90;\n          break;\n        case 'down-left':\n          rotation = 135;\n          break;\n        case 'left':\n          rotation = 180;\n          break;\n        case 'up-left':\n          rotation = 225;\n          break;\n        case 'up':\n          rotation = 270;\n          break;\n        case 'up-right':\n          rotation = 315;\n          break;\n      }\n\n      // Keep outer radius fixed\n      var outerRadius = this.radius;\n\n      // Calculate inner radius (smallest arc)\n      var minRadius = Math.max(10, outerRadius * 0.2); // Ensure minimum size for smallest arc\n\n      // Calculate spacing between arcs\n      var availableSpace = outerRadius - minRadius;\n      var calculatedSpacing = this.arcCount > 1 ? availableSpace / (this.arcCount - 1) : 0;\n      var finalSpacing = Math.min(this.spacing, calculatedSpacing);\n\n      // Create container group with rotation\n      elements.push(\"<g transform=\\\"rotate(\".concat(rotation, \")\\\">\"));\n      var startAngleRad = radians(this.startAngle);\n      var endAngleRad = radians(this.endAngle);\n      var sweepFlag = endAngleRad > startAngleRad ? 1 : 0;\n      var largeArcFlag = Math.abs(this.endAngle - this.startAngle) > 180 ? 1 : 0;\n\n      // Draw arcs from outer to inner\n      for (var i = 0; i < this.arcCount; i++) {\n        // Calculate radius for current arc - evenly distribute from outer to inner\n        var currentRadius = void 0;\n        if (this.arcCount > 1) {\n          currentRadius = outerRadius - i * finalSpacing;\n        } else {\n          currentRadius = outerRadius;\n        }\n\n        // Ensure we don't go below minimum radius\n        if (currentRadius < minRadius) break;\n\n        // Use consistent thickness for all arcs\n        var arcThickness = this.thickness;\n\n        // Calculate start and end points\n        var startX = Math.cos(startAngleRad) * currentRadius;\n        var startY = Math.sin(startAngleRad) * currentRadius;\n        var endX = Math.cos(endAngleRad) * currentRadius;\n        var endY = Math.sin(endAngleRad) * currentRadius;\n\n        // Create path for this arc\n        var path = \"<path \\n                d=\\\"M \".concat(startX, \" \").concat(startY, \" A \").concat(currentRadius, \" \").concat(currentRadius, \" 0 \").concat(largeArcFlag, \" \").concat(sweepFlag, \" \").concat(endX, \" \").concat(endY, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(arcThickness, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke-linecap=\\\"\").concat(this.cornerRadius > 0 ? 'round' : 'butt', \"\\\"\\n            />\");\n        elements.push(path);\n      }\n      elements.push('</g>');\n      return elements.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RainbowArcs, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 100,\n    \"default\": 90\n  },\n  arcCount: {\n    min: 2,\n    max: 12,\n    \"default\": 5\n  },\n  spacing: {\n    min: 5,\n    max: 50,\n    \"default\": 15\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 8\n  },\n  startAngle: {\n    min: -180,\n    max: 180,\n    \"default\": -135\n  },\n  endAngle: {\n    min: -180,\n    max: 180,\n    \"default\": 135\n  },\n  cornerRadius: {\n    min: 0,\n    max: 1,\n    \"default\": 0\n  },\n  direction: {\n    options: ['right', 'down-right', 'down', 'down-left', 'left', 'up-left', 'up', 'up-right'],\n    \"default\": 'up'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RainbowArcs);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RainbowArcs.js?");

/***/ }),

/***/ "./src/shapes/RectangleGrid.js":
/*!*************************************!*\
  !*** ./src/shapes/RectangleGrid.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RectangleGrid = /*#__PURE__*/function (_Shape) {\n  function RectangleGrid() {\n    _classCallCheck(this, RectangleGrid);\n    return _callSuper(this, RectangleGrid, arguments);\n  }\n  _inherits(RectangleGrid, _Shape);\n  return _createClass(RectangleGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var cells = [];\n\n      // Calculate cell dimensions accounting for spacing\n      var cellWidth = (this.width - this.spacing * (this.columns - 1)) / this.columns;\n      var cellHeight = (this.height - this.spacing * (this.rows - 1)) / this.rows;\n\n      // Calculate starting position to center the grid\n      var startX = -this.width / 2;\n      var startY = -this.height / 2;\n\n      // Generate grid of rectangles\n      for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n          // Calculate position including spacing\n          var x = startX + j * (cellWidth + this.spacing);\n          var y = startY + i * (cellHeight + this.spacing);\n          cells.push(\"<rect \\n                    x=\\\"\".concat(x, \"\\\"\\n                    y=\\\"\").concat(y, \"\\\"\\n                    width=\\\"\").concat(cellWidth, \"\\\"\\n                    height=\\\"\").concat(cellHeight, \"\\\"\\n                    fill=\\\"\").concat(this.mode === 'fill' ? 'white' : 'none', \"\\\"\\n                    stroke=\\\"\").concat(this.mode === 'stroke' ? 'white' : 'none', \"\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                />\"));\n        }\n      }\n      return cells.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RectangleGrid, \"parameters\", {\n  width: {\n    min: 100,\n    max: 200,\n    \"default\": 150\n  },\n  height: {\n    min: 100,\n    max: 200,\n    \"default\": 150\n  },\n  rows: {\n    min: 1,\n    max: 8,\n    \"default\": 5\n  },\n  columns: {\n    min: 1,\n    max: 8,\n    \"default\": 5\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  },\n  mode: {\n    options: ['stroke', 'fill'],\n    \"default\": 'stroke'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RectangleGrid.js?");

/***/ }),

/***/ "./src/shapes/RecursiveCrescent.js":
/*!*****************************************!*\
  !*** ./src/shapes/RecursiveCrescent.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RecursiveCrescent = /*#__PURE__*/function (_Shape) {\n  function RecursiveCrescent() {\n    _classCallCheck(this, RecursiveCrescent);\n    return _callSuper(this, RecursiveCrescent, arguments);\n  }\n  _inherits(RecursiveCrescent, _Shape);\n  return _createClass(RecursiveCrescent, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate valid ring count based on parameters\n      var maxRings = Math.min(this.rings, Math.floor(this.radius / this.spacing));\n\n      // If no valid rings, return an empty SVG\n      if (maxRings <= 0) {\n        return '<g></g>';\n      }\n      var crescents = [];\n      var baseAngle = this.rotation * Math.PI / 180;\n\n      // Create a unique mask ID for this instance\n      var maskId = \"crescent-mask-\".concat(Math.random().toString(36).substr(2, 9));\n\n      // Start with mask definition\n      crescents.push(\"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <rect x=\\\"-200\\\" y=\\\"-200\\\" width=\\\"400\\\" height=\\\"400\\\" fill=\\\"black\\\"/>\\n        \"));\n\n      // Generate each recursive ring\n      for (var i = 0; i < maxRings; i++) {\n        // Calculate current ring properties with safety checks\n        var scale = Math.pow(0.85, i);\n        var currentRadius = Math.max(5, this.radius - i * this.spacing);\n        var safeThickness = Math.min(currentRadius * 0.8, this.thickness * scale);\n\n        // Calculate offset with smooth progression\n        var offsetAngle = baseAngle + i * Math.PI / 16;\n        var safeOffsetDistance = Math.min(this.offset / 100 * currentRadius, currentRadius * 0.6 // Limit offset to prevent excessive overlap\n        );\n        var offsetX = safeOffsetDistance * Math.cos(offsetAngle);\n        var offsetY = safeOffsetDistance * Math.sin(offsetAngle);\n\n        // The inner radius must be positive and less than the outer radius\n        var innerRadius = Math.max(1, currentRadius - safeThickness);\n\n        // Draw the crescent\n        crescents.push(\"\\n                <circle \\n                    cx=\\\"0\\\" \\n                    cy=\\\"0\\\" \\n                    r=\\\"\".concat(currentRadius, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\\n                <circle \\n                    cx=\\\"\").concat(offsetX, \"\\\" \\n                    cy=\\\"\").concat(offsetY, \"\\\" \\n                    r=\\\"\").concat(innerRadius, \"\\\"\\n                    fill=\\\"black\\\"\\n                />\\n            \"));\n      }\n\n      // Close mask definition\n      crescents.push(\"\\n                </mask>\\n            </defs>\\n        \");\n\n      // Add the final masked shape\n      crescents.push(\"\\n            <rect \\n                x=\\\"-200\\\" \\n                y=\\\"-200\\\" \\n                width=\\\"400\\\" \\n                height=\\\"400\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\".concat(maskId, \")\\\"\\n            />\\n        \"));\n      return crescents.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RecursiveCrescent, \"parameters\", {\n  radius: {\n    min: 20,\n    max: 150,\n    \"default\": 80\n  },\n  rings: {\n    min: 1,\n    max: 8,\n    \"default\": 4\n  },\n  thickness: {\n    min: 1,\n    max: 50,\n    \"default\": 15\n  },\n  spacing: {\n    min: 5,\n    max: 50,\n    \"default\": 20\n  },\n  rotation: {\n    min: -360,\n    max: 360,\n    \"default\": -90\n  },\n  offset: {\n    min: 0,\n    max: 100,\n    \"default\": 30\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RecursiveCrescent);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RecursiveCrescent.js?");

/***/ }),

/***/ "./src/shapes/RecursiveSqrdCircles.js":
/*!********************************************!*\
  !*** ./src/shapes/RecursiveSqrdCircles.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RecursiveSqrdCircles = /*#__PURE__*/function (_Shape) {\n  function RecursiveSqrdCircles() {\n    _classCallCheck(this, RecursiveSqrdCircles);\n    return _callSuper(this, RecursiveSqrdCircles, arguments);\n  }\n  _inherits(RecursiveSqrdCircles, _Shape);\n  return _createClass(RecursiveSqrdCircles, [{\n    key: \"generateMaskId\",\n    value: function generateMaskId(iteration) {\n      return \"square-circle-mask-\".concat(iteration, \"-\").concat(Math.random().toString(36).substr(2, 9));\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var shapes = [];\n      var defs = ['<defs>'];\n\n      // Function to create one iteration\n      var _createIteration = function createIteration(size, rotation, iteration) {\n        if (iteration >= _this.iterations) return '';\n\n        // Generate unique mask ID for this iteration\n        var maskId = _this.generateMaskId(iteration);\n\n        // Create mask definition for this iteration\n        defs.push(\"\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <rect x=\\\"\").concat(-size / 2, \"\\\" y=\\\"\").concat(-size / 2, \"\\\" width=\\\"\").concat(size, \"\\\" height=\\\"\").concat(size, \"\\\" fill=\\\"white\\\"/>\\n                    <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(size / 2, \"\\\" fill=\\\"black\\\"/>\\n                </mask>\\n            \"));\n\n        // Calculate next iteration size\n        var nextSize = size * _this.scale;\n\n        // Create current square with mask\n        var square = \"\\n                <rect \\n                    x=\\\"\".concat(-size / 2, \"\\\" \\n                    y=\\\"\").concat(-size / 2, \"\\\" \\n                    width=\\\"\").concat(size, \"\\\" \\n                    height=\\\"\").concat(size, \"\\\"\\n                    transform=\\\"rotate(\").concat(rotation, \")\\\"\\n                    fill=\\\"white\\\"\\n                    mask=\\\"url(#\").concat(maskId, \")\\\"\\n                />\\n            \");\n\n        // Recursively create next iteration\n        return square + _createIteration(nextSize, rotation + _this.rotation, iteration + 1);\n      };\n\n      // Close defs\n      defs.push('</defs>');\n\n      // Generate the complete pattern\n      var pattern = _createIteration(this.size, 0, 0);\n      return defs.join('') + pattern;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RecursiveSqrdCircles, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 150\n  },\n  iterations: {\n    min: 1,\n    max: 6,\n    \"default\": 4\n  },\n  scale: {\n    min: 0.2,\n    max: 0.8,\n    \"default\": 0.6\n  },\n  rotation: {\n    min: -90,\n    max: 90,\n    \"default\": 90\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RecursiveSqrdCircles);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RecursiveSqrdCircles.js?");

/***/ }),

/***/ "./src/shapes/RhombusPattern.js":
/*!**************************************!*\
  !*** ./src/shapes/RhombusPattern.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RhombusPattern = /*#__PURE__*/function (_Shape) {\n  function RhombusPattern() {\n    _classCallCheck(this, RhombusPattern);\n    return _callSuper(this, RhombusPattern, arguments);\n  }\n  _inherits(RhombusPattern, _Shape);\n  return _createClass(RhombusPattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var shapes = [];\n      var gridCount = Math.floor(this.gridSize);\n      var totalSize = (this.diamondSize + this.spacing) * gridCount;\n      var startX = -totalSize / 2 + (this.diamondSize + this.spacing) / 2;\n      var startY = -totalSize / 2 + (this.diamondSize + this.spacing) / 2;\n      for (var row = 0; row < gridCount; row++) {\n        for (var col = 0; col < gridCount; col++) {\n          var x = startX + col * (this.diamondSize + this.spacing);\n          var y = startY + row * (this.diamondSize + this.spacing);\n\n          // Outer diamond points\n          var outerPoints = [[x, y - this.diamondSize / 2], [x + this.diamondSize / 2, y], [x, y + this.diamondSize / 2], [x - this.diamondSize / 2, y]];\n\n          // Draw outer diamond\n          shapes.push(\"<path \\n                    d=\\\"M \".concat(outerPoints[0][0], \" \").concat(outerPoints[0][1], \" \\n                       L \").concat(outerPoints[1][0], \" \").concat(outerPoints[1][1], \" \\n                       L \").concat(outerPoints[2][0], \" \").concat(outerPoints[2][1], \" \\n                       L \").concat(outerPoints[3][0], \" \").concat(outerPoints[3][1], \" Z\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                    fill=\\\"none\\\"\\n                />\"));\n\n          // Only draw inner diamond and connecting lines if innerRatio > 0.1\n          if (this.innerRatio > 0.1) {\n            var innerSize = this.diamondSize * this.innerRatio;\n            var innerPoints = [[x, y - innerSize / 2], [x + innerSize / 2, y], [x, y + innerSize / 2], [x - innerSize / 2, y]];\n\n            // Draw inner diamond\n            shapes.push(\"<path \\n                        d=\\\"M \".concat(innerPoints[0][0], \" \").concat(innerPoints[0][1], \" \\n                           L \").concat(innerPoints[1][0], \" \").concat(innerPoints[1][1], \" \\n                           L \").concat(innerPoints[2][0], \" \").concat(innerPoints[2][1], \" \\n                           L \").concat(innerPoints[3][0], \" \").concat(innerPoints[3][1], \" Z\\\"\\n                        stroke=\\\"white\\\"\\n                        stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                        stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                        fill=\\\"none\\\"\\n                    />\"));\n\n            // Draw connecting lines\n            for (var i = 0; i < 4; i++) {\n              shapes.push(\"<line \\n                            x1=\\\"\".concat(outerPoints[i][0], \"\\\" \\n                            y1=\\\"\").concat(outerPoints[i][1], \"\\\" \\n                            x2=\\\"\").concat(innerPoints[i][0], \"\\\" \\n                            y2=\\\"\").concat(innerPoints[i][1], \"\\\"\\n                            stroke=\\\"white\\\"\\n                            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                            stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                        />\"));\n            }\n          }\n        }\n      }\n      return shapes.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RhombusPattern, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 4,\n    \"default\": 2\n  },\n  diamondSize: {\n    min: 20,\n    max: 80,\n    \"default\": 60\n  },\n  thickness: {\n    min: 1,\n    max: 8,\n    \"default\": 2\n  },\n  spacing: {\n    min: 1,\n    max: 50,\n    \"default\": 1\n  },\n  innerRatio: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.6\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RhombusPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RhombusPattern.js?");

/***/ }),

/***/ "./src/shapes/RhythmicWaves.js":
/*!*************************************!*\
  !*** ./src/shapes/RhythmicWaves.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RhythmicWaves = /*#__PURE__*/function (_Shape) {\n  function RhythmicWaves() {\n    _classCallCheck(this, RhythmicWaves);\n    return _callSuper(this, RhythmicWaves, arguments);\n  }\n  _inherits(RhythmicWaves, _Shape);\n  return _createClass(RhythmicWaves, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n      var baseWidth = 400 * this.rootSpread; // Increased from 240 to fill viewBox\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var groundLevel = center.y + this.archHeight / 2;\n      var archTop = center.y - this.archHeight / 2;\n      for (var i = 0; i < this.rootCount; i++) {\n        var progress = i / (this.rootCount - 1);\n        var phase = this.rootPhase * Math.PI / 180 * Math.sin(progress * Math.PI);\n        var startX = center.x - baseWidth / 2 + baseWidth * progress;\n        var startPoint = {\n          x: startX,\n          y: groundLevel\n        };\n        var endPoint = {\n          x: startX,\n          y: archTop\n        };\n        var control1 = {\n          x: startX + 100 * this.rootCurve * Math.cos(phase),\n          // Increased from 50\n          y: groundLevel - this.archHeight * 0.4 // Adjusted from 1/3\n        };\n        var control2 = {\n          x: startX - 60 * this.rootCurve * Math.cos(phase),\n          // Increased from 30\n          y: archTop + this.archHeight * 0.4 // Adjusted from 1/3\n        };\n        lines.push(\"<path \\n                d=\\\"M \".concat(startPoint.x, \" \").concat(startPoint.y, \" \\n                   C \").concat(control1.x, \" \").concat(control1.y, \" \\n                     \").concat(control2.x, \" \").concat(control2.y, \" \\n                     \").concat(endPoint.x, \" \").concat(endPoint.y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.rootThickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                fill=\\\"none\\\"\\n            />\"));\n      }\n      return lines.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RhythmicWaves, \"parameters\", {\n  archHeight: {\n    min: 50,\n    max: 200,\n    \"default\": 180\n  },\n  rootCount: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  rootThickness: {\n    min: 2,\n    max: 15,\n    \"default\": 8\n  },\n  rootCurve: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.6\n  },\n  rootSpread: {\n    min: 0.2,\n    max: 0.8,\n    \"default\": 0.3\n  },\n  rootPhase: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RhythmicWaves);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RhythmicWaves.js?");

/***/ }),

/***/ "./src/shapes/RibbonShape.js":
/*!***********************************!*\
  !*** ./src/shapes/RibbonShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RibbonShape = /*#__PURE__*/function (_Shape) {\n  function RibbonShape() {\n    _classCallCheck(this, RibbonShape);\n    return _callSuper(this, RibbonShape, arguments);\n  }\n  _inherits(RibbonShape, _Shape);\n  return _createClass(RibbonShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = [];\n      var steps = 100;\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps * Math.PI * 2;\n        var x = Math.sin(t * this.cycles) * this.width;\n        var y = Math.cos(t) * this.width * this.squeeze;\n        points.push(\"\".concat(x, \",\").concat(y));\n      }\n      return \"<path \\n            d=\\\"M \".concat(points.join(' L '), \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RibbonShape, \"parameters\", {\n  cycles: {\n    min: 2,\n    max: 4,\n    \"default\": 2\n  },\n  width: {\n    min: 20,\n    max: 100,\n    \"default\": 80\n  },\n  thickness: {\n    min: 2,\n    max: 20,\n    \"default\": 12\n  },\n  squeeze: {\n    min: 0.2,\n    max: 1,\n    \"default\": 0.6\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RibbonShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RibbonShape.js?");

/***/ }),

/***/ "./src/shapes/RoundedInnerStarShape.js":
/*!*********************************************!*\
  !*** ./src/shapes/RoundedInnerStarShape.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RoundedInnerStarShape = /*#__PURE__*/function (_Shape) {\n  function RoundedInnerStarShape() {\n    _classCallCheck(this, RoundedInnerStarShape);\n    return _callSuper(this, RoundedInnerStarShape, arguments);\n  }\n  _inherits(RoundedInnerStarShape, _Shape);\n  return _createClass(RoundedInnerStarShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var pathParts = [];\n      // Ensure points is an integer using Math.round\n      var pointsInt = Math.round(this.points);\n      var rotationInRadians = this.rotation * Math.PI / 180;\n      var angleStep = 2 * Math.PI / pointsInt;\n\n      // Calculate control point distance based on curve strength\n      // Add adaptive scaling based on point count to prevent self-intersection\n      var pointScale = Math.min(1, 5 / pointsInt);\n      var controlDist = this.curveStrength / 100 * (this.size - this.innerRadius) * 0.5 * pointScale;\n      for (var i = 0; i < pointsInt; i++) {\n        var angle = i * angleStep + rotationInRadians;\n        var nextAngle = (i + 1) % pointsInt * angleStep + rotationInRadians;\n\n        // Outer point\n        var outerX = Math.cos(angle) * this.size;\n        var outerY = Math.sin(angle) * this.size;\n\n        // Inner point\n        var midAngle = angle + angleStep / 2;\n        var innerX = Math.cos(midAngle) * this.innerRadius;\n        var innerY = Math.sin(midAngle) * this.innerRadius;\n\n        // Next outer point\n        var nextOuterX = Math.cos(nextAngle) * this.size;\n        var nextOuterY = Math.sin(nextAngle) * this.size;\n\n        // Control points for the curves - use perpendicular angles for smooth transitions\n        var controlAngle1 = angle + Math.PI / 2;\n        var controlAngle2 = nextAngle - Math.PI / 2;\n\n        // Control point calculation - similar to original but with better stability\n        // First control point (after outer point)\n        var control1X = outerX + Math.cos(controlAngle1) * controlDist;\n        var control1Y = outerY + Math.sin(controlAngle1) * controlDist;\n\n        // Second control point (before inner point)\n        var control2X = innerX - Math.cos(controlAngle1) * controlDist;\n        var control2Y = innerY - Math.sin(controlAngle1) * controlDist;\n\n        // Third control point (after inner point)\n        var control3X = innerX - Math.cos(controlAngle2) * controlDist;\n        var control3Y = innerY - Math.sin(controlAngle2) * controlDist;\n\n        // Fourth control point (before next outer point)\n        var control4X = nextOuterX + Math.cos(controlAngle2) * controlDist;\n        var control4Y = nextOuterY + Math.sin(controlAngle2) * controlDist;\n        if (i === 0) {\n          pathParts.push(\"M \".concat(outerX, \",\").concat(outerY));\n        }\n\n        // Add the two cubic bezier curves for this segment\n        pathParts.push(\"C \".concat(control1X, \",\").concat(control1Y, \" \").concat(control2X, \",\").concat(control2Y, \" \").concat(innerX, \",\").concat(innerY));\n        pathParts.push(\"C \".concat(control3X, \",\").concat(control3Y, \" \").concat(control4X, \",\").concat(control4Y, \" \").concat(nextOuterX, \",\").concat(nextOuterY));\n      }\n      pathParts.push('Z');\n      return \"<path \\n            d=\\\"\".concat(pathParts.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"1\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedInnerStarShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  points: {\n    min: 3,\n    max: 12,\n    \"default\": 4\n  },\n  innerRadius: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  curveStrength: {\n    min: 0,\n    max: 100,\n    \"default\": 70\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 45\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedInnerStarShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedInnerStarShape.js?");

/***/ }),

/***/ "./src/shapes/RoundedPolygon.js":
/*!**************************************!*\
  !*** ./src/shapes/RoundedPolygon.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RoundedPolygon = /*#__PURE__*/function (_Shape) {\n  function RoundedPolygon() {\n    _classCallCheck(this, RoundedPolygon);\n    return _callSuper(this, RoundedPolygon, arguments);\n  }\n  _inherits(RoundedPolygon, _Shape);\n  return _createClass(RoundedPolygon, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.sides = Math.round(this.sides);\n      this.size = 100;\n      // Generate base polygon points\n      var points = [];\n      var angleStep = 2 * Math.PI / this.sides;\n      for (var i = 0; i < this.sides; i++) {\n        var angle = i * angleStep - Math.PI / 2; // Start from top\n        var x = this.size * Math.cos(angle);\n        var y = this.size * Math.sin(angle);\n        points.push([x, y]);\n      }\n\n      // Calculate maximum possible corner radius based on polygon geometry\n      var sideLength = Math.sqrt(Math.pow(points[1][0] - points[0][0], 2) + Math.pow(points[1][1] - points[0][1], 2));\n      var maxRadius = sideLength * Math.sin(Math.PI / this.sides) * 0.5;\n      var cornerRadius = this.cornerRadius / 100 * maxRadius;\n\n      // Generate path with rounded corners using quadratic bezier curves\n      var path = '';\n      for (var _i = 0; _i < points.length; _i++) {\n        var curr = points[_i];\n        var next = points[(_i + 1) % points.length];\n        var nextNext = points[(_i + 2) % points.length];\n\n        // Calculate vectors\n        var v1 = {\n          x: next[0] - curr[0],\n          y: next[1] - curr[1]\n        };\n        var v2 = {\n          x: nextNext[0] - next[0],\n          y: nextNext[1] - next[1]\n        };\n\n        // Normalize vectors\n        var len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);\n        var len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);\n        var n1 = {\n          x: v1.x / len1,\n          y: v1.y / len1\n        };\n        var n2 = {\n          x: v2.x / len2,\n          y: v2.y / len2\n        };\n\n        // Calculate control points\n        var cp1 = {\n          x: next[0] - n1.x * cornerRadius,\n          y: next[1] - n1.y * cornerRadius\n        };\n        var cp2 = {\n          x: next[0] + n2.x * cornerRadius,\n          y: next[1] + n2.y * cornerRadius\n        };\n\n        // Start path\n        if (_i === 0) {\n          path += \"M \".concat(curr[0], \",\").concat(curr[1]);\n        }\n\n        // Add line to first control point\n        path += \" L \".concat(cp1.x, \",\").concat(cp1.y);\n\n        // Add quadratic bezier curve for the corner\n        path += \" Q \".concat(next[0], \",\").concat(next[1], \" \").concat(cp2.x, \",\").concat(cp2.y);\n      }\n      path += 'Z';\n      return \"<path d=\\\"\".concat(path, \"\\\" fill=\\\"white\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedPolygon, \"parameters\", {\n  sides: {\n    min: 3,\n    max: 12,\n    \"default\": 5\n  },\n  cornerRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 20\n  } // as percentage of max possible radius\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedPolygon);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedPolygon.js?");

/***/ }),

/***/ "./src/shapes/RoundedRect.js":
/*!***********************************!*\
  !*** ./src/shapes/RoundedRect.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RoundedRectShape = /*#__PURE__*/function (_Shape) {\n  function RoundedRectShape() {\n    _classCallCheck(this, RoundedRectShape);\n    return _callSuper(this, RoundedRectShape, arguments);\n  }\n  _inherits(RoundedRectShape, _Shape);\n  return _createClass(RoundedRectShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var outerSize = 150;\n      var halfOuter = outerSize / 2;\n\n      // Calculate inner dimensions\n      var innerSize = outerSize * this.innerRatio;\n      var halfInner = innerSize / 2;\n\n      // Calculate corner radii using fixed ratio of 2\n      var outerRadius = Math.min(this.cornerRadius, outerSize / 4);\n      var innerRadius = outerRadius / 2; // Fixed ratio of 2\n\n      // Create outer rounded rectangle path\n      var outerPath = this.createRoundedRectPath(-halfOuter, -halfOuter, outerSize, outerSize, outerRadius);\n\n      // Create centered inner rounded rectangle path\n      var innerPath = this.createRoundedRectPath(-halfInner, -halfInner, innerSize, innerSize, innerRadius);\n      return \"<path d=\\\"\".concat(outerPath, \" \").concat(innerPath, \"\\\"\\n                  fill=\\\"white\\\"\\n                  fill-rule=\\\"evenodd\\\"/>\");\n    }\n  }, {\n    key: \"createRoundedRectPath\",\n    value: function createRoundedRectPath(x, y, width, height, radius) {\n      // Ensure radius doesn't exceed half of width or height\n      var r = Math.min(radius, width / 2, height / 2);\n      var commands = [\"M \".concat(x + r, \" \").concat(y), \"h \".concat(width - 2 * r), \"a \".concat(r, \" \").concat(r, \" 0 0 1 \").concat(r, \" \").concat(r), \"v \".concat(height - 2 * r), \"a \".concat(r, \" \").concat(r, \" 0 0 1 -\").concat(r, \" \").concat(r), \"h -\".concat(width - 2 * r), \"a \".concat(r, \" \").concat(r, \" 0 0 1 -\").concat(r, \" -\").concat(r), \"v -\".concat(height - 2 * r), \"a \".concat(r, \" \").concat(r, \" 0 0 1 \").concat(r, \" -\").concat(r), 'Z'];\n      return commands.join(' ');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedRectShape, \"parameters\", {\n  innerRatio: {\n    min: 0.7,\n    max: 0.9,\n    \"default\": 0.65\n  },\n  cornerRadius: {\n    min: 5,\n    max: 100,\n    \"default\": 35\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedRectShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedRect.js?");

/***/ }),

/***/ "./src/shapes/RoundedRectangles.js":
/*!*****************************************!*\
  !*** ./src/shapes/RoundedRectangles.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RoundedRectangleGrid = /*#__PURE__*/function (_Shape) {\n  function RoundedRectangleGrid() {\n    _classCallCheck(this, RoundedRectangleGrid);\n    return _callSuper(this, RoundedRectangleGrid, arguments);\n  }\n  _inherits(RoundedRectangleGrid, _Shape);\n  return _createClass(RoundedRectangleGrid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var cells = [];\n\n      // Calculate cell dimensions accounting for spacing\n      var cellWidth = (this.width - this.spacing * (this.columns - 1)) / this.columns;\n      var cellHeight = (this.height - this.spacing * (this.rows - 1)) / this.rows;\n\n      // Calculate starting position to center the grid\n      var startX = -this.width / 2;\n      var startY = -this.height / 2;\n\n      // Generate grid of rounded rectangles\n      for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n          // Calculate position including spacing\n          var x = startX + j * (cellWidth + this.spacing);\n          var y = startY + i * (cellHeight + this.spacing);\n\n          // Calculate corner radius as percentage of minimum cell dimension\n          var maxRadius = Math.min(cellWidth, cellHeight) / 2;\n          var appliedRadius = this.cornerRadius / 100 * maxRadius;\n          cells.push(\"<rect \\n                    x=\\\"\".concat(x, \"\\\"\\n                    y=\\\"\").concat(y, \"\\\"\\n                    width=\\\"\").concat(cellWidth, \"\\\"\\n                    height=\\\"\").concat(cellHeight, \"\\\"\\n                    rx=\\\"\").concat(appliedRadius, \"\\\"\\n                    ry=\\\"\").concat(appliedRadius, \"\\\"\\n                    fill=\\\"\").concat(this.mode === 'fill' ? 'white' : 'none', \"\\\"\\n                    stroke=\\\"\").concat(this.mode === 'stroke' ? 'white' : 'none', \"\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                />\"));\n        }\n      }\n      return cells.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedRectangleGrid, \"parameters\", {\n  width: {\n    min: 100,\n    max: 250,\n    \"default\": 200\n  },\n  height: {\n    min: 100,\n    max: 250,\n    \"default\": 200\n  },\n  rows: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  columns: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 10\n  },\n  cornerRadius: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  },\n  mode: {\n    options: ['stroke', 'fill'],\n    \"default\": 'fill'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedRectangleGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedRectangles.js?");

/***/ }),

/***/ "./src/shapes/RoundedStar.js":
/*!***********************************!*\
  !*** ./src/shapes/RoundedStar.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RoundedStarShape = /*#__PURE__*/function (_Shape) {\n  function RoundedStarShape() {\n    _classCallCheck(this, RoundedStarShape);\n    return _callSuper(this, RoundedStarShape, arguments);\n  }\n  _inherits(RoundedStarShape, _Shape);\n  return _createClass(RoundedStarShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Ensure points is an integer\n      var rotationRad = this.rotation * Math.PI / 180;\n      var pointsInt = Math.round(this.points);\n      var angleStep = 2 * Math.PI / pointsInt;\n      var halfStep = angleStep / 2;\n      var pathParts = [];\n\n      // Calculate control point distance for smooth corners\n      // Add adaptive scaling based on point count\n      var adaptiveFactor = Math.min(1, 6 / pointsInt);\n      var outerControlDist = this.cornerRadius * Math.tan(Math.PI / 8) * adaptiveFactor;\n      var innerControlDist = this.cornerRadius * Math.tan(Math.PI / 8) * adaptiveFactor;\n      for (var i = 0; i < pointsInt; i++) {\n        // Offset the angle by -90 degrees (-/2) to start from top\n        var angle = i * angleStep - Math.PI / 2 + rotationRad;\n        var nextAngle = angle + halfStep;\n\n        // Outer point\n        var outerX = this.outerRadius * Math.cos(angle);\n        var outerY = this.outerRadius * Math.sin(angle);\n\n        // Inner point\n        var innerX = this.innerRadius * Math.cos(nextAngle);\n        var innerY = this.innerRadius * Math.sin(nextAngle);\n\n        // Calculate control points for outer to inner curve\n        var outerControlX1 = outerX - outerControlDist * Math.sin(angle);\n        var outerControlY1 = outerY + outerControlDist * Math.cos(angle);\n        var innerControlX1 = innerX + innerControlDist * Math.sin(nextAngle);\n        var innerControlY1 = innerY - innerControlDist * Math.cos(nextAngle);\n        if (i === 0) {\n          pathParts.push(\"M \".concat(outerX, \",\").concat(outerY));\n        }\n\n        // Add cubic Bezier curve to inner point\n        pathParts.push(\"C \".concat(outerControlX1, \",\").concat(outerControlY1, \" \").concat(innerControlX1, \",\").concat(innerControlY1, \" \").concat(innerX, \",\").concat(innerY));\n\n        // Calculate next outer point\n        var nextOuterAngle = angle + angleStep;\n        var nextOuterX = this.outerRadius * Math.cos(nextOuterAngle);\n        var nextOuterY = this.outerRadius * Math.sin(nextOuterAngle);\n\n        // Calculate control points for inner to outer curve\n        var innerControlX2 = innerX - innerControlDist * Math.sin(nextAngle);\n        var innerControlY2 = innerY + innerControlDist * Math.cos(nextAngle);\n        var outerControlX2 = nextOuterX + outerControlDist * Math.sin(nextOuterAngle);\n        var outerControlY2 = nextOuterY - outerControlDist * Math.cos(nextOuterAngle);\n\n        // Add cubic Bezier curve to next outer point\n        pathParts.push(\"C \".concat(innerControlX2, \",\").concat(innerControlY2, \" \").concat(outerControlX2, \",\").concat(outerControlY2, \" \").concat(nextOuterX, \",\").concat(nextOuterY));\n      }\n      pathParts.push('Z');\n      return \"<path \\n            d=\\\"\".concat(pathParts.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedStarShape, \"parameters\", {\n  outerRadius: {\n    min: 20,\n    max: 100,\n    \"default\": 100\n  },\n  innerRadius: {\n    min: 15,\n    max: 100,\n    \"default\": 50\n  },\n  points: {\n    min: 3,\n    max: 16,\n    \"default\": 6\n  },\n  cornerRadius: {\n    min: 25,\n    max: 65,\n    \"default\": 50\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedStarShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedStar.js?");

/***/ }),

/***/ "./src/shapes/RoundedTriangle.js":
/*!***************************************!*\
  !*** ./src/shapes/RoundedTriangle.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RoundedTriangleShape = /*#__PURE__*/function (_Shape) {\n  function RoundedTriangleShape() {\n    _classCallCheck(this, RoundedTriangleShape);\n    return _callSuper(this, RoundedTriangleShape, arguments);\n  }\n  _inherits(RoundedTriangleShape, _Shape);\n  return _createClass(RoundedTriangleShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var size = 180;\n      var sideLength = size;\n      var height = sideLength * Math.sqrt(3) / 2;\n      var outerPoints = [[0, -height * 2 / 3],\n      // top\n      [sideLength / 2, height / 3],\n      // bottom right\n      [-sideLength / 2, height / 3] // bottom left\n      ];\n      var innerScale = this.innerRatio;\n      var innerPoints = outerPoints.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        return [x * innerScale, y * innerScale];\n      });\n      var outerPath = this.createRoundedPath(outerPoints, this.cornerRadius);\n      var innerPath = this.createRoundedPath(innerPoints, this.cornerRadius * innerScale);\n      return \"<path \\n            d=\\\"\".concat(outerPath, \" \").concat(innerPath, \"\\\"\\n            fill=\\\"white\\\"\\n            fill-rule=\\\"evenodd\\\"\\n        />\");\n    }\n  }, {\n    key: \"createRoundedPath\",\n    value: function createRoundedPath(points, radius) {\n      var commands = [];\n      var len = points.length;\n      for (var i = 0; i < len; i++) {\n        var current = points[i];\n        var next = points[(i + 1) % len];\n        var prev = points[(i - 1 + len) % len];\n        var cornerRadius = Math.min(radius, this.getDistance(current, next) / 2, this.getDistance(current, prev) / 2);\n        var prevPoint = this.adjustPoint(current, prev, cornerRadius);\n        var nextPoint = this.adjustPoint(current, next, cornerRadius);\n        if (i === 0) {\n          commands.push(\"M \".concat(prevPoint[0], \" \").concat(prevPoint[1]));\n        }\n        commands.push(\"L \".concat(prevPoint[0], \" \").concat(prevPoint[1]));\n        commands.push(\"Q \".concat(current[0], \" \").concat(current[1], \" \").concat(nextPoint[0], \" \").concat(nextPoint[1]));\n      }\n      commands.push('Z');\n      return commands.join(' ');\n    }\n  }, {\n    key: \"adjustPoint\",\n    value: function adjustPoint(origin, target, radius) {\n      var vector = [target[0] - origin[0], target[1] - origin[1]];\n      var length = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n      var scale = radius / length;\n      return [origin[0] + vector[0] * scale, origin[1] + vector[1] * scale];\n    }\n  }, {\n    key: \"getDistance\",\n    value: function getDistance(p1, p2) {\n      return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedTriangleShape, \"parameters\", {\n  innerRatio: {\n    min: 0.3,\n    max: 0.9,\n    \"default\": 0.65\n  },\n  cornerRadius: {\n    min: 5,\n    max: 100,\n    \"default\": 30\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedTriangleShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedTriangle.js?");

/***/ }),

/***/ "./src/shapes/RoundedTrianglesGrid.js":
/*!********************************************!*\
  !*** ./src/shapes/RoundedTrianglesGrid.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RoundedTriangleGrid = /*#__PURE__*/function (_Shape) {\n  function RoundedTriangleGrid() {\n    _classCallCheck(this, RoundedTriangleGrid);\n    return _callSuper(this, RoundedTriangleGrid, arguments);\n  }\n  _inherits(RoundedTriangleGrid, _Shape);\n  return _createClass(RoundedTriangleGrid, [{\n    key: \"calculateIntersection\",\n    value: function calculateIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n      var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n      if (denominator === 0) return null;\n      var intersectionX = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denominator;\n      var intersectionY = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denominator;\n      return [intersectionX, intersectionY];\n    }\n  }, {\n    key: \"calculateRoundedCorner\",\n    value: function calculateRoundedCorner(from, via, to, radius) {\n      var fromAngle = Math.atan2(via[1] - from[1], via[0] - from[0]);\n      var toAngle = Math.atan2(to[1] - via[1], to[0] - via[0]);\n\n      // Calculate offset vectors\n      var fromOffset = {\n        dx: -Math.sin(fromAngle) * radius,\n        dy: Math.cos(fromAngle) * radius\n      };\n      var toOffset = {\n        dx: -Math.sin(toAngle) * radius,\n        dy: Math.cos(toAngle) * radius\n      };\n\n      // Calculate line intersection points\n      var x1 = from[0] + fromOffset.dx;\n      var y1 = from[1] + fromOffset.dy;\n      var x2 = via[0] + fromOffset.dx;\n      var y2 = via[1] + fromOffset.dy;\n      var x3 = via[0] + toOffset.dx;\n      var y3 = via[1] + toOffset.dy;\n      var x4 = to[0] + toOffset.dx;\n      var y4 = to[1] + toOffset.dy;\n      var intersection = this.calculateIntersection(x1, y1, x2, y2, x3, y3, x4, y4);\n      if (!intersection) return null;\n      return {\n        center: intersection,\n        startAngle: fromAngle - Math.PI / 2,\n        endAngle: toAngle - Math.PI / 2\n      };\n    }\n  }, {\n    key: \"generateRoundedTrianglePath\",\n    value: function generateRoundedTrianglePath(x, y, width, height, radius) {\n      // Define triangle points\n      var points = [[x + width / 2, y],\n      // top\n      [x + width, y + height],\n      // bottom right\n      [x, y + height] // bottom left\n      ];\n\n      // Calculate maximum possible radius based on triangle size\n      var maxRadius = Math.min(width, height) / 6;\n      var appliedRadius = radius / 100 * maxRadius;\n\n      // For zero radius, return simple triangle\n      if (appliedRadius === 0) {\n        return \"M \".concat(points[0][0], \",\").concat(points[0][1], \" \\n                    L \").concat(points[1][0], \",\").concat(points[1][1], \" \\n                    L \").concat(points[2][0], \",\").concat(points[2][1], \" Z\");\n      }\n\n      // Calculate rounded corners\n      var corners = [this.calculateRoundedCorner(points[1], points[2], points[0], appliedRadius),\n      // left\n      this.calculateRoundedCorner(points[2], points[0], points[1], appliedRadius),\n      // top\n      this.calculateRoundedCorner(points[0], points[1], points[2], appliedRadius) // right\n      ];\n\n      // Fall back to simple triangle if corner calculation fails\n      if (corners.some(function (corner) {\n        return !corner;\n      })) {\n        return \"M \".concat(points[0][0], \",\").concat(points[0][1], \" \\n                    L \").concat(points[1][0], \",\").concat(points[1][1], \" \\n                    L \").concat(points[2][0], \",\").concat(points[2][1], \" Z\");\n      }\n\n      // Calculate start point\n      var startX = corners[0].center[0] + appliedRadius * Math.cos(corners[0].startAngle);\n      var startY = corners[0].center[1] + appliedRadius * Math.sin(corners[0].startAngle);\n\n      // Generate path with rounded corners\n      return \"M \".concat(startX, \",\").concat(startY, \"\\n                A \").concat(appliedRadius, \",\").concat(appliedRadius, \" 0 0 1 \\n                  \").concat(corners[0].center[0] + appliedRadius * Math.cos(corners[0].endAngle), \",\\n                  \").concat(corners[0].center[1] + appliedRadius * Math.sin(corners[0].endAngle), \"\\n                L \").concat(corners[1].center[0] + appliedRadius * Math.cos(corners[1].startAngle), \",\\n                  \").concat(corners[1].center[1] + appliedRadius * Math.sin(corners[1].startAngle), \"\\n                A \").concat(appliedRadius, \",\").concat(appliedRadius, \" 0 0 1 \\n                  \").concat(corners[1].center[0] + appliedRadius * Math.cos(corners[1].endAngle), \",\\n                  \").concat(corners[1].center[1] + appliedRadius * Math.sin(corners[1].endAngle), \"\\n                L \").concat(corners[2].center[0] + appliedRadius * Math.cos(corners[2].startAngle), \",\\n                  \").concat(corners[2].center[1] + appliedRadius * Math.sin(corners[2].startAngle), \"\\n                A \").concat(appliedRadius, \",\").concat(appliedRadius, \" 0 0 1 \\n                  \").concat(corners[2].center[0] + appliedRadius * Math.cos(corners[2].endAngle), \",\\n                  \").concat(corners[2].center[1] + appliedRadius * Math.sin(corners[2].endAngle), \"\\n                Z\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var triangles = [];\n      var cellWidth = (this.width - this.spacing * (this.columns - 1)) / this.columns;\n      var cellHeight = (this.height - this.spacing * (this.rows - 1)) / this.rows;\n      var startX = -this.width / 2;\n      var startY = -this.height / 2;\n\n      // Generate grid of triangles\n      for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n          var x = startX + j * (cellWidth + this.spacing);\n          var y = startY + i * (cellHeight + this.spacing);\n          var path = this.generateRoundedTrianglePath(x, y, cellWidth, cellHeight, this.cornerRadius);\n          triangles.push(\"<path \\n                    d=\\\"\".concat(path, \"\\\"\\n                    fill=\\\"\").concat(this.mode === 'fill' ? 'white' : 'none', \"\\\"\\n                    stroke=\\\"\").concat(this.mode === 'stroke' ? 'white' : 'none', \"\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                />\"));\n        }\n      }\n      return triangles.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedTriangleGrid, \"parameters\", {\n  width: {\n    min: 100,\n    max: 250,\n    \"default\": 220\n  },\n  height: {\n    min: 100,\n    max: 250,\n    \"default\": 200\n  },\n  rows: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  columns: {\n    min: 1,\n    max: 8,\n    \"default\": 1\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  },\n  cornerRadius: {\n    min: 0,\n    max: 150,\n    \"default\": 100\n  },\n  mode: {\n    options: ['stroke', 'fill'],\n    \"default\": 'fill'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedTriangleGrid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedTrianglesGrid.js?");

/***/ }),

/***/ "./src/shapes/RoundedTruchet.js":
/*!**************************************!*\
  !*** ./src/shapes/RoundedTruchet.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar RoundedTruchet = /*#__PURE__*/function (_Shape) {\n  function RoundedTruchet() {\n    _classCallCheck(this, RoundedTruchet);\n    return _callSuper(this, RoundedTruchet, arguments);\n  }\n  _inherits(RoundedTruchet, _Shape);\n  return _createClass(RoundedTruchet, [{\n    key: \"adaptSize\",\n    value: function adaptSize() {\n      var maxDimension = 400 * 0.9;\n      var calculatedTileSize = maxDimension / this.gridSize;\n      this.tileSize = Math.min(this.tileSize, calculatedTileSize);\n    }\n  }, {\n    key: \"getPseudoRandom\",\n    value: function getPseudoRandom(x, y) {\n      var value = Math.sin(x * 12.9898 + y * 78.233 + this.seed) * 43758.5453;\n      return value - Math.floor(value);\n    }\n  }, {\n    key: \"createNoiseField\",\n    value: function createNoiseField() {\n      var _this = this;\n      this.grid = Array(this.gridSize).fill().map(function (_, y) {\n        return Array(_this.gridSize).fill().map(function (_, x) {\n          return _this.getPseudoRandom(x, y);\n        });\n      });\n      var smoothedGrid = Array(this.gridSize).fill().map(function () {\n        return Array(_this.gridSize).fill(0);\n      });\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          var avg = this.grid[y][x];\n          var count = 1;\n          for (var dy = -1; dy <= 1; dy++) {\n            for (var dx = -1; dx <= 1; dx++) {\n              if (dx === 0 && dy === 0) continue;\n              var nx = x + dx;\n              var ny = y + dy;\n              if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize) {\n                avg += this.grid[ny][nx];\n                count++;\n              }\n            }\n          }\n          avg /= count;\n          smoothedGrid[y][x] = avg * this.flowIntensity + this.grid[y][x] * (1 - this.flowIntensity);\n          if (this.contrast > 0) {\n            smoothedGrid[y][x] = Math.pow(smoothedGrid[y][x], 1 + this.contrast * 2);\n          }\n        }\n      }\n      this.grid = smoothedGrid;\n    }\n  }, {\n    key: \"getRotation\",\n    value: function getRotation(x, y) {\n      var noiseValue = this.grid[y][x];\n      var baseRotation = Math.floor(noiseValue * 4) * 90;\n      var balanceValue = this.getPseudoRandom(x + 100, y + 100);\n      if (balanceValue > this.patternBalance) {\n        var rotIndex = Math.floor(this.getPseudoRandom(x + 200, y + 200) * 4);\n        return this.patterns[rotIndex];\n      }\n      return baseRotation;\n    }\n  }, {\n    key: \"createTile\",\n    value: function createTile(rotation, x, y) {\n      var xPos = x * this.tileSize;\n      var yPos = y * this.tileSize;\n      var size = this.tileSize;\n      var transform = \"translate(\".concat(xPos, \",\").concat(yPos, \") rotate(\").concat(rotation, \", \").concat(size / 2, \", \").concat(size / 2, \")\");\n      return \"<g transform=\\\"\".concat(transform, \"\\\">\\n            <path d=\\\"M 0 0 A \").concat(size, \" \").concat(size, \" 0 0 1 \").concat(size, \" \").concat(size, \" L 0 \").concat(size, \" Z\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\\n        </g>\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.flowIntensity = this.flowIntensity / 100;\n      this.patternBalance = this.patternBalance / 100;\n      this.contrast = this.contrast / 100;\n      this.patterns = [0, 90, 180, 270];\n      this.seed = 12345;\n      this.adaptSize();\n      this.createNoiseField();\n      this.adaptSize();\n      var totalWidth = this.gridSize * this.tileSize;\n      var offset = -totalWidth / 2;\n      var shapes = [\"<g transform=\\\"translate(\".concat(offset, \",\").concat(offset, \")\\\">\")];\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          var rotation = this.getRotation(x, y);\n          shapes.push(this.createTile(rotation, x, y));\n        }\n      }\n      shapes.push('</g>');\n      return shapes.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(RoundedTruchet, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 10,\n    \"default\": 2\n  },\n  tileSize: {\n    min: 25,\n    max: 100,\n    \"default\": 90\n  },\n  flowIntensity: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  },\n  patternBalance: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  contrast: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoundedTruchet);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/RoundedTruchet.js?");

/***/ }),

/***/ "./src/shapes/SemicirclePattern.js":
/*!*****************************************!*\
  !*** ./src/shapes/SemicirclePattern.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SemicirclePattern = /*#__PURE__*/function (_Shape) {\n  function SemicirclePattern() {\n    _classCallCheck(this, SemicirclePattern);\n    return _callSuper(this, SemicirclePattern, arguments);\n  }\n  _inherits(SemicirclePattern, _Shape);\n  return _createClass(SemicirclePattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var semicircles = [];\n      var totalWidth = this.columns * (this.radius * 2 + this.spacing) - this.spacing;\n      var totalHeight = this.rows * (this.radius * 2 + this.spacing) - this.spacing;\n      var startX = -totalWidth / 2 + this.radius;\n      var startY = -totalHeight / 2.5 + this.radius;\n      for (var row = 0; row < this.rows; row++) {\n        for (var col = 0; col < this.columns; col++) {\n          var centerX = startX + col * (this.radius * 2 + this.spacing);\n          var centerY = startY + row * (this.radius * 2 + this.spacing);\n          var path = [\"M \".concat(centerX - this.radius, \" \").concat(centerY), \"A \".concat(this.radius, \" \").concat(this.radius, \" 0 0 1 \").concat(centerX + this.radius, \" \").concat(centerY)].join(' ');\n          semicircles.push(\"<path \\n                    d=\\\"\".concat(path, \"\\\"\\n                    fill=\\\"none\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n                />\"));\n        }\n      }\n      return semicircles.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SemicirclePattern, \"parameters\", {\n  rows: {\n    min: 1,\n    max: 6,\n    \"default\": 3\n  },\n  columns: {\n    min: 1,\n    max: 6,\n    \"default\": 3\n  },\n  radius: {\n    min: 10,\n    max: 50,\n    \"default\": 30\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SemicirclePattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SemicirclePattern.js?");

/***/ }),

/***/ "./src/shapes/SerratedFrame.js":
/*!*************************************!*\
  !*** ./src/shapes/SerratedFrame.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SerratedFrame = /*#__PURE__*/function (_Shape) {\n  function SerratedFrame() {\n    _classCallCheck(this, SerratedFrame);\n    return _callSuper(this, SerratedFrame, arguments);\n  }\n  _inherits(SerratedFrame, _Shape);\n  return _createClass(SerratedFrame, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 200 / 300; // Assuming viewBox is -200 -200 400 400\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Get parameter values\n      var baseSize = this.baseSize * scale;\n      var flameHeight = this.flameHeight * scale;\n      var flameCount = this.flameCount;\n      var flameWidth = this.flameWidth;\n      var turbulence = this.turbulence;\n\n      // Create base diamond points\n      var diamondPoints = [{\n        x: center.x,\n        y: center.y - baseSize\n      },\n      // Top\n      {\n        x: center.x + baseSize,\n        y: center.y\n      },\n      // Right\n      {\n        x: center.x,\n        y: center.y + baseSize\n      },\n      // Bottom\n      {\n        x: center.x - baseSize,\n        y: center.y\n      } // Left\n      ];\n\n      // Function to generate flame points along an edge\n      function generateFlamePoints(start, end, count) {\n        var points = [];\n        var segmentLength = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n        var dx = (end.x - start.x) / count;\n        var dy = (end.y - start.y) / count;\n        for (var i = 0; i <= count; i++) {\n          var progress = i / count;\n          var baseX = start.x + dx * i;\n          var baseY = start.y + dy * i;\n          if (i > 0 && i < count) {\n            // Calculate flame tip position\n            var angle = Math.atan2(end.y - start.y, end.x - start.x) + Math.PI / 2;\n            var flameLen = flameHeight * (1 + Math.sin(progress * Math.PI) * turbulence);\n            var tipX = baseX + Math.cos(angle) * flameLen;\n            var tipY = baseY + Math.sin(angle) * flameLen;\n\n            // Add control points for curved flames\n            var ctrl1X = baseX + Math.cos(angle) * flameLen * flameWidth;\n            var ctrl1Y = baseY + Math.sin(angle) * flameLen * flameWidth;\n            points.push({\n              x: ctrl1X,\n              y: ctrl1Y\n            });\n            points.push({\n              x: tipX,\n              y: tipY\n            });\n            points.push({\n              x: baseX,\n              y: baseY\n            });\n          } else {\n            points.push({\n              x: baseX,\n              y: baseY\n            });\n          }\n        }\n        return points;\n      }\n\n      // Start the path at the first diamond point\n      var path = \"M \".concat(diamondPoints[0].x, \" \").concat(diamondPoints[0].y);\n\n      // Create flames for each edge of the diamond\n      for (var i = 0; i < 4; i++) {\n        var start = diamondPoints[i];\n        var end = diamondPoints[(i + 1) % 4];\n        var flamePoints = generateFlamePoints(start, end, flameCount);\n\n        // Draw flames using curved paths\n        for (var index = 0; index < flamePoints.length; index++) {\n          if (index % 3 === 0) {\n            path += \" L \".concat(flamePoints[index].x, \" \").concat(flamePoints[index].y);\n          } else {\n            path += \" Q \".concat(flamePoints[index - 1].x, \" \").concat(flamePoints[index - 1].y, \" \").concat(flamePoints[index].x, \" \").concat(flamePoints[index].y);\n          }\n        }\n      }\n\n      // Close the path\n      path += ' Z';\n      return \"<path d=\\\"\".concat(path, \"\\\" fill=\\\"white\\\"/>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SerratedFrame, \"parameters\", {\n  baseSize: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  flameHeight: {\n    min: 10,\n    max: 80,\n    \"default\": 30\n  },\n  flameCount: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  flameWidth: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  },\n  turbulence: {\n    min: 0,\n    max: 1,\n    \"default\": 0.3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SerratedFrame);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SerratedFrame.js?");

/***/ }),

/***/ "./src/shapes/Shape.js":
/*!*****************************!*\
  !*** ./src/shapes/Shape.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shape: () => (/* binding */ Shape)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Shape = /*#__PURE__*/function () {\n  function Shape() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Shape);\n    var classParameters = this.constructor.parameters || {};\n\n    // Merge parameters from parent class with child class\n    var allParameters = _objectSpread(_objectSpread({}, Shape.parameters), classParameters);\n    var defaults = Object.fromEntries(Object.entries(allParameters).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n      return [key, value[\"default\"]];\n    }));\n    Object.assign(this, defaults, options);\n\n    // Initialize the RNG with the seed\n    this.initRNG();\n  }\n\n  // Initialize RNG with current seed\n  return _createClass(Shape, [{\n    key: \"initRNG\",\n    value: function initRNG() {\n      this.rng = this.createSeededRNG(this.seed);\n    }\n\n    // Seeded random number generator that child classes can use\n  }, {\n    key: \"createSeededRNG\",\n    value: function createSeededRNG(seed) {\n      return {\n        _seed: seed,\n        next: function next() {\n          this._seed = (this._seed * 9301 + 49297) % 233280;\n          return this._seed / 233280;\n        }\n      };\n    }\n\n    // Convenience method to get next random number\n  }, {\n    key: \"random\",\n    value: function random() {\n      return this.rng.next();\n    }\n\n    // Reset RNG to initial seed or a new seed\n  }, {\n    key: \"resetRNG\",\n    value: function resetRNG(newSeed) {\n      if (newSeed !== undefined) {\n        this.seed = newSeed;\n      }\n      this.initRNG();\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      throw new Error('generateShape() method must be implemented in child class');\n    }\n  }]);\n}();\n_defineProperty(Shape, \"parameters\", {\n  seed: {\n    min: 1,\n    max: 10000,\n    \"default\": 42\n  }\n});\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Shape.js?");

/***/ }),

/***/ "./src/shapes/SierpinskiTriangle.js":
/*!******************************************!*\
  !*** ./src/shapes/SierpinskiTriangle.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SierpinskiTriangle = /*#__PURE__*/function (_Shape) {\n  function SierpinskiTriangle() {\n    _classCallCheck(this, SierpinskiTriangle);\n    return _callSuper(this, SierpinskiTriangle, arguments);\n  }\n  _inherits(SierpinskiTriangle, _Shape);\n  return _createClass(SierpinskiTriangle, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n\n      // Calculate initial triangle points\n      var height = this.size * Math.sqrt(3) / 2;\n      var x1 = -this.size / 2;\n      var y1 = height / 2;\n      var x2 = this.size / 2;\n      var y2 = height / 2;\n      var x3 = 0;\n      var y3 = -height / 2;\n\n      // Limit iterations to prevent stack overflow\n      var safeIterations = Math.min(5, Math.floor(this.iterations));\n\n      // Generate Sierpinski triangles recursively\n      this.drawSierpinski(elements, x1, y1, x2, y2, x3, y3, safeIterations);\n      return elements.join('');\n    }\n  }, {\n    key: \"drawSierpinski\",\n    value: function drawSierpinski(elements, x1, y1, x2, y2, x3, y3, depth) {\n      // Base case: depth is 0 or minimal area (to prevent stack overflow)\n      var area = Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2);\n      if (depth <= 0 || area < 1) {\n        // Draw the triangle\n        elements.push(\"<polygon\\n        points=\\\"\".concat(x1, \",\").concat(y1, \" \").concat(x2, \",\").concat(y2, \" \").concat(x3, \",\").concat(y3, \"\\\"\\n        stroke=\\\"white\\\"\\n        stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n        fill=\\\"none\\\"\\n      />\"));\n      } else {\n        // Calculate midpoints\n        var x12 = (x1 + x2) / 2;\n        var y12 = (y1 + y2) / 2;\n        var x23 = (x2 + x3) / 2;\n        var y23 = (y2 + y3) / 2;\n        var x31 = (x3 + x1) / 2;\n        var y31 = (y3 + y1) / 2;\n\n        // Add a limit to prevent infinite recursion\n        var nextDepth = depth - 1;\n\n        // Recursively draw three smaller triangles (with reduced stack usage)\n        if (nextDepth >= 0) {\n          this.drawSierpinski(elements, x1, y1, x12, y12, x31, y31, nextDepth);\n          this.drawSierpinski(elements, x12, y12, x2, y2, x23, y23, nextDepth);\n          this.drawSierpinski(elements, x31, y31, x23, y23, x3, y3, nextDepth);\n        }\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SierpinskiTriangle, \"parameters\", {\n  size: {\n    min: 100,\n    max: 180,\n    \"default\": 180\n  },\n  iterations: {\n    min: 1,\n    max: 5,\n    \"default\": 3\n  },\n  thickness: {\n    min: 0.5,\n    max: 5,\n    \"default\": 3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SierpinskiTriangle);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SierpinskiTriangle.js?");

/***/ }),

/***/ "./src/shapes/SignalShape.js":
/*!***********************************!*\
  !*** ./src/shapes/SignalShape.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SignalShape = /*#__PURE__*/function (_Shape) {\n  function SignalShape() {\n    _classCallCheck(this, SignalShape);\n    return _callSuper(this, SignalShape, arguments);\n  }\n  _inherits(SignalShape, _Shape);\n  return _createClass(SignalShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG for consistency\n      this.resetRNG();\n\n      // Calculate dimensions\n      var barHeights = this.calculateBarHeights();\n      var totalWidth = this.barCount * this.barWidth + (this.barCount - 1) * this.spacing;\n      var startX = -totalWidth / 2;\n\n      // Determine if we should split the signal into two groups (like in Image 2)\n      var elements = [];\n      if (this.splitStyle === 'wifi') {\n        // Create WiFi-style signal (left side square, right side rounded)\n        var leftCount = Math.ceil(this.barCount / 2);\n        var rightCount = this.barCount - leftCount;\n\n        // First group (square bars, ascending left to right)\n        for (var i = 0; i < leftCount; i++) {\n          var height = barHeights[i];\n          var x = startX + i * (this.barWidth + this.spacing);\n          var y = -height / 2;\n          elements.push(\"<rect \\n                    x=\\\"\".concat(x, \"\\\" \\n                    y=\\\"\").concat(y, \"\\\" \\n                    width=\\\"\").concat(this.barWidth, \"\\\" \\n                    height=\\\"\").concat(height, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n\n        // Second group (rounded bars, ascending left to right)\n        for (var _i = 0; _i < rightCount; _i++) {\n          var idx = _i + leftCount;\n          var _height = barHeights[idx];\n          var _x = startX + idx * (this.barWidth + this.spacing);\n          var _y = -_height / 2;\n          elements.push(\"<rect \\n                    x=\\\"\".concat(_x, \"\\\" \\n                    y=\\\"\").concat(_y, \"\\\" \\n                    width=\\\"\").concat(this.barWidth, \"\\\" \\n                    height=\\\"\").concat(_height, \"\\\"\\n                    rx=\\\"\").concat(this.style === 'square' ? 0 : Math.min(this.barWidth / 2, 8), \"\\\" \\n                    ry=\\\"\").concat(this.style === 'square' ? 0 : Math.min(this.barWidth / 2, 8), \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n      } else {\n        // Standard signal bars (all same style, ascending left to right)\n        for (var _i2 = 0; _i2 < this.barCount; _i2++) {\n          var _height2 = barHeights[_i2];\n          var _x2 = startX + _i2 * (this.barWidth + this.spacing);\n          var _y2 = -_height2 / 2;\n          var radius = this.style === 'rounded' ? Math.min(this.cornerRadius, this.barWidth / 2) : 0;\n          elements.push(\"<rect \\n                    x=\\\"\".concat(_x2, \"\\\" \\n                    y=\\\"\").concat(_y2, \"\\\" \\n                    width=\\\"\").concat(this.barWidth, \"\\\" \\n                    height=\\\"\").concat(_height2, \"\\\"\\n                    rx=\\\"\").concat(radius, \"\\\" \\n                    ry=\\\"\").concat(radius, \"\\\"\\n                    fill=\\\"white\\\"\\n                />\"));\n        }\n      }\n      return \"<g transform=\\\"rotate(90)\\\">\".concat(elements.join(''), \"</g>\");\n    }\n  }, {\n    key: \"calculateBarHeights\",\n    value: function calculateBarHeights() {\n      var heights = [];\n      var heightDiff = this.maxHeight - this.minHeight;\n      for (var i = 0; i < this.barCount; i++) {\n        // Calculate height based on position (increasing from left to right)\n        var ratio = i / (this.barCount - 1);\n        var height = this.minHeight + heightDiff * ratio;\n        heights.push(height);\n      }\n      return heights;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SignalShape, \"parameters\", {\n  barCount: {\n    min: 3,\n    max: 8,\n    \"default\": 5\n  },\n  spacing: {\n    min: 2,\n    max: 15,\n    \"default\": 8\n  },\n  minHeight: {\n    min: 10,\n    max: 40,\n    \"default\": 20\n  },\n  maxHeight: {\n    min: 30,\n    max: 200,\n    \"default\": 180\n  },\n  barWidth: {\n    min: 5,\n    max: 25,\n    \"default\": 15\n  },\n  cornerRadius: {\n    min: 0,\n    max: 10,\n    \"default\": 0\n  },\n  style: {\n    options: ['square', 'rounded'],\n    \"default\": 'square'\n  },\n  splitStyle: {\n    options: ['standard', 'wifi'],\n    \"default\": 'standard'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SignalShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SignalShape.js?");

/***/ }),

/***/ "./src/shapes/Spikes.js":
/*!******************************!*\
  !*** ./src/shapes/Spikes.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SpikesShape = /*#__PURE__*/function (_Shape) {\n  function SpikesShape() {\n    _classCallCheck(this, SpikesShape);\n    return _callSuper(this, SpikesShape, arguments);\n  }\n  _inherits(SpikesShape, _Shape);\n  return _createClass(SpikesShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var halfSize = this.size / 2;\n      var segmentWidth = this.size / (this.segments * 2); // Each Spikes needs 2 segments\n      var pathPoints = [];\n\n      // Calculate maximum safe skew to stay within bounds\n      var maxSkewOffset = segmentWidth / 2;\n      var skewOffset = this.skew / 45 * maxSkewOffset; // Normalize skew to max offset\n\n      // Start at top-left corner\n      pathPoints.push(\"M \".concat(-halfSize, \" \").concat(-halfSize));\n\n      // Create Spikes pattern\n      for (var i = 0; i <= this.segments * 2; i++) {\n        var baseX = -halfSize + i * segmentWidth;\n\n        // Apply skew only to peaks, keeping base points aligned\n        var isTop = i % 2 === 0;\n        var x = baseX + (isTop ? 0 : skewOffset);\n        var y = -halfSize + (isTop ? 0 : this.size);\n        pathPoints.push(\"L \".concat(x, \" \").concat(y));\n      }\n\n      // Complete the rectangle\n      pathPoints.push(\"L \".concat(halfSize, \" \").concat(halfSize));\n      pathPoints.push(\"L \".concat(-halfSize, \" \").concat(halfSize));\n      pathPoints.push('Z');\n      return \"<path \\n            d=\\\"\".concat(pathPoints.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SpikesShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 400,\n    \"default\": 200\n  },\n  segments: {\n    min: 2,\n    max: 8,\n    \"default\": 4\n  },\n  skew: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpikesShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Spikes.js?");

/***/ }),

/***/ "./src/shapes/Spiral.js":
/*!******************************!*\
  !*** ./src/shapes/Spiral.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SpiralShape = /*#__PURE__*/function (_Shape) {\n  function SpiralShape() {\n    _classCallCheck(this, SpiralShape);\n    return _callSuper(this, SpiralShape, arguments);\n  }\n  _inherits(SpiralShape, _Shape);\n  return _createClass(SpiralShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate points along the spiral\n      var points = [];\n      var steps = Math.floor(this.revolutions * 50); // 50 points per revolution for smoothness\n\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps * (this.revolutions * 2 * Math.PI);\n        var radius = t / (2 * Math.PI) * this.spacing;\n        var x = radius * Math.cos(t);\n        var y = radius * Math.sin(t);\n        points.push([x, y]);\n      }\n\n      // Generate SVG path\n      var pathData = points.reduce(function (path, _ref, i) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        return path + (i === 0 ? \"M \".concat(x, \" \").concat(y) : \" L \".concat(x, \" \").concat(y));\n      }, '');\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SpiralShape, \"parameters\", {\n  revolutions: {\n    min: 1,\n    max: 5,\n    \"default\": 4\n  },\n  spacing: {\n    min: 10,\n    max: 50,\n    \"default\": 20\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 5\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpiralShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Spiral.js?");

/***/ }),

/***/ "./src/shapes/SpiralWave.js":
/*!**********************************!*\
  !*** ./src/shapes/SpiralWave.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SpiralWave = /*#__PURE__*/function (_Shape) {\n  function SpiralWave() {\n    _classCallCheck(this, SpiralWave);\n    return _callSuper(this, SpiralWave, arguments);\n  }\n  _inherits(SpiralWave, _Shape);\n  return _createClass(SpiralWave, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var viewBoxWidth = 200;\n      var viewBoxHeight = 200;\n      var padding = 0.8;\n      var effectiveWidth = viewBoxWidth - 2 * padding;\n      var effectiveHeight = viewBoxHeight - 2 * padding;\n      var scale = Math.min(effectiveWidth, effectiveHeight) / 300;\n      var xMin = -viewBoxWidth / 2 + padding;\n      var xMax = viewBoxWidth / 2 - padding;\n      var yMin = -viewBoxHeight / 2 + padding;\n      var yMax = viewBoxHeight / 2 - padding;\n      var centerX = (xMin + xMax) / 2;\n      var strands = this.strands;\n      var amplitude = this.amplitude * scale;\n      var frequency = this.frequency;\n      var phase = this.phase * (Math.PI / 180);\n      var thickness = this.thickness * scale;\n      var spread = this.spread * scale;\n      var paths = [];\n      for (var strand = 0; strand < strands; strand++) {\n        var strandOffset = strand * spread / (strands - 1);\n        var strandPhase = phase + strand * 0.5;\n        var d = \"\";\n        for (var step = 0; step <= 100; step++) {\n          var t = step / 100;\n          var baseX = centerX - spread / 2 + strandOffset;\n          var x = baseX + amplitude * Math.sin(2 * Math.PI * frequency * t + strandPhase);\n          var y = yMin + effectiveHeight * t;\n          d += step === 0 ? \"M \".concat(x, \" \").concat(y) : \" L \".concat(x, \" \").concat(y);\n        }\n        paths.push(\"<path d=\\\"\".concat(d, \"\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(thickness, \"\\\" fill=\\\"none\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" />\"));\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SpiralWave, \"parameters\", {\n  strands: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  amplitude: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  frequency: {\n    min: 1,\n    max: 8,\n    \"default\": 1\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  spread: {\n    min: 10,\n    max: 100,\n    \"default\": 100\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpiralWave);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SpiralWave.js?");

/***/ }),

/***/ "./src/shapes/SpiroPetal.js":
/*!**********************************!*\
  !*** ./src/shapes/SpiroPetal.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SpiroPetal = /*#__PURE__*/function (_Shape) {\n  function SpiroPetal() {\n    _classCallCheck(this, SpiroPetal);\n    return _callSuper(this, SpiroPetal, arguments);\n  }\n  _inherits(SpiroPetal, _Shape);\n  return _createClass(SpiroPetal, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var paths = [];\n      var petalCount = parseInt(this.petals);\n      var offsetRad = this.offset * Math.PI / 180;\n\n      // Generate the points exactly like in the p5.js sketch\n      for (var k = 0; k < 2 * Math.PI; k += Math.PI / petalCount) {\n        var pathData = '';\n        var firstPoint = null;\n        for (var a = 0; a < 2 * Math.PI; a += 2 * Math.PI / 200) {\n          var s = offsetRad;\n\n          // Using the exact equations from the p5.js sketch\n          var x = Math.sin(a - s) * Math.cos(a + k - s) * this.outerRadius + (this.innerRadius + this.modulation * Math.sin(a + k + s)) * Math.sin(a + k + s);\n          var y = Math.cos(a - s) * Math.cos(a + k - s) * this.outerRadius + (this.innerRadius + this.modulation * Math.sin(a + k + s)) * Math.cos(a + k + s);\n\n          // Start the path with the first point\n          if (a === 0) {\n            pathData = \"M \".concat(x, \",\").concat(y);\n            firstPoint = {\n              x: x,\n              y: y\n            };\n          } else {\n            // Add line segments\n            pathData += \" L \".concat(x, \",\").concat(y);\n          }\n        }\n\n        // Close the path if needed\n        // pathData += ` Z`;\n\n        // Add the path to our collection\n        paths.push(\"<path \\n                d=\\\"\".concat(pathData, \"\\\" \\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SpiroPetal, \"parameters\", {\n  outerRadius: {\n    min: 50,\n    max: 100,\n    \"default\": 80\n  },\n  innerRadius: {\n    min: 10,\n    max: 50,\n    \"default\": 30\n  },\n  modulation: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 4\n  },\n  offset: {\n    min: 0,\n    max: 360,\n    \"default\": 45\n  },\n  petals: {\n    min: 1,\n    max: 2,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpiroPetal);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SpiroPetal.js?");

/***/ }),

/***/ "./src/shapes/SprocketShape.js":
/*!*************************************!*\
  !*** ./src/shapes/SprocketShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SprocketShape = /*#__PURE__*/function (_Shape) {\n  function SprocketShape() {\n    _classCallCheck(this, SprocketShape);\n    return _callSuper(this, SprocketShape, arguments);\n  }\n  _inherits(SprocketShape, _Shape);\n  return _createClass(SprocketShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var lines = [];\n\n      // Calculate dimensions\n      var radius = 100;\n      var innerRadius = radius * (1 - this.toothDepth);\n      var hubRadius = this.hubRadius * 100;\n      this.teeth = Math.round(this.teeth);\n      this.spokesCount = Math.round(this.spokesCount);\n\n      // Generate teeth\n      for (var i = 0; i < this.teeth; i++) {\n        var angle = i * 2 * Math.PI / this.teeth;\n        var nextAngle = (i + 1) * 2 * Math.PI / this.teeth;\n        var midAngle = (angle + nextAngle) / 2;\n\n        // Outer point\n        var x1 = radius * Math.cos(angle);\n        var y1 = radius * Math.sin(angle);\n\n        // Inner point\n        var x2 = innerRadius * Math.cos(midAngle);\n        var y2 = innerRadius * Math.sin(midAngle);\n        lines.push(\"<line \\n                x1=\\\"\".concat(x1, \"\\\" \\n                y1=\\\"\").concat(y1, \"\\\" \\n                x2=\\\"\").concat(x2, \"\\\" \\n                y2=\\\"\").concat(y2, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n\n        // Connect to next tooth (including back to first tooth)\n        var nextX = radius * Math.cos(nextAngle);\n        var nextY = radius * Math.sin(nextAngle);\n        lines.push(\"<line \\n                x1=\\\"\".concat(x2, \"\\\" \\n                y1=\\\"\").concat(y2, \"\\\" \\n                x2=\\\"\").concat(nextX, \"\\\" \\n                y2=\\\"\").concat(nextY, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n\n      // Draw hub circle\n      lines.push(\"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(hubRadius, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\"));\n\n      // Generate spokes\n      for (var _i = 0; _i < this.spokesCount; _i++) {\n        var _angle = _i * 2 * Math.PI / this.spokesCount;\n        var x = innerRadius * Math.cos(_angle);\n        var y = innerRadius * Math.sin(_angle);\n        lines.push(\"<line \\n                x1=\\\"\".concat(hubRadius * Math.cos(_angle), \"\\\" \\n                y1=\\\"\").concat(hubRadius * Math.sin(_angle), \"\\\" \\n                x2=\\\"\").concat(x, \"\\\" \\n                y2=\\\"\").concat(y, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n      return lines.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SprocketShape, \"parameters\", {\n  teeth: {\n    min: 6,\n    max: 24,\n    \"default\": 32\n  },\n  toothDepth: {\n    min: 0.1,\n    max: 0.3,\n    \"default\": 0.2\n  },\n  hubRadius: {\n    min: 0.2,\n    max: 0.4,\n    \"default\": 0.2\n  },\n  spokesCount: {\n    min: 3,\n    max: 8,\n    \"default\": 6\n  },\n  thickness: {\n    min: 1,\n    max: 5,\n    \"default\": 4\n  },\n  lineCap: {\n    options: ['butt', 'round'],\n    \"default\": 'round'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SprocketShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SprocketShape.js?");

/***/ }),

/***/ "./src/shapes/SquareBoxShape.js":
/*!**************************************!*\
  !*** ./src/shapes/SquareBoxShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SquareBoxShape = /*#__PURE__*/function (_Shape) {\n  function SquareBoxShape() {\n    _classCallCheck(this, SquareBoxShape);\n    return _callSuper(this, SquareBoxShape, arguments);\n  }\n  _inherits(SquareBoxShape, _Shape);\n  return _createClass(SquareBoxShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate dimensions ensuring the inner rectangle fits\n      var innerHeight = this.size - this.padding * 2;\n\n      // Center the shapes in the viewBox\n      var offset = -this.size / 2;\n\n      // Calculate maximum x-offset to keep inner rect within bounds\n      var maxSlide = this.size - this.innerWidth - this.padding * 2;\n      var normalizedOffset = maxSlide * this.xOffset / 100; // Convert percentage to actual offset\n\n      // Generate the outer square with rounded corners\n      var outerSquare = \"<rect \\n            x=\\\"\".concat(offset, \"\\\"\\n            y=\\\"\").concat(offset, \"\\\"\\n            width=\\\"\").concat(this.size, \"\\\"\\n            height=\\\"\").concat(this.size, \"\\\"\\n            rx=\\\"\").concat(this.outerRadius, \"\\\"\\n            ry=\\\"\").concat(this.outerRadius, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n\n      // Generate the inner rectangle with horizontal offset\n      var innerRect = \"<rect \\n            x=\\\"\".concat(offset + this.padding + normalizedOffset, \"\\\"\\n            y=\\\"\").concat(offset + this.padding, \"\\\"\\n            width=\\\"\").concat(this.innerWidth, \"\\\"\\n            height=\\\"\").concat(innerHeight, \"\\\"\\n            rx=\\\"\").concat(this.innerRadius, \"\\\"\\n            ry=\\\"\").concat(this.innerRadius, \"\\\"\\n            fill=\\\"black\\\"\\n        />\");\n      return \"\".concat(outerSquare).concat(innerRect);\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SquareBoxShape, \"parameters\", {\n  size: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  outerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  },\n  innerRadius: {\n    min: 0,\n    max: 25,\n    \"default\": 0\n  },\n  innerWidth: {\n    min: 5,\n    max: 50,\n    \"default\": 20\n  },\n  padding: {\n    min: 5,\n    max: 30,\n    \"default\": 15\n  },\n  xOffset: {\n    min: 0,\n    max: 100,\n    \"default\": 0\n  } // New parameter for horizontal sliding\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SquareBoxShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SquareBoxShape.js?");

/***/ }),

/***/ "./src/shapes/SquaresPyramid.js":
/*!**************************************!*\
  !*** ./src/shapes/SquaresPyramid.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SquaresPyramid = /*#__PURE__*/function (_Shape) {\n  function SquaresPyramid() {\n    _classCallCheck(this, SquaresPyramid);\n    return _callSuper(this, SquaresPyramid, arguments);\n  }\n  _inherits(SquaresPyramid, _Shape);\n  return _createClass(SquaresPyramid, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var squares = [];\n      var totalHeight = this.rows * (this.squareSize + this.spacing);\n      var startY = -totalHeight / 2;\n      for (var row = 0; row < this.rows; row++) {\n        var squaresInRow = row + 1;\n        var rowWidth = squaresInRow * (this.squareSize + this.spacing) - this.spacing;\n        var startX = -rowWidth / 2;\n        for (var col = 0; col < squaresInRow; col++) {\n          var x = startX + col * (this.squareSize + this.spacing);\n          var y = startY + row * (this.squareSize + this.spacing);\n          squares.push(\"<rect \\n                    x=\\\"\".concat(x, \"\\\"\\n                    y=\\\"\").concat(y, \"\\\"\\n                    width=\\\"\").concat(this.squareSize, \"\\\"\\n                    height=\\\"\").concat(this.squareSize, \"\\\"\\n                    fill=\\\"\").concat(this.fillStyle === 'fill' ? 'white' : 'none', \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                />\"));\n        }\n      }\n      return squares.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SquaresPyramid, \"parameters\", {\n  rows: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  squareSize: {\n    min: 10,\n    max: 50,\n    \"default\": 50\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  spacing: {\n    min: 0,\n    max: 20,\n    \"default\": 8\n  },\n  fillStyle: {\n    options: ['stroke', 'fill'],\n    \"default\": 'fill'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SquaresPyramid);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SquaresPyramid.js?");

/***/ }),

/***/ "./src/shapes/SquiggleShape.js":
/*!*************************************!*\
  !*** ./src/shapes/SquiggleShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar WaveCurve = /*#__PURE__*/function (_Shape) {\n  function WaveCurve() {\n    _classCallCheck(this, WaveCurve);\n    return _callSuper(this, WaveCurve, arguments);\n  }\n  _inherits(WaveCurve, _Shape);\n  return _createClass(WaveCurve, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = [];\n      var segments = this.points;\n      var phaseRad = this.phase * Math.PI / 180;\n\n      // Generate base points\n      for (var i = 0; i < segments; i++) {\n        var t = i / (segments - 1);\n        var x = (t * 2 - 1) * this.radius;\n\n        // Base wave with frequency\n        var y = Math.sin(t * Math.PI * 2 * this.frequency + phaseRad) * this.amplitude;\n\n        // Add controlled noise\n        if (this.noise > 0) {\n          var noiseAmount = this.noise / 100 * this.amplitude * 0.5;\n          var noise = Math.sin(t * 12.9898 + phaseRad) * Math.sin(t * 78.233 + phaseRad) * noiseAmount;\n          y += noise;\n        }\n        points.push([x, y]);\n      }\n\n      // Create SVG path\n      var pathData = \"M \".concat(points[0][0], \",\").concat(points[0][1]);\n      var tensionFactor = 1 - this.tension / 100;\n\n      // Smooth curves with variable control points\n      for (var _i = 1; _i < points.length; _i++) {\n        var p0 = points[_i - 1];\n        var p1 = points[_i];\n\n        // Calculate control points with variable distance based on smoothness\n        var dx = p1[0] - p0[0];\n        var dy = p1[1] - p0[1];\n\n        // Control point distance affected by both smoothness and tension\n        var cp_dist = Math.min(Math.abs(dx) * 0.5, 30) * tensionFactor;\n\n        // Control points\n        var cp1 = [p0[0] + cp_dist, p0[1]];\n        var cp2 = [p1[0] - cp_dist, p1[1]];\n        pathData += \" C \".concat(cp1[0], \",\").concat(cp1[1], \" \").concat(cp2[0], \",\").concat(cp2[1], \" \").concat(p1[0], \",\").concat(p1[1]);\n      }\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WaveCurve, \"parameters\", {\n  points: {\n    min: 3,\n    max: 10,\n    \"default\": 8\n  },\n  // Number of control points\n  radius: {\n    min: 10,\n    max: 150,\n    \"default\": 78\n  },\n  // Overall width\n  thickness: {\n    min: 1,\n    max: 20,\n    \"default\": 15\n  },\n  // Line thickness\n  amplitude: {\n    min: 0,\n    max: 100,\n    \"default\": 56\n  },\n  // Wave height\n  frequency: {\n    min: 1,\n    max: 8,\n    \"default\": 4\n  },\n  // Wave frequency\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 2\n  },\n  // Rotation offset\n  tension: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  },\n  // Curve tension\n  noise: {\n    min: 0,\n    max: 100,\n    \"default\": 20\n  } // Random variation amount\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WaveCurve);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SquiggleShape.js?");

/***/ }),

/***/ "./src/shapes/Squircle.js":
/*!********************************!*\
  !*** ./src/shapes/Squircle.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar Squircle = /*#__PURE__*/function (_Shape) {\n  function Squircle() {\n    _classCallCheck(this, Squircle);\n    return _callSuper(this, Squircle, arguments);\n  }\n  _inherits(Squircle, _Shape);\n  return _createClass(Squircle, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Scale factors and constraints\n      var baseSize = 200;\n      var minDimension = baseSize;\n      var scaleFactor = minDimension / baseSize;\n\n      // Scale parameters with safety bounds\n      var scaledRadius = Math.min(this.cornerRadius * scaleFactor, minDimension / 3);\n      var scaledInset = Math.min(this.inset * scaleFactor, minDimension / 4);\n      var scaledSmoothFactor = scaledRadius * this.smoothness;\n      var scaledBalancedRadius = scaledRadius * this.cornerBalance;\n\n      // Calculate drawing dimensions\n      var availableSize = minDimension - scaledInset * 2;\n      var halfSize = availableSize / 2;\n      var center = 0; // Center point in our coordinate system\n\n      // Calculate key points relative to center\n      var minX = center - halfSize;\n      var maxX = center + halfSize;\n      var minY = center - halfSize;\n      var maxY = center + halfSize;\n\n      // Build SVG path\n      var path = [// Start at top-left radius point\n      \"M \".concat(minX + scaledBalancedRadius, \" \").concat(minY), // Top edge to top-right corner\n      \"L \".concat(maxX - scaledBalancedRadius, \" \").concat(minY), // Top-right corner curve\n      \"C \".concat(maxX - scaledBalancedRadius + scaledSmoothFactor, \" \").concat(minY), \"\".concat(maxX, \" \").concat(minY + scaledBalancedRadius - scaledSmoothFactor), \"\".concat(maxX, \" \").concat(minY + scaledBalancedRadius), // Right edge to bottom-right corner\n      \"L \".concat(maxX, \" \").concat(maxY - scaledBalancedRadius), // Bottom-right corner curve\n      \"C \".concat(maxX, \" \").concat(maxY - scaledBalancedRadius + scaledSmoothFactor), \"\".concat(maxX - scaledBalancedRadius + scaledSmoothFactor, \" \").concat(maxY), \"\".concat(maxX - scaledBalancedRadius, \" \").concat(maxY), // Bottom edge to bottom-left corner\n      \"L \".concat(minX + scaledBalancedRadius, \" \").concat(maxY), // Bottom-left corner curve\n      \"C \".concat(minX + scaledBalancedRadius - scaledSmoothFactor, \" \").concat(maxY), \"\".concat(minX, \" \").concat(maxY - scaledBalancedRadius + scaledSmoothFactor), \"\".concat(minX, \" \").concat(maxY - scaledBalancedRadius), // Left edge to top-left corner\n      \"L \".concat(minX, \" \").concat(minY + scaledBalancedRadius), // Top-left corner curve\n      \"C \".concat(minX, \" \").concat(minY + scaledBalancedRadius - scaledSmoothFactor), \"\".concat(minX + scaledBalancedRadius - scaledSmoothFactor, \" \").concat(minY), \"\".concat(minX + scaledBalancedRadius, \" \").concat(minY), 'Z' // Close the path\n      ].join(' ');\n      return \"<path \\n            d=\\\"\".concat(path, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(Squircle, \"parameters\", {\n  cornerRadius: {\n    min: 0,\n    max: 150,\n    \"default\": 80\n  },\n  smoothness: {\n    min: 0.1,\n    max: 1.0,\n    \"default\": 0.6\n  },\n  inset: {\n    min: 0,\n    max: 100,\n    \"default\": 20\n  },\n  cornerBalance: {\n    min: 0.1,\n    max: 2.0,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Squircle);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Squircle.js?");

/***/ }),

/***/ "./src/shapes/StackedCircles.js":
/*!**************************************!*\
  !*** ./src/shapes/StackedCircles.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar StackedCircles = /*#__PURE__*/function (_Shape) {\n  function StackedCircles() {\n    _classCallCheck(this, StackedCircles);\n    return _callSuper(this, StackedCircles, arguments);\n  }\n  _inherits(StackedCircles, _Shape);\n  return _createClass(StackedCircles, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var shapes = [];\n\n      // Calculate sizes from largest to smallest\n      var sizes = [];\n      // Start with a more appropriate size to fit ViewBox\n      var size = 160; // Slightly smaller than 200 to ensure visibility\n      for (var i = 0; i < this.count; i++) {\n        sizes.push(size);\n        size *= this.sizeRatio;\n      }\n\n      // Calculate total height with buffer for centering\n      var totalHeight = 0;\n      for (var _i = 0; _i < sizes.length; _i++) {\n        // Add full radius for proper spacing\n        totalHeight += sizes[_i] * 0.5;\n      }\n\n      // Start position depends on direction\n      var currentY = this.direction === 'up' ? -totalHeight / 2 : totalHeight / 2;\n\n      // Generate shapes from smallest to largest\n      for (var _i2 = this.count - 1; _i2 >= 0; _i2--) {\n        var radius = sizes[_i2] / 2;\n\n        // Apply horizontal shift (will be interpolated on hover)\n        var shiftX = this.shift * ((_i2 + 1) / this.count);\n\n        // Create half circle path based on direction\n        var sweepFlag = this.direction === 'up' ? 0 : 1;\n        var path = \"M \".concat(-radius + shiftX, \" \").concat(currentY, \" \\n                         A \").concat(radius, \" \").concat(radius, \" 0 0 \").concat(sweepFlag, \" \").concat(radius + shiftX, \" \").concat(currentY, \" \\n                         L \").concat(-radius + shiftX, \" \").concat(currentY, \" Z\");\n\n        // Apply fill or hollow style without opacity\n        var style = this.fillMode === 'filled' ? 'fill=\"white\" stroke=\"none\"' : 'fill=\"none\" stroke=\"white\" stroke-width=\"2\"';\n        shapes.push(\"<path d=\\\"\".concat(path, \"\\\" \").concat(style, \"/>\"));\n\n        // Move in appropriate direction by radius with additional spacing to prevent overlap\n        var spacing = radius;\n        currentY += this.direction === 'up' ? spacing : -spacing;\n      }\n      return shapes.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StackedCircles, \"parameters\", {\n  count: {\n    min: 1,\n    max: 12,\n    \"default\": 3\n  },\n  sizeRatio: {\n    min: 0.3,\n    max: 0.8,\n    \"default\": 0.5\n  },\n  fillMode: {\n    options: ['filled', 'hollow'],\n    \"default\": 'filled'\n  },\n  direction: {\n    options: ['up', 'down'],\n    \"default\": 'up'\n  },\n  // Parameter names that will animate on hover\n  shift: {\n    min: -40,\n    max: 40,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StackedCircles);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StackedCircles.js?");

/***/ }),

/***/ "./src/shapes/StampShape.js":
/*!**********************************!*\
  !*** ./src/shapes/StampShape.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar StampShape = /*#__PURE__*/function (_Shape) {\n  function StampShape() {\n    _classCallCheck(this, StampShape);\n    return _callSuper(this, StampShape, arguments);\n  }\n  _inherits(StampShape, _Shape);\n  return _createClass(StampShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var maskId = \"stamp-mask-\".concat(Math.random().toString(36).substr(2, 9));\n\n      // Calculate half size for positioning\n      var halfSize = this.baseSize / 2;\n\n      // Create mask definition\n      var maskDef = \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <rect \\n                        x=\\\"\").concat(-halfSize, \"\\\"\\n                        y=\\\"\").concat(-halfSize, \"\\\"\\n                        width=\\\"\").concat(this.baseSize, \"\\\"\\n                        height=\\\"\").concat(this.baseSize, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\\n                    \").concat(this.generateCircles(), \"\\n                </mask>\\n            </defs>\\n        \");\n\n      // Create main shape with mask applied\n      var mainShape = \"\\n            <rect\\n                x=\\\"\".concat(-halfSize, \"\\\"\\n                y=\\\"\").concat(-halfSize, \"\\\"\\n                width=\\\"\").concat(this.baseSize, \"\\\"\\n                height=\\\"\").concat(this.baseSize, \"\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\\n        \");\n      return \"\".concat(maskDef).concat(mainShape);\n    }\n  }, {\n    key: \"generateCircles\",\n    value: function generateCircles() {\n      var points = [];\n      var halfSize = this.baseSize / 2;\n\n      // Generate perimeter points based on grid size\n      for (var i = 0; i < this.gridSize; i++) {\n        var t = i / (this.gridSize - 1);\n        var pos = -halfSize + this.baseSize * t;\n\n        // Add points for each side\n        points.push([pos, -halfSize],\n        // Top edge\n        [pos, halfSize],\n        // Bottom edge\n        [-halfSize, pos],\n        // Left edge\n        [halfSize, pos] // Right edge\n        );\n      }\n\n      // Remove duplicate corner points\n      var uniquePoints = points.filter(function (point, index, self) {\n        return index === self.findIndex(function (p) {\n          return p[0] === point[0] && p[1] === point[1];\n        });\n      });\n\n      // Calculate adjusted radius (animatable on hover)\n      var adjustedRadius = this.circleRadius * this.intensity;\n\n      // Generate circles as black shapes in the mask\n      return uniquePoints.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n        return \"\\n            <circle\\n                cx=\\\"\".concat(x, \"\\\"\\n                cy=\\\"\").concat(y, \"\\\"\\n                r=\\\"\").concat(adjustedRadius, \"\\\"\\n                fill=\\\"black\\\"\\n            />\");\n      }).join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StampShape, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 8,\n    \"default\": 5\n  },\n  circleRadius: {\n    min: 5,\n    max: 30,\n    \"default\": 15\n  },\n  baseSize: {\n    min: 50,\n    max: 300,\n    \"default\": 155\n  },\n  intensity: {\n    min: 0.7,\n    max: 1.3,\n    \"default\": 1\n  } // This parameter will animate on hover\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StampShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StampShape.js?");

/***/ }),

/***/ "./src/shapes/Star.js":
/*!****************************!*\
  !*** ./src/shapes/Star.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar StarShape = /*#__PURE__*/function (_Shape) {\n  function StarShape() {\n    _classCallCheck(this, StarShape);\n    return _callSuper(this, StarShape, arguments);\n  }\n  _inherits(StarShape, _Shape);\n  return _createClass(StarShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Ensure points is an integer\n      var numPoints = Math.round(this.points);\n\n      // Convert innerSize to ratio\n      this.innerSizeRatio = this.innerSize / 100;\n\n      // Convert rotation to radians\n      var rotationRad = this.rotation * Math.PI / 180;\n\n      // Convert corner radii to half values as per original implementation\n      // Add adaptive scaling based on point count to prevent issues during interpolation\n      var adaptiveFactor = Math.min(1, 8 / numPoints);\n      this.outerCornerRadiusHalf = this.outerCornerRadius / 2 * adaptiveFactor;\n      this.innerCornerRadiusHalf = this.innerCornerRadius / 2 * adaptiveFactor;\n      var points = [];\n      var outerRadius = this.size;\n      var innerRadius = this.size * this.innerSizeRatio;\n      var angleStep = Math.PI / numPoints;\n\n      // Generate points\n      for (var i = 0; i < numPoints * 2; i++) {\n        var angle = i * angleStep + rotationRad;\n        var radius = i % 2 === 0 ? outerRadius : innerRadius;\n        points.push([Math.cos(angle) * radius, Math.sin(angle) * radius]);\n      }\n\n      // Generate path\n      var path = \"<path \\n            d=\\\"M \".concat(points[0][0], \" \").concat(points[0][1]);\n      for (var _i = 1; _i <= points.length; _i++) {\n        var curr = points[_i % points.length];\n        var prev = points[_i - 1];\n        var next = points[(_i + 1) % points.length];\n        var cornerRadius = _i % 2 === 0 ? this.outerCornerRadiusHalf : this.innerCornerRadiusHalf;\n        if (cornerRadius <= 0) {\n          path += \" L \".concat(curr[0], \" \").concat(curr[1]);\n        } else {\n          // Calculate direction vectors\n          var toPrev = [prev[0] - curr[0], prev[1] - curr[1]];\n          var toNext = [next[0] - curr[0], next[1] - curr[1]];\n\n          // Normalize vectors\n          var lenPrev = Math.sqrt(toPrev[0] * toPrev[0] + toPrev[1] * toPrev[1]);\n          var lenNext = Math.sqrt(toNext[0] * toNext[0] + toNext[1] * toNext[1]);\n\n          // Prevent division by zero\n          var normPrev = lenPrev === 0 ? [0, 0] : [toPrev[0] / lenPrev, toPrev[1] / lenPrev];\n          var normNext = lenNext === 0 ? [0, 0] : [toNext[0] / lenNext, toNext[1] / lenNext];\n\n          // Calculate control points - limit corner radius to not exceed half of segment length\n          var maxRadius = Math.min(lenPrev, lenNext) / 2;\n          var limitedRadius = Math.min(cornerRadius, maxRadius);\n          var cp1 = [curr[0] + normPrev[0] * limitedRadius, curr[1] + normPrev[1] * limitedRadius];\n          var cp2 = [curr[0] + normNext[0] * limitedRadius, curr[1] + normNext[1] * limitedRadius];\n          path += \" L \".concat(cp1[0], \" \").concat(cp1[1]);\n          path += \" Q \".concat(curr[0], \" \").concat(curr[1], \" \").concat(cp2[0], \" \").concat(cp2[1]);\n        }\n      }\n      path += ' Z\" fill=\"white\" />';\n      return path;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StarShape, \"parameters\", {\n  points: {\n    min: 4,\n    max: 32,\n    \"default\": 8\n  },\n  size: {\n    min: 50,\n    max: 150,\n    \"default\": 100\n  },\n  innerSize: {\n    min: 1,\n    max: 99,\n    \"default\": 40\n  },\n  outerCornerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  },\n  innerCornerRadius: {\n    min: 0,\n    max: 50,\n    \"default\": 0\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StarShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Star.js?");

/***/ }),

/***/ "./src/shapes/StarCircle.js":
/*!**********************************!*\
  !*** ./src/shapes/StarCircle.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar StarCircleShape = /*#__PURE__*/function (_Shape) {\n  function StarCircleShape() {\n    _classCallCheck(this, StarCircleShape);\n    return _callSuper(this, StarCircleShape, arguments);\n  }\n  _inherits(StarCircleShape, _Shape);\n  return _createClass(StarCircleShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Ensure numBlades is an integer\n      var numBladesInt = Math.round(this.numBlades);\n\n      // Convert rotation to radians\n      var rotationRad = this.rotation * Math.PI / 180;\n\n      // Create local copies of parameters and convert percentages to actual values\n      var bladeLength = this.bladeLength / 100;\n      var circleSize = this.circleSize / 100;\n\n      // Ensure blade length is always proportionally larger than circle size\n      var adjustedBladeLength = Math.max(bladeLength, circleSize * 1.5);\n      var size = 300;\n      var halfSize = size / 2;\n\n      // Calculate dimensions\n      var radius = halfSize * adjustedBladeLength;\n      var circleRadius = halfSize * circleSize;\n      var angleStep = 2 * Math.PI / numBladesInt;\n\n      // Generate blades\n      var blades = [];\n      for (var i = 0; i < numBladesInt; i++) {\n        var angle = i * angleStep + rotationRad;\n        var midAngle = angle + angleStep / 2;\n\n        // Adaptive arc offset based on the number of blades\n        // Ensures blades don't overlap with too many points\n        var adaptiveFactor = Math.min(1, 5 / numBladesInt);\n        var arcOffset = angleStep * 0.2 * adaptiveFactor;\n\n        // Calculate blade points\n        var tip = {\n          x: Math.cos(midAngle) * radius,\n          y: Math.sin(midAngle) * radius\n        };\n\n        // Calculate connection points on circle\n        var base1 = {\n          x: Math.cos(midAngle - arcOffset) * circleRadius,\n          y: Math.sin(midAngle - arcOffset) * circleRadius\n        };\n        var base2 = {\n          x: Math.cos(midAngle + arcOffset) * circleRadius,\n          y: Math.sin(midAngle + arcOffset) * circleRadius\n        };\n\n        // Create blade path\n        var bladePath = \"M \".concat(base1.x, \" \").concat(base1.y, \" \\n                             L \").concat(tip.x, \" \").concat(tip.y, \" \\n                             L \").concat(base2.x, \" \").concat(base2.y);\n        blades.push(bladePath);\n      }\n\n      // Combine blades and circle\n      return \"\\n            \".concat(blades.map(function (blade) {\n        return \"<path d=\\\"\".concat(blade, \"\\\" fill=\\\"white\\\" />\");\n      }).join('\\n'), \"\\n            <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"\").concat(circleRadius, \"\\\" fill=\\\"white\\\" />\\n        \");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StarCircleShape, \"parameters\", {\n  numBlades: {\n    min: 3,\n    max: 16,\n    \"default\": 4\n  },\n  // Number of blades\n  bladeLength: {\n    min: 20,\n    max: 100,\n    \"default\": 80\n  },\n  // Base length of blades\n  circleSize: {\n    min: 10,\n    max: 80,\n    \"default\": 30\n  },\n  // Size of center circle\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  } // Rotation in degrees\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StarCircleShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StarCircle.js?");

/***/ }),

/***/ "./src/shapes/StarCluster.js":
/*!***********************************!*\
  !*** ./src/shapes/StarCluster.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar StarCluster = /*#__PURE__*/function (_Shape) {\n  function StarCluster() {\n    _classCallCheck(this, StarCluster);\n    return _callSuper(this, StarCluster, arguments);\n  }\n  _inherits(StarCluster, _Shape);\n  return _createClass(StarCluster, [{\n    key: \"point\",\n    value:\n    // Helper function to calculate point from center, radius, and angle\n    function point(centerX, centerY, radius, angle) {\n      return {\n        x: centerX + radius * Math.cos(angle),\n        y: centerY + radius * Math.sin(angle)\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Base setup and scaling\n      var maxSize = 400;\n      var scale = 0.8;\n      var centerX = 0;\n      var centerY = 0;\n\n      // Scale parameters\n      var nodeCount = Math.round(this.nodes);\n      var branchCount = Math.round(this.branchCount);\n      var thickness = this.thickness * scale;\n      var innerScale = this.innerScale;\n\n      // Adjust radius and branch length to ensure shape fits within bounds\n      var baseRadius = this.radius * scale;\n      var baseBranchLength = this.branchLength * scale;\n\n      // Calculate maximum allowed radius to ensure shape fits in square\n      var maxRadius = maxSize / 2 - baseBranchLength;\n      var radius = Math.min(baseRadius, maxRadius);\n      var branchLength = Math.min(baseBranchLength, maxSize / 4);\n\n      // Generate paths for the star cluster\n      var paths = [];\n\n      // Generate main node points around center\n      var nodeAngles = Array.from({\n        length: nodeCount\n      }, function (_, i) {\n        return i * 2 * Math.PI / nodeCount;\n      });\n\n      // Create star-like pattern at each node\n      nodeAngles.forEach(function (baseAngle) {\n        var nodeCenter = _this.point(centerX, centerY, radius, baseAngle);\n        var angleStep = 2 * Math.PI / branchCount;\n\n        // Create petal-like shapes at each node\n        for (var i = 0; i < branchCount; i++) {\n          var startAngle = baseAngle + angleStep * i;\n\n          // Calculate outer point\n          var outerPoint = _this.point(nodeCenter.x, nodeCenter.y, branchLength, startAngle);\n          if (innerScale > 0) {\n            // Calculate inner points for petal shape\n            var innerPoint1 = _this.point(nodeCenter.x, nodeCenter.y, branchLength * innerScale, startAngle + angleStep * 0.3);\n            var innerPoint2 = _this.point(nodeCenter.x, nodeCenter.y, branchLength * innerScale, startAngle - angleStep * 0.3);\n\n            // Draw petal\n            paths.push(\"M \".concat(nodeCenter.x, \" \").concat(nodeCenter.y, \"\\n                        L \").concat(innerPoint1.x, \" \").concat(innerPoint1.y, \"\\n                        L \").concat(outerPoint.x, \" \").concat(outerPoint.y, \"\\n                        L \").concat(innerPoint2.x, \" \").concat(innerPoint2.y, \"\\n                        Z\"));\n          } else {\n            // Draw simple line for innerScale = 0\n            paths.push(\"M \".concat(nodeCenter.x, \" \").concat(nodeCenter.y, \"\\n                        L \").concat(outerPoint.x, \" \").concat(outerPoint.y));\n          }\n        }\n      });\n      return \"<path \\n            d=\\\"\".concat(paths.join(' '), \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linejoin=\\\"round\\\"\\n            stroke-linecap=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StarCluster, \"parameters\", {\n  nodes: {\n    min: 4,\n    max: 12,\n    \"default\": 6\n  },\n  radius: {\n    min: 40,\n    max: 80,\n    \"default\": 80\n  },\n  branchLength: {\n    min: 10,\n    max: 80,\n    \"default\": 40\n  },\n  branchCount: {\n    min: 4,\n    max: 12,\n    \"default\": 6\n  },\n  thickness: {\n    min: 2,\n    max: 10,\n    \"default\": 4\n  },\n  innerScale: {\n    min: 0.4,\n    max: 0.8,\n    \"default\": 0.5\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StarCluster);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StarCluster.js?");

/***/ }),

/***/ "./src/shapes/StarburstRingsShape.js":
/*!*******************************************!*\
  !*** ./src/shapes/StarburstRingsShape.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar StarburstRingsShape = /*#__PURE__*/function (_Shape) {\n  function StarburstRingsShape() {\n    _classCallCheck(this, StarburstRingsShape);\n    return _callSuper(this, StarburstRingsShape, arguments);\n  }\n  _inherits(StarburstRingsShape, _Shape);\n  return _createClass(StarburstRingsShape, [{\n    key: \"getRandomInRange\",\n    value:\n    // These methods have been simplified to use the inherited random() method\n    function getRandomInRange(min, max) {\n      return min + this.random() * (max - min);\n    }\n  }, {\n    key: \"getRandomIntInRange\",\n    value: function getRandomIntInRange(min, max) {\n      return Math.floor(this.getRandomInRange(min, max + 1));\n    }\n  }, {\n    key: \"createArcPath\",\n    value: function createArcPath(radius, startAngle, endAngle) {\n      var startX = radius * Math.cos(startAngle);\n      var startY = radius * Math.sin(startAngle);\n      var endX = radius * Math.cos(endAngle);\n      var endY = radius * Math.sin(endAngle);\n      var largeArcFlag = endAngle - startAngle > Math.PI ? 1 : 0;\n      return \"M \".concat(startX, \",\").concat(startY, \" A \").concat(radius, \",\").concat(radius, \" 0 \").concat(largeArcFlag, \" 1 \").concat(endX, \",\").concat(endY);\n    }\n  }, {\n    key: \"generateCircleWithGaps\",\n    value: function generateCircleWithGaps(radius, gapCount, minGapAngle, maxGapAngle) {\n      var minGapRad = minGapAngle * Math.PI / 180;\n      var maxGapRad = maxGapAngle * Math.PI / 180;\n      var gaps = [];\n      var totalGapSize = 0;\n      for (var i = 0; i < gapCount; i++) {\n        var gapSize = this.getRandomInRange(minGapRad, maxGapRad);\n        var gapStart = this.getRandomInRange(0, 2 * Math.PI - gapSize);\n        gaps.push({\n          start: gapStart,\n          end: gapStart + gapSize\n        });\n        totalGapSize += gapSize;\n      }\n\n      // Ensure gaps are sorted and merged properly\n      gaps.sort(function (a, b) {\n        return a.start - b.start;\n      });\n      var mergedGaps = [];\n      var currentGap = gaps[0];\n      for (var _i = 1; _i < gaps.length; _i++) {\n        if (gaps[_i].start <= currentGap.end) {\n          currentGap.end = Math.max(currentGap.end, gaps[_i].end);\n        } else {\n          mergedGaps.push(currentGap);\n          currentGap = gaps[_i];\n        }\n      }\n      mergedGaps.push(currentGap);\n\n      // Create arcs between gaps\n      var segments = [];\n      var lastEnd = mergedGaps[mergedGaps.length - 1].end - 2 * Math.PI;\n      for (var _i2 = 0, _mergedGaps = mergedGaps; _i2 < _mergedGaps.length; _i2++) {\n        var gap = _mergedGaps[_i2];\n        if (gap.start > lastEnd) {\n          segments.push(this.createArcPath(radius, lastEnd, gap.start));\n        }\n        lastEnd = gap.end;\n      }\n      if (mergedGaps[0].start + 2 * Math.PI > lastEnd) {\n        segments.push(this.createArcPath(radius, lastEnd, mergedGaps[0].start + 2 * Math.PI));\n      }\n      return segments;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n      this.randomizeEach = !!this.randomizeEach;\n      var paths = [];\n      var radiusStep = (this.maxRadius - this.minRadius) / (this.circleCount - 1);\n      var baseGapCount, baseMinGapAngle, baseMaxGapAngle;\n      if (!this.randomizeEach) {\n        baseGapCount = this.getRandomIntInRange(this.minGapCount, this.maxGapCount);\n        baseMinGapAngle = this.minGapAngle;\n        baseMaxGapAngle = this.maxGapAngle;\n      }\n      for (var i = 0; i < this.circleCount; i++) {\n        var radius = this.maxRadius - i * radiusStep;\n        var gapCount = void 0,\n          minGapAngle = void 0,\n          maxGapAngle = void 0;\n        if (this.randomizeEach) {\n          gapCount = this.getRandomIntInRange(this.minGapCount, this.maxGapCount);\n          minGapAngle = this.minGapAngle;\n          maxGapAngle = this.maxGapAngle;\n        } else {\n          gapCount = baseGapCount;\n          minGapAngle = baseMinGapAngle;\n          maxGapAngle = baseMaxGapAngle;\n        }\n        var segments = this.generateCircleWithGaps(radius, gapCount, minGapAngle, maxGapAngle);\n        segments.forEach(function (segment) {\n          paths.push(\"<path\\n                    d=\\\"\".concat(segment, \"\\\"\\n                    fill=\\\"none\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(_this.thickness, \"\\\"\\n                    stroke-linecap=\\\"\").concat(_this.lineCap, \"\\\"\\n                />\"));\n        });\n      }\n      return paths.join(\"\\n\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StarburstRingsShape, \"parameters\", {\n  circleCount: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  minRadius: {\n    min: 5,\n    max: 40,\n    \"default\": 20\n  },\n  maxRadius: {\n    min: 70,\n    max: 100,\n    \"default\": 100\n  },\n  thickness: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  minGapCount: {\n    min: 1,\n    max: 8,\n    \"default\": 1\n  },\n  maxGapCount: {\n    min: 2,\n    max: 12,\n    \"default\": 6\n  },\n  minGapAngle: {\n    min: 5,\n    max: 90,\n    \"default\": 25\n  },\n  maxGapAngle: {\n    min: 15,\n    max: 90,\n    \"default\": 90\n  },\n  randomizeEach: {\n    options: [true, false],\n    \"default\": true\n  },\n  lineCap: {\n    options: [\"butt\", \"round\"],\n    \"default\": \"round\"\n  }\n  // seed parameter is now inherited from Shape class\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StarburstRingsShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StarburstRingsShape.js?");

/***/ }),

/***/ "./src/shapes/StarburstShape.js":
/*!**************************************!*\
  !*** ./src/shapes/StarburstShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar StarburstShape = /*#__PURE__*/function (_Shape) {\n  function StarburstShape() {\n    _classCallCheck(this, StarburstShape);\n    return _callSuper(this, StarburstShape, arguments);\n  }\n  _inherits(StarburstShape, _Shape);\n  return _createClass(StarburstShape, [{\n    key: \"rotatePoint\",\n    value:\n    // Helper function to rotate a point around a center point\n    function rotatePoint(point, center, angle) {\n      var dx = point.x - center.x;\n      var dy = point.y - center.y;\n      var cos = Math.cos(angle);\n      var sin = Math.sin(angle);\n      return {\n        x: dx * cos - dy * sin + center.x,\n        y: dx * sin + dy * cos + center.y\n      };\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Calculate dimensions\n      var size = 200;\n\n      // Get parameter values and ensure proper types\n      var spikeDepth = this.spikeDepth;\n      var spikeWidth = this.spikeWidth;\n      var spikesPerSide = Math.round(this.spikesPerSide);\n      var innerPadding = this.innerPadding;\n\n      // Calculate effective dimensions\n      var effectiveSize = size - innerPadding * 2;\n      var halfSize = effectiveSize / 2;\n\n      // Array to store all path commands\n      var pathCommands = [];\n\n      // Create spikes for each side\n      var _loop = function _loop() {\n        var rotation = side * Math.PI / 2;\n\n        // Calculate spikes for current side\n        for (var spikeIndex = 0; spikeIndex < spikesPerSide; spikeIndex++) {\n          var spikeSpacing = effectiveSize / spikesPerSide;\n          var spikeOffset = spikeSpacing * spikeIndex - (halfSize - spikeSpacing / 2);\n\n          // Create base spike points before rotation\n          var basePoints = [{\n            x: spikeOffset - spikeWidth / 2,\n            y: halfSize\n          },\n          // Left point\n          {\n            x: spikeOffset,\n            y: halfSize - spikeDepth\n          },\n          // Tip point\n          {\n            x: spikeOffset + spikeWidth / 2,\n            y: halfSize\n          } // Right point\n          ];\n\n          // Rotate and translate points\n          var points = basePoints.map(function (point) {\n            return _this.rotatePoint(point, {\n              x: 0,\n              y: 0\n            }, rotation);\n          });\n\n          // Add to path commands\n          if (pathCommands.length === 0) {\n            pathCommands.push(\"M \".concat(points[0].x, \" \").concat(points[0].y));\n          } else {\n            pathCommands.push(\"L \".concat(points[0].x, \" \").concat(points[0].y));\n          }\n          pathCommands.push(\"L \".concat(points[1].x, \" \").concat(points[1].y));\n          pathCommands.push(\"L \".concat(points[2].x, \" \").concat(points[2].y));\n        }\n      };\n      for (var side = 0; side < 4; side++) {\n        _loop();\n      }\n\n      // Close the path\n      pathCommands.push('Z');\n      return \"<path \\n            d=\\\"\".concat(pathCommands.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StarburstShape, \"parameters\", {\n  spikeDepth: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  spikeWidth: {\n    min: 10,\n    max: 100,\n    \"default\": 30\n  },\n  spikesPerSide: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  },\n  innerPadding: {\n    min: 0,\n    max: 50,\n    \"default\": 20\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StarburstShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StarburstShape.js?");

/***/ }),

/***/ "./src/shapes/StitchPattern.js":
/*!*************************************!*\
  !*** ./src/shapes/StitchPattern.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar StitchPattern = /*#__PURE__*/function (_Shape) {\n  function StitchPattern() {\n    _classCallCheck(this, StitchPattern);\n    return _callSuper(this, StitchPattern, arguments);\n  }\n  _inherits(StitchPattern, _Shape);\n  return _createClass(StitchPattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var elements = [];\n\n      // Calculate total width and height based on the number of spaces between elements\n      var totalWidth = (this.columns - 1) * this.spacing;\n      var totalHeight = (this.rows - 1) * this.spacing;\n\n      // Calculate starting positions to center the pattern\n      var startX = -totalWidth / 2;\n      var startY = -totalHeight / 2;\n\n      // Generate all dashes in a grid pattern\n      for (var row = 0; row < this.rows; row++) {\n        for (var col = 0; col < this.columns; col++) {\n          var x = startX + col * this.spacing;\n          var y = startY + row * this.spacing;\n\n          // Alternate between horizontal and vertical dashes\n          // Even rows, odd columns: vertical dash\n          // Odd rows, even columns: vertical dash\n          // All other positions: horizontal dash\n          var isVertical = row % 2 === 0 && col % 2 === 1 || row % 2 === 1 && col % 2 === 0;\n          if (isVertical) {\n            // Add vertical dash\n            elements.push(\"<rect \\n            x=\\\"\".concat(x - this.dashHeight / 2, \"\\\" \\n            y=\\\"\").concat(y - this.dashWidth / 2, \"\\\" \\n            width=\\\"\").concat(this.dashHeight, \"\\\" \\n            height=\\\"\").concat(this.dashWidth, \"\\\" \\n            rx=\\\"\").concat(this.cornerRadius, \"\\\"\\n            ry=\\\"\").concat(this.cornerRadius, \"\\\"\\n            fill=\\\"white\\\"\\n          />\"));\n          } else {\n            // Add horizontal dash\n            elements.push(\"<rect \\n            x=\\\"\".concat(x - this.dashWidth / 2, \"\\\" \\n            y=\\\"\").concat(y - this.dashHeight / 2, \"\\\" \\n            width=\\\"\").concat(this.dashWidth, \"\\\" \\n            height=\\\"\").concat(this.dashHeight, \"\\\" \\n            rx=\\\"\").concat(this.cornerRadius, \"\\\"\\n            ry=\\\"\").concat(this.cornerRadius, \"\\\"\\n            fill=\\\"white\\\"\\n          />\"));\n          }\n        }\n      }\n      return elements.join('');\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StitchPattern, \"parameters\", {\n  size: {\n    min: 100,\n    max: 200,\n    \"default\": 200\n  },\n  rows: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  columns: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  dashWidth: {\n    min: 10,\n    max: 40,\n    \"default\": 25\n  },\n  dashHeight: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  spacing: {\n    min: 10,\n    max: 40,\n    \"default\": 25\n  },\n  cornerRadius: {\n    min: 0,\n    max: 10,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StitchPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StitchPattern.js?");

/***/ }),

/***/ "./src/shapes/StitchedFrame.js":
/*!*************************************!*\
  !*** ./src/shapes/StitchedFrame.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar StitchedFrame = /*#__PURE__*/function (_Shape) {\n  function StitchedFrame() {\n    _classCallCheck(this, StitchedFrame);\n    return _callSuper(this, StitchedFrame, arguments);\n  }\n  _inherits(StitchedFrame, _Shape);\n  return _createClass(StitchedFrame, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Helper function to calculate distance between points\n      var distance = function distance(a, b) {\n        var dx = b.x - a.x;\n        var dy = b.y - a.y;\n        return Math.sqrt(dx * dx + dy * dy);\n      };\n\n      // Setup base parameters with scaling\n      var viewBoxSize = 200;\n      var scale = 0.8;\n      var zigzagDepth = this.zigzagDepth * scale;\n      var zigzagCount = Math.round(this.zigzagCount);\n      var thickness = this.thickness * scale;\n\n      // Calculate base square size to ensure shape stays within bounds\n      var baseSize = viewBoxSize - zigzagDepth * 2 - thickness * 2;\n      var halfSize = baseSize / 2;\n      var center = {\n        x: 0,\n        y: 0\n      };\n      var pathPoints = [];\n\n      // Create points for each side\n      for (var side = 0; side < 4; side++) {\n        var startAngle = side * Math.PI / 2;\n        var startPoint = {\n          x: center.x + Math.cos(startAngle) * halfSize,\n          y: center.y + Math.sin(startAngle) * halfSize\n        };\n        var endAngle = (side + 1) * Math.PI / 2;\n        var endPoint = {\n          x: center.x + Math.cos(endAngle) * halfSize,\n          y: center.y + Math.sin(endAngle) * halfSize\n        };\n\n        // Calculate zigzag points\n        var segmentLength = distance(startPoint, endPoint);\n        var zigzagSegmentLength = segmentLength / zigzagCount;\n        var direction = {\n          x: (endPoint.x - startPoint.x) / segmentLength,\n          y: (endPoint.y - startPoint.y) / segmentLength\n        };\n        var perpDirection = {\n          x: -direction.y,\n          y: direction.x\n        };\n\n        // Draw zigzags\n        for (var i = 0; i < zigzagCount; i++) {\n          var segmentStart = {\n            x: startPoint.x + direction.x * zigzagSegmentLength * i,\n            y: startPoint.y + direction.y * zigzagSegmentLength * i\n          };\n          var zigzagPoint = {\n            x: segmentStart.x + direction.x * (zigzagSegmentLength / 2) + perpDirection.x * zigzagDepth,\n            y: segmentStart.y + direction.y * (zigzagSegmentLength / 2) + perpDirection.y * zigzagDepth\n          };\n          if (i === 0 && side === 0) {\n            pathPoints.push(['M', segmentStart.x, segmentStart.y]);\n          }\n          pathPoints.push(['L', zigzagPoint.x, zigzagPoint.y]);\n          if (i < zigzagCount - 1 || side < 3) {\n            var nextPoint = {\n              x: startPoint.x + direction.x * zigzagSegmentLength * (i + 1),\n              y: startPoint.y + direction.y * zigzagSegmentLength * (i + 1)\n            };\n            pathPoints.push(['L', nextPoint.x, nextPoint.y]);\n          }\n        }\n      }\n      pathPoints.push(['Z']);\n\n      // Generate the SVG path\n      var pathData = pathPoints.map(function (point) {\n        return point.join(' ');\n      }).join(' ');\n\n      // Return SVG with path element\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StitchedFrame, \"parameters\", {\n  zigzagDepth: {\n    min: 5,\n    max: 40,\n    \"default\": 13\n  },\n  zigzagCount: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StitchedFrame);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StitchedFrame.js?");

/***/ }),

/***/ "./src/shapes/StylizedOShape.js":
/*!**************************************!*\
  !*** ./src/shapes/StylizedOShape.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar StylizedOShape = /*#__PURE__*/function (_Shape) {\n  function StylizedOShape() {\n    _classCallCheck(this, StylizedOShape);\n    return _callSuper(this, StylizedOShape, arguments);\n  }\n  _inherits(StylizedOShape, _Shape);\n  return _createClass(StylizedOShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Setup base parameters with scaling\n      var scale = 1;\n      var width = this.width * scale;\n      var height = this.height * scale;\n      var cutoutHeight = this.cutoutHeight * scale;\n      var cornerRadius = this.cornerRadius * scale;\n      var sideWidth = this.sideWidth * scale;\n\n      // Calculate cutout dimensions\n      var cutoutWidth = width - sideWidth * 2;\n\n      // Generate paths for outer rectangle and inner cutout\n      var outerPath = this.roundedRectPath(-width / 2,\n      // x\n      -height / 2,\n      // y\n      width,\n      // width\n      height,\n      // height\n      cornerRadius // radius\n      );\n      var innerPath = this.roundedRectPath(-cutoutWidth / 2,\n      // x\n      -cutoutHeight / 2,\n      // y\n      cutoutWidth,\n      // width\n      cutoutHeight,\n      // height\n      cornerRadius // radius\n      );\n\n      // Create unique IDs for the mask\n      var maskId = \"mask-\".concat(Math.random().toString(36).substr(2, 9));\n\n      // Return SVG with mask and path\n      return \"\\n            <defs>\\n                <mask id=\\\"\".concat(maskId, \"\\\">\\n                    <path \\n                        d=\\\"\").concat(outerPath, \"\\\"\\n                        fill=\\\"white\\\"\\n                    />\\n                    <path \\n                        d=\\\"\").concat(innerPath, \"\\\"\\n                        fill=\\\"black\\\"\\n                    />\\n                </mask>\\n            </defs>\\n            <rect \\n                x=\\\"\").concat(-width / 2, \"\\\"\\n                y=\\\"\").concat(-height / 2, \"\\\"\\n                width=\\\"\").concat(width, \"\\\"\\n                height=\\\"\").concat(height, \"\\\"\\n                fill=\\\"white\\\"\\n                mask=\\\"url(#\").concat(maskId, \")\\\"\\n            />\");\n    }\n  }, {\n    key: \"roundedRectPath\",\n    value: function roundedRectPath(x, y, width, height, radius) {\n      // Ensure radius doesn't exceed half of width or height\n      var r = Math.min(radius, Math.min(width / 2, height / 2));\n\n      // Start path at top-left corner after the radius\n      return \"M\".concat(x + r, \",\").concat(y, \"\\n            h\").concat(width - 2 * r, \"\\n            a\").concat(r, \",\").concat(r, \" 0 0 1 \").concat(r, \",\").concat(r, \"\\n            v\").concat(height - 2 * r, \"\\n            a\").concat(r, \",\").concat(r, \" 0 0 1 -\").concat(r, \",\").concat(r, \"\\n            h-\").concat(width - 2 * r, \"\\n            a\").concat(r, \",\").concat(r, \" 0 0 1 -\").concat(r, \",-\").concat(r, \"\\n            v-\").concat(height - 2 * r, \"\\n            a\").concat(r, \",\").concat(r, \" 0 0 1 \").concat(r, \",-\").concat(r, \"\\n            z\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(StylizedOShape, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  height: {\n    min: 80,\n    max: 250,\n    \"default\": 160\n  },\n  cutoutHeight: {\n    min: 10,\n    max: 60,\n    \"default\": 30\n  },\n  cornerRadius: {\n    min: 0,\n    max: 40,\n    \"default\": 20\n  },\n  sideWidth: {\n    min: 20,\n    max: 80,\n    \"default\": 40\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StylizedOShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/StylizedOShape.js?");

/***/ }),

/***/ "./src/shapes/Sun.js":
/*!***************************!*\
  !*** ./src/shapes/Sun.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar BladeShape = /*#__PURE__*/function (_Shape) {\n  function BladeShape() {\n    _classCallCheck(this, BladeShape);\n    return _callSuper(this, BladeShape, arguments);\n  }\n  _inherits(BladeShape, _Shape);\n  return _createClass(BladeShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var segments = [];\n      var angleStep = 2 * Math.PI / this.segmentCount;\n      var bladeWidthRad = this.bladeWidth * Math.PI / 180;\n      var twistRad = this.twist * Math.PI / 180;\n      for (var i = 0; i < this.segmentCount; i++) {\n        var baseAngle = i * angleStep;\n\n        // Calculate blade points\n        var tipAngle = baseAngle + twistRad;\n        var leftAngle = baseAngle - bladeWidthRad / 2;\n        var rightAngle = baseAngle + bladeWidthRad / 2;\n\n        // Inner points\n        var innerX1 = this.innerRadius * Math.cos(leftAngle);\n        var innerY1 = this.innerRadius * Math.sin(leftAngle);\n        var innerX2 = this.innerRadius * Math.cos(rightAngle);\n        var innerY2 = this.innerRadius * Math.sin(rightAngle);\n\n        // Outer tip point\n        var tipX = this.outerRadius * Math.cos(tipAngle);\n        var tipY = this.outerRadius * Math.sin(tipAngle);\n\n        // Create the blade segment\n        var path = \"\\n                M \".concat(innerX1, \" \").concat(innerY1, \"\\n                L \").concat(tipX, \" \").concat(tipY, \"\\n                L \").concat(innerX2, \" \").concat(innerY2, \"\\n                A \").concat(this.innerRadius, \" \").concat(this.innerRadius, \" 0 0 0 \").concat(innerX1, \" \").concat(innerY1, \"\\n                Z\\n            \");\n        segments.push(\"<path d=\\\"\".concat(path, \"\\\" fill=\\\"white\\\"/>\"));\n      }\n      return segments.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(BladeShape, \"parameters\", {\n  segmentCount: {\n    min: 3,\n    max: 24,\n    \"default\": 12\n  },\n  innerRadius: {\n    min: 2,\n    max: 100,\n    \"default\": 30\n  },\n  outerRadius: {\n    min: 50,\n    max: 150,\n    \"default\": 90\n  },\n  bladeWidth: {\n    min: 1,\n    max: 90,\n    \"default\": 45\n  },\n  // Angular width in degrees\n  twist: {\n    min: -90,\n    max: 90,\n    \"default\": 0\n  } // Rotation of blade tips\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BladeShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Sun.js?");

/***/ }),

/***/ "./src/shapes/SwirlingVortex.js":
/*!**************************************!*\
  !*** ./src/shapes/SwirlingVortex.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SwirlingVortex = /*#__PURE__*/function (_Shape) {\n  function SwirlingVortex() {\n    _classCallCheck(this, SwirlingVortex);\n    return _callSuper(this, SwirlingVortex, arguments);\n  }\n  _inherits(SwirlingVortex, _Shape);\n  return _createClass(SwirlingVortex, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG for consistent results\n      this.resetRNG();\n      var paths = [];\n      var maxRadius = 100;\n      var rotationRad = this.rotation * Math.PI / 180;\n\n      // Generate each spiral arm\n      for (var i = 0; i < this.arms; i++) {\n        var baseAngle = i * 2 * Math.PI / this.arms + rotationRad;\n\n        // Create spiral path with logarithmic function for smoother result\n        var pathData = this.generateSpiralPath(baseAngle, maxRadius);\n        paths.push(\"<path \\n                d=\\\"\".concat(pathData, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                fill=\\\"none\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      }\n      return paths.join('');\n    }\n  }, {\n    key: \"generateSpiralPath\",\n    value: function generateSpiralPath(baseAngle, maxRadius) {\n      // Use more points for smoother curve\n      var numPoints = 200;\n      var points = [];\n\n      // Generate a logarithmic spiral\n      for (var i = 0; i <= numPoints; i++) {\n        var t = i / numPoints;\n\n        // Logarithmic spiral function\n        var angle = baseAngle + this.turns * 2 * Math.PI * t;\n        var radius = maxRadius * t;\n\n        // Convert to cartesian coordinates\n        var x = radius * Math.cos(angle);\n        var y = radius * Math.sin(angle);\n        points.push([x, y]);\n      }\n\n      // Create a simple path connecting points directly - for clean spirals\n      var pathData = \"M \".concat(points[0][0], \",\").concat(points[0][1]);\n      for (var _i = 1; _i < points.length; _i++) {\n        pathData += \" L \".concat(points[_i][0], \",\").concat(points[_i][1]);\n      }\n      return pathData;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SwirlingVortex, \"parameters\", {\n  arms: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  turns: {\n    min: 1,\n    max: 5,\n    \"default\": 2.5\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 3\n  },\n  variation: {\n    min: 0,\n    max: 1,\n    \"default\": 0.2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SwirlingVortex);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SwirlingVortex.js?");

/***/ }),

/***/ "./src/shapes/SymmetricGridPattern.js":
/*!********************************************!*\
  !*** ./src/shapes/SymmetricGridPattern.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SymmetricGridPattern = /*#__PURE__*/function (_Shape) {\n  function SymmetricGridPattern() {\n    _classCallCheck(this, SymmetricGridPattern);\n    return _callSuper(this, SymmetricGridPattern, arguments);\n  }\n  _inherits(SymmetricGridPattern, _Shape);\n  return _createClass(SymmetricGridPattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var paths = [];\n      var rotationRad = this.rotation * Math.PI / 180;\n\n      // Generate one quadrant of lines\n      var generateQuadrant = function generateQuadrant(baseAngle) {\n        var lines = [];\n        var angleStep = Math.PI / 2 / (_this.lines - 1);\n        for (var i = 0; i < _this.lines; i++) {\n          var angle = baseAngle + i * angleStep;\n          var startX = 0;\n          var startY = 0;\n          var endX = _this.radius * Math.cos(angle);\n          var endY = _this.radius * Math.sin(angle);\n\n          // Add cross lines\n          for (var j = 0; j <= _this.lines; j++) {\n            var t = j / _this.lines;\n            var x1 = startX + (endX - startX) * t;\n            var y1 = startY + (endY - startY) * t;\n            var perpAngle = angle + Math.PI / 2;\n            var gridSpacing = _this.spacing * (1 - t); // Spacing decreases towards the center\n\n            var x2 = x1 + gridSpacing * Math.cos(perpAngle);\n            var y2 = y1 + gridSpacing * Math.sin(perpAngle);\n            lines.push(\"\\n                        <line \\n                            x1=\\\"\".concat(x1, \"\\\" \\n                            y1=\\\"\").concat(y1, \"\\\" \\n                            x2=\\\"\").concat(x2, \"\\\" \\n                            y2=\\\"\").concat(y2, \"\\\"\\n                            stroke=\\\"white\\\"\\n                            stroke-width=\\\"\").concat(_this.thickness, \"\\\"\\n                            stroke-linecap=\\\"round\\\"\\n                        />\\n                    \"));\n          }\n        }\n        return lines;\n      };\n\n      // Generate all four quadrants\n      for (var quadrant = 0; quadrant < 4; quadrant++) {\n        var baseAngle = quadrant * Math.PI / 2 + rotationRad;\n        var quadrantLines = generateQuadrant(baseAngle);\n        paths.push.apply(paths, _toConsumableArray(quadrantLines));\n      }\n      return paths.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SymmetricGridPattern, \"parameters\", {\n  lines: {\n    min: 6,\n    max: 24,\n    \"default\": 6\n  },\n  spacing: {\n    min: 6,\n    max: 20,\n    \"default\": 12\n  },\n  radius: {\n    min: 40,\n    max: 120,\n    \"default\": 80\n  },\n  rotation: {\n    min: -180,\n    max: 180,\n    \"default\": 45\n  },\n  thickness: {\n    min: 1,\n    max: 6,\n    \"default\": 4\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SymmetricGridPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SymmetricGridPattern.js?");

/***/ }),

/***/ "./src/shapes/SymmetricLines.js":
/*!**************************************!*\
  !*** ./src/shapes/SymmetricLines.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SymmetricLines = /*#__PURE__*/function (_Shape) {\n  function SymmetricLines() {\n    _classCallCheck(this, SymmetricLines);\n    return _callSuper(this, SymmetricLines, arguments);\n  }\n  _inherits(SymmetricLines, _Shape);\n  return _createClass(SymmetricLines, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.viewportSize = 150;\n      var lines = [];\n      var totalWidth = this.spacing * (this.count - 1);\n\n      // Calculate scale to fit within viewport\n      var scale = Math.min(1, this.viewportSize * 2 / totalWidth);\n      var scaledSpacing = this.spacing * scale;\n      var startX = -totalWidth * scale / 2;\n\n      // Calculate middle point for symmetry\n      var middleIndex = (this.count - 1) / 2;\n\n      // Generate lines\n      for (var i = 0; i < this.count; i++) {\n        var x = startX + i * scaledSpacing;\n\n        // Calculate height based on distance from center\n        var distanceFromCenter = Math.abs(i - middleIndex) / middleIndex;\n        var variationFactor = this.variation / 100;\n\n        // Create symmetrical height variation\n        var heightFactor = 1 - distanceFromCenter * variationFactor;\n        var height = this.minHeight + (this.maxHeight - this.minHeight) * heightFactor;\n        var scaledHeight = height * scale;\n        var halfHeight = scaledHeight / 2;\n        lines.push(\"<line \\n                x1=\\\"\".concat(x, \"\\\"\\n                y1=\\\"\").concat(-halfHeight, \"\\\"\\n                x2=\\\"\").concat(x, \"\\\"\\n                y2=\\\"\").concat(halfHeight, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness * scale, \"\\\"\\n                stroke-linecap=\\\"\").concat(this.lineCap, \"\\\"\\n            />\"));\n      }\n      return \"<g>\".concat(lines.join(''), \"</g>\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SymmetricLines, \"parameters\", {\n  count: {\n    min: 3,\n    max: 16,\n    \"default\": 7\n  },\n  spacing: {\n    min: 10,\n    max: 50,\n    \"default\": 22\n  },\n  minHeight: {\n    min: 20,\n    max: 200,\n    \"default\": 20\n  },\n  maxHeight: {\n    min: 50,\n    max: 250,\n    \"default\": 166\n  },\n  thickness: {\n    min: 2,\n    max: 30,\n    \"default\": 8\n  },\n  variation: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  lineCap: {\n    options: ['butt', 'round', 'square'],\n    \"default\": 'square'\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SymmetricLines);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SymmetricLines.js?");

/***/ }),

/***/ "./src/shapes/SymmetricTotem.js":
/*!**************************************!*\
  !*** ./src/shapes/SymmetricTotem.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SymmetricTotem = /*#__PURE__*/function (_Shape) {\n  function SymmetricTotem() {\n    _classCallCheck(this, SymmetricTotem);\n    return _callSuper(this, SymmetricTotem, arguments);\n  }\n  _inherits(SymmetricTotem, _Shape);\n  return _createClass(SymmetricTotem, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n\n      // Get scaled parameters\n      var rectHeight = this.rectangleHeight * scale;\n      var rectWidth = this.rectangleWidth * scale;\n      var arcRadius = this.arcRadius * scale;\n      var cornerRadius = this.cornerRadius * scale;\n\n      // Calculate rectangle bounds\n      var rectX = -rectWidth / 2;\n      var rectY = -rectHeight / 2;\n\n      // Create path for the rounded rectangle\n      var path = [];\n      if (cornerRadius > 0) {\n        // Top-left corner\n        path.push(\"M \".concat(rectX + cornerRadius, \" \").concat(rectY));\n        // Top edge\n        path.push(\"L \".concat(rectX + rectWidth - cornerRadius, \" \").concat(rectY));\n        // Top-right corner\n        path.push(\"A \".concat(cornerRadius, \" \").concat(cornerRadius, \" 0 0 1 \").concat(rectX + rectWidth, \" \").concat(rectY + cornerRadius));\n        // Right edge\n        path.push(\"L \".concat(rectX + rectWidth, \" \").concat(rectY + rectHeight - cornerRadius));\n        // Bottom-right corner\n        path.push(\"A \".concat(cornerRadius, \" \").concat(cornerRadius, \" 0 0 1 \").concat(rectX + rectWidth - cornerRadius, \" \").concat(rectY + rectHeight));\n        // Bottom edge\n        path.push(\"L \".concat(rectX + cornerRadius, \" \").concat(rectY + rectHeight));\n        // Bottom-left corner\n        path.push(\"A \".concat(cornerRadius, \" \").concat(cornerRadius, \" 0 0 1 \").concat(rectX, \" \").concat(rectY + rectHeight - cornerRadius));\n        // Left edge\n        path.push(\"L \".concat(rectX, \" \").concat(rectY + cornerRadius));\n        // Top-left corner completion\n        path.push(\"A \".concat(cornerRadius, \" \").concat(cornerRadius, \" 0 0 1 \").concat(rectX + cornerRadius, \" \").concat(rectY));\n      } else {\n        // Simple rectangle without rounded corners\n        path.push(\"M \".concat(rectX, \" \").concat(rectY));\n        path.push(\"L \".concat(rectX + rectWidth, \" \").concat(rectY));\n        path.push(\"L \".concat(rectX + rectWidth, \" \").concat(rectY + rectHeight));\n        path.push(\"L \".concat(rectX, \" \").concat(rectY + rectHeight));\n        path.push('Z');\n      }\n\n      // Add top semicircle\n      path.push(\"M \".concat(-arcRadius, \" \").concat(rectY));\n      path.push(\"A \".concat(arcRadius, \" \").concat(arcRadius, \" 0 0 1 \").concat(arcRadius, \" \").concat(rectY));\n\n      // Add bottom semicircle\n      path.push(\"M \".concat(arcRadius, \" \").concat(rectY + rectHeight));\n      path.push(\"A \".concat(arcRadius, \" \").concat(arcRadius, \" 0 0 1 \").concat(-arcRadius, \" \").concat(rectY + rectHeight));\n      return \"<path \\n            d=\\\"\".concat(path.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SymmetricTotem, \"parameters\", {\n  rectangleHeight: {\n    min: 20,\n    max: 200,\n    \"default\": 100\n  },\n  rectangleWidth: {\n    min: 20,\n    max: 200,\n    \"default\": 120\n  },\n  arcRadius: {\n    min: 10,\n    max: 100,\n    \"default\": 60\n  },\n  cornerRadius: {\n    min: 0,\n    max: 20,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SymmetricTotem);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SymmetricTotem.js?");

/***/ }),

/***/ "./src/shapes/SymmetricalPattern.js":
/*!******************************************!*\
  !*** ./src/shapes/SymmetricalPattern.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SymmetricalPattern = /*#__PURE__*/function (_Shape) {\n  function SymmetricalPattern() {\n    _classCallCheck(this, SymmetricalPattern);\n    return _callSuper(this, SymmetricalPattern, arguments);\n  }\n  _inherits(SymmetricalPattern, _Shape);\n  return _createClass(SymmetricalPattern, [{\n    key: \"generatePoints\",\n    value: function generatePoints() {\n      var points = [[1, 1]];\n      var grid = 2;\n      var maxEdges = Math.min(this.edgesMax, this.edgesAttempts);\n      for (var i = 0; i < maxEdges; i++) {\n        var lastPoint = points[points.length - 1];\n        var _lastPoint = _slicedToArray(lastPoint, 2),\n          lastX = _lastPoint[0],\n          lastY = _lastPoint[1];\n        var validMove = false;\n        var attempts = 0;\n        while (!validMove && attempts < this.edgesAttempts) {\n          var dx = Math.floor(this.random() * 3) - 1;\n          var dy = Math.floor(this.random() * 3) - 1;\n          var newX = lastX + dx;\n          var newY = lastY + dy;\n          if (newX >= 0 && newX <= grid && newY >= 0 && newY <= grid && !(dx === 0 && dy === 0)) {\n            points.push([newX, newY]);\n            validMove = true;\n          }\n          attempts++;\n        }\n        if (!validMove) break;\n      }\n      return points;\n    }\n  }, {\n    key: \"generateQuadrant\",\n    value: function generateQuadrant(points, size) {\n      var _this = this;\n      var step = size / 2;\n      var lines = points.map(function (point, i) {\n        if (i === 0) return '';\n        var prevPoint = points[i - 1];\n        if (!prevPoint || !point) return '';\n        var _prevPoint = _slicedToArray(prevPoint, 2),\n          x1 = _prevPoint[0],\n          y1 = _prevPoint[1];\n        var _point = _slicedToArray(point, 2),\n          x2 = _point[0],\n          y2 = _point[1];\n        return \"<line\\n                x1=\\\"\".concat(-size + x1 * step, \"\\\"\\n                y1=\\\"\").concat(-size + y1 * step, \"\\\"\\n                x2=\\\"\").concat(-size + x2 * step, \"\\\"\\n                y2=\\\"\").concat(-size + y2 * step, \"\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(_this.strokeWidth, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n            />\");\n      });\n      return lines.join('');\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Reset RNG to ensure consistent results with the same seed\n      this.resetRNG();\n      var totalSize = 200;\n      var padding = totalSize * 0.2;\n      var usableSize = (totalSize - padding * 2) / 2;\n      var points = this.generatePoints();\n      var quadrant = this.generateQuadrant(points, usableSize);\n      if (this.symmetry === 'reflect') {\n        return \"\\n                <g>\\n                    \".concat(quadrant, \"\\n                    <g transform=\\\"scale(1, -1)\\\">\").concat(quadrant, \"</g>\\n                    <g transform=\\\"scale(-1, 1)\\\">\").concat(quadrant, \"</g>\\n                    <g transform=\\\"scale(-1, -1)\\\">\").concat(quadrant, \"</g>\\n                </g>\\n            \");\n      } else {\n        return \"\\n                <g>\\n                    \".concat(quadrant, \"\\n                    <g transform=\\\"rotate(90, 0, 0)\\\">\").concat(quadrant, \"</g>\\n                    <g transform=\\\"rotate(180, 0, 0)\\\">\").concat(quadrant, \"</g>\\n                    <g transform=\\\"rotate(270, 0, 0)\\\">\").concat(quadrant, \"</g>\\n                </g>\\n            \");\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(SymmetricalPattern, \"parameters\", {\n  edgesMax: {\n    min: 5,\n    max: 20,\n    \"default\": 12\n  },\n  edgesAttempts: {\n    min: 5,\n    max: 30,\n    \"default\": 25\n  },\n  strokeWidth: {\n    min: 1,\n    max: 5,\n    \"default\": 3\n  },\n  symmetry: {\n    options: ['reflect', 'rotate'],\n    \"default\": 'rotate'\n  }\n  // seed parameter is now inherited from Shape class\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SymmetricalPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/SymmetricalPattern.js?");

/***/ }),

/***/ "./src/shapes/ThreadedShape.js":
/*!*************************************!*\
  !*** ./src/shapes/ThreadedShape.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar ThreadedShape = /*#__PURE__*/function (_Shape) {\n  function ThreadedShape() {\n    _classCallCheck(this, ThreadedShape);\n    return _callSuper(this, ThreadedShape, arguments);\n  }\n  _inherits(ThreadedShape, _Shape);\n  return _createClass(ThreadedShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Create grid of circles\n      var grid = this.createCircleGrid();\n\n      // Default fallback path in case of errors\n      var finalPath = 'M 0,0 L 0,0 Z';\n      try {\n        // Select pins from the grid (subset of circles to be used as wrapping points)\n        var pins = this.selectPins(grid);\n\n        // Set pin order - important for natural thread flow\n        var orderedPins = this.optimizePinSequence(pins);\n\n        // Calculate pin orientation (clockwise/counterclockwise)\n        var orientations = this.determinePinOrientations(orderedPins);\n\n        // Generate the tangent paths between pins\n        var tangentPaths = this.calculateTangentPaths(orderedPins, orientations);\n\n        // Create the final thread path\n        finalPath = this.generateThreadPath(orderedPins, tangentPaths);\n      } catch (error) {\n        console.error('Error generating threaded shape:', error);\n      }\n\n      // Create SVG elements\n      var svg = '';\n\n      // Add the thread path first (beneath the pins)\n      svg += \"<path d=\\\"\".concat(finalPath, \"\\\" fill=\\\"white\\\" stroke=\\\"white\\\" stroke-width=\\\"\").concat(this.strokeWidth, \"\\\" />\");\n\n      // Add the grid circles if showGrid is true\n      if (this.showGrid) {\n        grid.forEach(function (circle) {\n          svg += \"<circle cx=\\\"\".concat(circle.x, \"\\\" cy=\\\"\").concat(circle.y, \"\\\" r=\\\"\").concat(circle.radius, \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"1\\\" />\");\n        });\n      }\n      return svg;\n    }\n  }, {\n    key: \"createCircleGrid\",\n    value: function createCircleGrid() {\n      var grid = [];\n      var rows = Math.floor(this.gridRows);\n      var cols = Math.floor(this.gridCols);\n\n      // Calculate spacing to distribute circles evenly in the viewport\n      var spacing = 200 / Math.max(rows, cols);\n      var offsetX = -((cols - 1) * spacing) / 2;\n      var offsetY = -((rows - 1) * spacing) / 2;\n\n      // Create grid of circles\n      for (var row = 0; row < rows; row++) {\n        for (var col = 0; col < cols; col++) {\n          grid.push({\n            x: offsetX + col * spacing,\n            y: offsetY + row * spacing,\n            radius: this.circleRadius,\n            row: row,\n            col: col\n          });\n        }\n      }\n      return grid;\n    }\n  }, {\n    key: \"selectPins\",\n    value: function selectPins(grid) {\n      // For a better shape, we might want to select pins to create a more interesting boundary\n      // This is where more sophisticated pin selection algorithms could be implemented\n      var pinCount = Math.min(Math.floor(this.pinCount), grid.length);\n\n      // For now, let's select random pins, but ensure we get a mix from different areas\n      var selectedPins = [];\n      var availablePins = _toConsumableArray(grid);\n\n      // Create a uniform random distribution by shuffling\n      for (var i = availablePins.length - 1; i > 0; i--) {\n        var j = Math.floor(this.random() * (i + 1));\n        var _ref = [availablePins[j], availablePins[i]];\n        availablePins[i] = _ref[0];\n        availablePins[j] = _ref[1];\n      }\n\n      // Take the first pinCount pins from the shuffled array\n      for (var _i = 0; _i < pinCount; _i++) {\n        if (availablePins.length > 0) {\n          var pin = availablePins.pop();\n          selectedPins.push(pin);\n        }\n      }\n      return selectedPins;\n    }\n  }, {\n    key: \"optimizePinSequence\",\n    value: function optimizePinSequence(pins) {\n      if (pins.length <= 3) return pins;\n\n      // For better winding patterns, we want to order pins in a way that creates\n      // a roughly convex hull or boundary around the shape\n      // This is a simplified approach - more advanced algorithms could be used\n\n      // Start with the leftmost pin\n      var leftmostPin = pins.reduce(function (current, pin) {\n        return pin.x < current.x ? pin : current;\n      });\n\n      // Order remaining pins by angle from the center point\n      var center = {\n        x: pins.reduce(function (sum, pin) {\n          return sum + pin.x;\n        }, 0) / pins.length,\n        y: pins.reduce(function (sum, pin) {\n          return sum + pin.y;\n        }, 0) / pins.length\n      };\n\n      // Sort pins by angle around the center\n      var orderedPins = _toConsumableArray(pins).sort(function (a, b) {\n        var angleA = Math.atan2(a.y - center.y, a.x - center.x);\n        var angleB = Math.atan2(b.y - center.y, b.x - center.x);\n        return angleA - angleB;\n      });\n      return orderedPins;\n    }\n  }, {\n    key: \"determinePinOrientations\",\n    value: function determinePinOrientations(pins) {\n      // For each pin, determine if thread should go clockwise or counterclockwise\n      var orientations = [];\n      for (var i = 0; i < pins.length; i++) {\n        var prev = pins[(i - 1 + pins.length) % pins.length];\n        var current = pins[i];\n        var next = pins[(i + 1) % pins.length];\n\n        // Calculate determinant to determine orientation\n        var det = (current.x - prev.x) * (next.y - current.y) - (current.y - prev.y) * (next.x - current.x);\n\n        // In browser coordinates (y points down), positive determinant means clockwise\n        orientations.push(det > 0 ? 'clockwise' : 'counterclockwise');\n      }\n      return orientations;\n    }\n  }, {\n    key: \"calculateTangentPaths\",\n    value: function calculateTangentPaths(pins, orientations) {\n      var tangentPaths = [];\n      for (var i = 0; i < pins.length; i++) {\n        var currentPin = pins[i];\n        var nextPin = pins[(i + 1) % pins.length];\n        var currentOrientation = orientations[i];\n        var nextOrientation = orientations[(i + 1) % pins.length];\n\n        // Calculate the tangent points between these pins\n        var tangentPoints = this.calculateTangentPoints(currentPin, nextPin, currentOrientation, nextOrientation);\n\n        // Create the path segment for this tangent\n        tangentPaths.push({\n          startPin: currentPin,\n          endPin: nextPin,\n          startPoint: tangentPoints.start,\n          endPoint: tangentPoints.end\n        });\n      }\n      return tangentPaths;\n    }\n  }, {\n    key: \"calculateTangentPoints\",\n    value: function calculateTangentPoints(pin1, pin2, orientation1, orientation2) {\n      var c1 = {\n        x: pin1.x,\n        y: pin1.y\n      };\n      var c2 = {\n        x: pin2.x,\n        y: pin2.y\n      };\n      var r1 = pin1.radius;\n      var r2 = pin2.radius;\n\n      // Calculate vector from c1 to c2\n      var dx = c2.x - c1.x;\n      var dy = c2.y - c1.y;\n      var distance = Math.sqrt(dx * dx + dy * dy);\n\n      // If circles are too close or overlapping, adjust the calculation\n      if (distance < r1 + r2) {\n        // Simple fallback for overlapping circles\n        var angle = Math.atan2(dy, dx);\n        return {\n          start: {\n            x: c1.x + Math.cos(angle) * r1,\n            y: c1.y + Math.sin(angle) * r1\n          },\n          end: {\n            x: c2.x - Math.cos(angle) * r2,\n            y: c2.y - Math.sin(angle) * r2\n          }\n        };\n      }\n\n      // Normalized direction vector\n      var ux = dx / distance;\n      var uy = dy / distance;\n\n      // Perpendicular vectors (90 rotations of the unit vector)\n      var perpCW = {\n        x: uy,\n        y: -ux\n      }; // Clockwise rotation\n      var perpCCW = {\n        x: -uy,\n        y: ux\n      }; // Counter-clockwise rotation\n\n      // Decide which tangent to use based on orientations\n      var startPerp, endPerp;\n\n      // If both pins have the same orientation, use the same tangent type\n      if (orientation1 === orientation2) {\n        startPerp = orientation1 === 'clockwise' ? perpCW : perpCCW;\n        endPerp = orientation2 === 'clockwise' ? perpCW : perpCCW;\n      } else {\n        // If orientations differ, we need to decide which tangent to use\n        // This is a simplification - a more sophisticated algorithm could make better choices\n        startPerp = orientation1 === 'clockwise' ? perpCW : perpCCW;\n        endPerp = orientation2 === 'clockwise' ? perpCW : perpCCW;\n      }\n\n      // Calculate tangent points\n      return {\n        start: {\n          x: c1.x + startPerp.x * r1,\n          y: c1.y + startPerp.y * r1\n        },\n        end: {\n          x: c2.x + endPerp.x * r2,\n          y: c2.y + endPerp.y * r2\n        }\n      };\n    }\n  }, {\n    key: \"generateThreadPath\",\n    value: function generateThreadPath(pins, tangentPaths) {\n      if (pins.length < 3 || tangentPaths.length < 3) {\n        return 'M 0,0 L 0,0 Z'; // Empty or invalid path\n      }\n\n      // Build the path data string\n      var pathData = '';\n\n      // Start at the first tangent point\n      var firstTangent = tangentPaths[0];\n      pathData = \"M \".concat(firstTangent.startPoint.x, \",\").concat(firstTangent.startPoint.y);\n\n      // For each pin pair, add the tangent line and the arc around the end pin\n      for (var i = 0; i < tangentPaths.length; i++) {\n        var currentTangent = tangentPaths[i];\n        var nextTangent = tangentPaths[(i + 1) % tangentPaths.length];\n\n        // Add tangent line from start to end point\n        pathData += \" L \".concat(currentTangent.endPoint.x, \",\").concat(currentTangent.endPoint.y);\n\n        // Add arc around the end pin to the start of the next tangent\n        pathData += this.createArcSegment(currentTangent.endPoint, nextTangent.startPoint, currentTangent.endPin);\n      }\n\n      // Close the path\n      pathData += ' Z';\n      return pathData;\n    }\n  }, {\n    key: \"createArcSegment\",\n    value: function createArcSegment(from, to, pin) {\n      // Calculate the center of the pin\n      var center = {\n        x: pin.x,\n        y: pin.y\n      };\n      var radius = pin.radius;\n\n      // Calculate angles from center to points\n      var angleFrom = Math.atan2(from.y - center.y, from.x - center.x);\n      var angleTo = Math.atan2(to.y - center.y, to.x - center.x);\n\n      // Calculate the angle difference\n      var angleDiff = angleTo - angleFrom;\n\n      // Normalize angle to range [-PI, PI]\n      if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;\n      if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;\n\n      // Determine flags for SVG arc command\n      // largeArcFlag: 0 for arc <= 180 degrees, 1 for arc > 180 degrees\n      // sweepFlag: 0 for counter-clockwise, 1 for clockwise\n      var largeArcFlag = Math.abs(angleDiff) > Math.PI ? 1 : 0;\n      var sweepFlag = angleDiff > 0 ? 1 : 0; // In SVG, positive angle is clockwise\n\n      // Create arc command\n      return \" A \".concat(radius, \" \").concat(radius, \" 0 \").concat(largeArcFlag, \" \").concat(sweepFlag, \" \").concat(to.x, \" \").concat(to.y);\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(ThreadedShape, \"parameters\", {\n  gridRows: {\n    min: 2,\n    max: 6,\n    \"default\": 4\n  },\n  gridCols: {\n    min: 2,\n    max: 6,\n    \"default\": 4\n  },\n  circleRadius: {\n    min: 0,\n    max: 10,\n    \"default\": 10\n  },\n  pinCount: {\n    min: 3,\n    max: 24,\n    \"default\": 18\n  },\n  threadWidth: {\n    min: 1,\n    max: 20,\n    \"default\": 8\n  },\n  showGrid: {\n    \"default\": false\n  },\n  strokeWidth: {\n    min: 0,\n    max: 5,\n    \"default\": 1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ThreadedShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/ThreadedShape.js?");

/***/ }),

/***/ "./src/shapes/Tornado.js":
/*!*******************************!*\
  !*** ./src/shapes/Tornado.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar Tornado = /*#__PURE__*/function (_Shape) {\n  function Tornado() {\n    _classCallCheck(this, Tornado);\n    return _callSuper(this, Tornado, arguments);\n  }\n  _inherits(Tornado, _Shape);\n  return _createClass(Tornado, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.9;\n\n      // Scale parameters\n      var height = this.height * scale;\n      var topWidth = this.topWidth * scale;\n      var bottomWidth = this.bottomWidth * scale;\n      var turbulence = this.turbulence * scale;\n\n      // Generate points with higher resolution for smoother curves\n      var controlPoints = this.segments * 4;\n      var leftPoints = [];\n      var rightPoints = [];\n\n      // Start with flat top edge\n      var topY = -height / 2;\n      leftPoints.push({\n        x: -topWidth / 2,\n        y: topY\n      });\n      rightPoints.push({\n        x: topWidth / 2,\n        y: topY\n      });\n\n      // Generate middle points with turbulence\n      for (var i = 1; i < controlPoints; i++) {\n        var progress = i / controlPoints;\n\n        // Smooth width interpolation using cosine\n        var widthProgress = (1 - Math.cos(progress * Math.PI)) / 2;\n        var width = topWidth + (bottomWidth - topWidth) * widthProgress;\n\n        // Create smooth wave effect using multiple sine waves\n        var baseWave = Math.sin(progress * this.twistCount * 2 * Math.PI);\n        var secondaryWave = Math.sin(progress * (this.twistCount + 1) * 2 * Math.PI) * 0.3;\n        var combinedWave = (baseWave + secondaryWave) * turbulence;\n\n        // Gradually reduce displacement near endpoints\n        var endpointDamping = Math.sin(progress * Math.PI);\n        var displacement = combinedWave * endpointDamping;\n\n        // Calculate points with smooth displacement\n        var y = -height / 2 + height * progress;\n        var leftX = -width / 2 + displacement;\n        var rightX = width / 2 + displacement;\n        leftPoints.push({\n          x: leftX,\n          y: y\n        });\n        rightPoints.push({\n          x: rightX,\n          y: y\n        });\n      }\n\n      // End with flat bottom edge\n      var bottomY = height / 2;\n      leftPoints.push({\n        x: -bottomWidth / 2,\n        y: bottomY\n      });\n      rightPoints.push({\n        x: bottomWidth / 2,\n        y: bottomY\n      });\n\n      // Build SVG path\n      var pathData = [];\n\n      // Start path at first left point\n      pathData.push(\"M \".concat(leftPoints[0].x, \" \").concat(leftPoints[0].y));\n\n      // Draw left side with quadratic curves\n      for (var _i = 1; _i < leftPoints.length - 2; _i++) {\n        var p0 = leftPoints[_i];\n        var p1 = leftPoints[_i + 1];\n        var midPoint = {\n          x: (p0.x + p1.x) / 2,\n          y: (p0.y + p1.y) / 2\n        };\n        pathData.push(\"Q \".concat(p0.x, \" \").concat(p0.y, \" \").concat(midPoint.x, \" \").concat(midPoint.y));\n      }\n\n      // Connect to bottom edge\n      pathData.push(\"L \".concat(leftPoints[leftPoints.length - 1].x, \" \").concat(bottomY));\n      pathData.push(\"L \".concat(rightPoints[rightPoints.length - 1].x, \" \").concat(bottomY));\n\n      // Draw right side with quadratic curves\n      for (var _i2 = rightPoints.length - 2; _i2 > 1; _i2--) {\n        var _p = rightPoints[_i2];\n        var _p2 = rightPoints[_i2 - 1];\n        var _midPoint = {\n          x: (_p.x + _p2.x) / 2,\n          y: (_p.y + _p2.y) / 2\n        };\n        pathData.push(\"Q \".concat(_p.x, \" \").concat(_p.y, \" \").concat(_midPoint.x, \" \").concat(_midPoint.y));\n      }\n\n      // Connect back to top edge and close\n      pathData.push(\"L \".concat(rightPoints[0].x, \" \").concat(topY));\n      pathData.push(\"L \".concat(leftPoints[0].x, \" \").concat(topY));\n      pathData.push('Z');\n      return \"<path \\n            d=\\\"\".concat(pathData.join(' '), \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(Tornado, \"parameters\", {\n  height: {\n    min: 100,\n    max: 300,\n    \"default\": 200\n  },\n  topWidth: {\n    min: 20,\n    max: 100,\n    \"default\": 40\n  },\n  bottomWidth: {\n    min: 50,\n    max: 150,\n    \"default\": 100\n  },\n  twistCount: {\n    min: 1,\n    max: 6,\n    \"default\": 3\n  },\n  segments: {\n    min: 8,\n    max: 24,\n    \"default\": 16\n  },\n  turbulence: {\n    min: 0,\n    max: 30,\n    \"default\": 15\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tornado);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Tornado.js?");

/***/ }),

/***/ "./src/shapes/TorusShape.js":
/*!**********************************!*\
  !*** ./src/shapes/TorusShape.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar TorusShape = /*#__PURE__*/function (_Shape) {\n  function TorusShape() {\n    _classCallCheck(this, TorusShape);\n    return _callSuper(this, TorusShape, arguments);\n  }\n  _inherits(TorusShape, _Shape);\n  return _createClass(TorusShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Convert rotation values from degrees to radians\n      var rotX = this.rotationX * Math.PI / 180;\n      var rotY = this.rotationY * Math.PI / 180;\n\n      // Ensure parameters are valid integers to prevent interpolation issues\n      var segments = Math.max(3, Math.round(this.segments));\n      var rings = Math.max(3, Math.round(this.rings));\n      var layers = Math.max(1, Math.round(this.layers));\n      var renderMode = Math.round(this.renderMode) % 2; // Ensure 0 or 1\n\n      // Store all lines for depth sorting\n      var lines = [];\n\n      // Calculate all layers\n      for (var layer = 0; layer < layers; layer++) {\n        var currentRadius = this.minorRadius - layer * this.layerSpacing;\n        if (currentRadius <= 0) continue;\n\n        // Generate torus points for current layer\n        var points = [];\n\n        // Generate points for each segment around major radius\n        for (var i = 0; i <= segments; i++) {\n          var theta = i * 2 * Math.PI / segments;\n          var cosTheta = Math.cos(theta);\n          var sinTheta = Math.sin(theta);\n\n          // Generate points for each ring around minor radius\n          for (var j = 0; j <= rings; j++) {\n            var phi = j * 2 * Math.PI / rings;\n            var cosPhi = Math.cos(phi);\n            var sinPhi = Math.sin(phi);\n\n            // Calculate 3D coordinates of point on torus\n            var x = (this.majorRadius + currentRadius * cosPhi) * cosTheta;\n            var y = (this.majorRadius + currentRadius * cosPhi) * sinTheta;\n            var z = currentRadius * sinPhi;\n\n            // Store the 3D point\n            points.push({\n              x: x,\n              y: y,\n              z: z\n            });\n          }\n        }\n\n        // Create the wireframe lines based on the render mode\n        for (var _i = 0; _i < segments; _i++) {\n          for (var _j = 0; _j < rings; _j++) {\n            // Calculate indices with bounds checking\n            var ringStep = rings + 1;\n            var p1Index = _i * ringStep + _j;\n            var p2Index = _i * ringStep + (_j + 1);\n            var p3Index = (_i + 1) % segments * ringStep + _j;\n\n            // Safely get points (with bounds checking)\n            var p1 = points[p1Index] || {\n              x: 0,\n              y: 0,\n              z: 0\n            };\n            var p2 = points[p2Index] || {\n              x: 0,\n              y: 0,\n              z: 0\n            };\n            var p3 = points[p3Index] || {\n              x: 0,\n              y: 0,\n              z: 0\n            };\n            if (renderMode === 0) {\n              // Segments only (around major radius)\n              lines.push(this.createLine(p1, p3, rotX, rotY));\n            } else {\n              // Rings only (around minor radius)\n              lines.push(this.createLine(p1, p2, rotX, rotY));\n            }\n          }\n        }\n      }\n\n      // Sort lines by z-depth for proper rendering (back to front)\n      lines.sort(function (a, b) {\n        return b.z - a.z;\n      });\n\n      // Generate SVG elements from sorted lines\n      var elements = [];\n      for (var _i2 = 0, _lines = lines; _i2 < _lines.length; _i2++) {\n        var line = _lines[_i2];\n        elements.push(\"<line \\n        x1=\\\"\".concat(line.x1, \"\\\" \\n        y1=\\\"\").concat(line.y1, \"\\\" \\n        x2=\\\"\").concat(line.x2, \"\\\" \\n        y2=\\\"\").concat(line.y2, \"\\\" \\n        stroke=\\\"white\\\" \\n        stroke-width=\\\"\").concat(this.thickness, \"\\\" \\n      />\"));\n      }\n      return elements.join('');\n    }\n  }, {\n    key: \"createLine\",\n    value: function createLine(p1, p2, rotX, rotY) {\n      // Apply 3D rotation to both points\n      var p1Rotated = this.rotate3D(p1.x, p1.y, p1.z, rotX, rotY);\n      var p2Rotated = this.rotate3D(p2.x, p2.y, p2.z, rotX, rotY);\n\n      // Calculate average z for depth sorting\n      var avgZ = (p1Rotated.z + p2Rotated.z) / 2;\n      return {\n        x1: p1Rotated.x,\n        y1: p1Rotated.y,\n        x2: p2Rotated.x,\n        y2: p2Rotated.y,\n        z: avgZ\n      };\n    }\n  }, {\n    key: \"rotate3D\",\n    value: function rotate3D(x, y, z, rotX, rotY) {\n      // Step 1: Rotate around X axis\n      var y1 = y * Math.cos(rotX) - z * Math.sin(rotX);\n      var z1 = y * Math.sin(rotX) + z * Math.cos(rotX);\n\n      // Step 2: Rotate around Y axis\n      var x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);\n      var z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);\n      return {\n        x: x2,\n        y: y1,\n        z: z2\n      };\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TorusShape, \"parameters\", {\n  majorRadius: {\n    min: 50,\n    max: 50,\n    \"default\": 50\n  },\n  minorRadius: {\n    min: 10,\n    max: 50,\n    \"default\": 50\n  },\n  segments: {\n    min: 3,\n    max: 16,\n    \"default\": 16\n  },\n  rings: {\n    min: 3,\n    max: 64,\n    \"default\": 32\n  },\n  layers: {\n    min: 1,\n    max: 10,\n    \"default\": 1\n  },\n  layerSpacing: {\n    min: 1,\n    max: 20,\n    \"default\": 0\n  },\n  renderMode: {\n    min: 0,\n    max: 1,\n    \"default\": 1\n  },\n  // 0 = segments only, 1 = rings only\n  rotationX: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  rotationY: {\n    min: -180,\n    max: 180,\n    \"default\": 45\n  },\n  thickness: {\n    min: 0.5,\n    max: 5,\n    \"default\": 2\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TorusShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TorusShape.js?");

/***/ }),

/***/ "./src/shapes/TriangleRays.js":
/*!************************************!*\
  !*** ./src/shapes/TriangleRays.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar TriangleRaysShape = /*#__PURE__*/function (_Shape) {\n  function TriangleRaysShape() {\n    _classCallCheck(this, TriangleRaysShape);\n    return _callSuper(this, TriangleRaysShape, arguments);\n  }\n  _inherits(TriangleRaysShape, _Shape);\n  return _createClass(TriangleRaysShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var triangles = [];\n\n      // Calculate basic dimensions\n      var topPoint = {\n        x: 0,\n        y: -this.height / 2\n      };\n\n      // Calculate gaps and ray widths\n      var gap = Math.max(2, this.thickness * 0.2);\n      var totalGapSpace = gap * (this.rayCount - 1);\n      var totalRayWidth = this.baseWidth - totalGapSpace;\n      var rayWidth = totalRayWidth / this.rayCount;\n\n      // Calculate starting point to center the pattern\n      var patternTotalWidth = totalRayWidth + totalGapSpace;\n      var startX = -patternTotalWidth / 2;\n\n      // Generate triangular rays\n      for (var i = 0; i < this.rayCount; i++) {\n        // Calculate base points from centered start position\n        var leftX = startX + i * (rayWidth + gap);\n        var rightX = leftX + rayWidth;\n\n        // Apply tilt to the base points\n        var tiltRad = this.tilt * Math.PI / 180;\n        var centerX = (leftX + rightX) / 2;\n        var tiltOffsetLeft = Math.sin(tiltRad) * centerX;\n        var tiltOffsetRight = Math.sin(tiltRad) * centerX;\n        var leftBaseX = leftX + tiltOffsetLeft;\n        var rightBaseX = rightX + tiltOffsetRight;\n\n        // Create triangular path\n        triangles.push(\"<path \\n                d=\\\"M \".concat(topPoint.x, \" \").concat(topPoint.y, \" \\n                   L \").concat(leftBaseX, \" \").concat(-topPoint.y, \" \\n                   L \").concat(rightBaseX, \" \").concat(-topPoint.y, \" Z\\\"\\n                fill=\\\"white\\\"\\n            />\"));\n      }\n      return triangles.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TriangleRaysShape, \"parameters\", {\n  rayCount: {\n    min: 3,\n    max: 12,\n    \"default\": 4\n  },\n  height: {\n    min: 20,\n    max: 200,\n    \"default\": 118\n  },\n  baseWidth: {\n    min: 20,\n    max: 200,\n    \"default\": 133\n  },\n  tilt: {\n    min: 0,\n    max: 45,\n    \"default\": 10\n  },\n  thickness: {\n    min: 1,\n    max: 100,\n    \"default\": 30\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TriangleRaysShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TriangleRays.js?");

/***/ }),

/***/ "./src/shapes/TriangularPortal.js":
/*!****************************************!*\
  !*** ./src/shapes/TriangularPortal.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar TriangularPortal = /*#__PURE__*/function (_Shape) {\n  function TriangularPortal() {\n    _classCallCheck(this, TriangularPortal);\n    return _callSuper(this, TriangularPortal, arguments);\n  }\n  _inherits(TriangularPortal, _Shape);\n  return _createClass(TriangularPortal, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Calculate center point (origin in our SVG coordinate system)\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Scale values to fit SVG viewBox (-200 -200 400 400)\n      var scale = 1.0;\n      var height = this.height * scale;\n      var baseWidth = this.baseWidth * scale;\n      var innerScale = this.innerScale;\n\n      // Calculate points for outer triangle\n      var topPoint = {\n        x: center.x,\n        y: center.y - height / 2\n      };\n      var bottomLeft = {\n        x: center.x - baseWidth / 2,\n        y: center.y + height / 2\n      };\n      var bottomRight = {\n        x: center.x + baseWidth / 2,\n        y: center.y + height / 2\n      };\n\n      // Calculate points for inner triangle\n      var innerHeight = height * innerScale;\n      var innerBaseWidth = baseWidth * (innerScale + 0.1); // Slightly wider base\n      var verticalOffset = (height - innerHeight) * 0.9;\n      var innerTopPoint = {\n        x: center.x,\n        y: center.y - height / 2 + verticalOffset\n      };\n      var innerBottomLeft = {\n        x: center.x - innerBaseWidth / 2,\n        y: center.y + height / 2\n      };\n      var innerBottomRight = {\n        x: center.x + innerBaseWidth / 2,\n        y: center.y + height / 2\n      };\n\n      // Create SVG path for both triangles\n      // Using fill-rule=\"evenodd\" to create the cutout effect\n      var pathData = \"\\n            M \".concat(topPoint.x, \" \").concat(topPoint.y, \"\\n            L \").concat(bottomLeft.x, \" \").concat(bottomLeft.y, \"\\n            L \").concat(bottomRight.x, \" \").concat(bottomRight.y, \"\\n            Z\\n            M \").concat(innerTopPoint.x, \" \").concat(innerTopPoint.y, \"\\n            L \").concat(innerBottomLeft.x, \" \").concat(innerBottomLeft.y, \"\\n            L \").concat(innerBottomRight.x, \" \").concat(innerBottomRight.y, \"\\n            Z\\n        \");\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n            fill-rule=\\\"evenodd\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"2\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TriangularPortal, \"parameters\", {\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  baseWidth: {\n    min: 20,\n    max: 200,\n    \"default\": 120\n  },\n  innerScale: {\n    min: 0.1,\n    max: 0.9,\n    \"default\": 0.4\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TriangularPortal);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TriangularPortal.js?");

/***/ }),

/***/ "./src/shapes/TribalArrow.js":
/*!***********************************!*\
  !*** ./src/shapes/TribalArrow.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar TribalArrow = /*#__PURE__*/function (_Shape) {\n  function TribalArrow() {\n    _classCallCheck(this, TribalArrow);\n    return _callSuper(this, TribalArrow, arguments);\n  }\n  _inherits(TribalArrow, _Shape);\n  return _createClass(TribalArrow, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Center point (origin in SVG coordinate system)\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Scale values to fit SVG viewBox (-200 -200 400 400)\n      var scale = 1.2;\n      var width = this.width * scale;\n      var height = this.height * scale;\n      var pointDepth = this.pointDepth;\n      var wingSpread = this.wingSpread;\n\n      // Calculate key points\n      var top = center.y - height / 2;\n      var bottom = center.y + height / 2;\n      var left = center.x - width / 2;\n      var right = center.x + width / 2;\n\n      // Build path data\n      var pathData = [// Start at top center\n      \"M \".concat(center.x, \" \").concat(top), // Right side\n      \"L \".concat(right, \" \").concat(top + height * pointDepth), \"L \".concat(center.x + width * wingSpread / 2, \" \").concat(center.y), \"L \".concat(right, \" \").concat(bottom - height * pointDepth), \"L \".concat(center.x, \" \").concat(bottom), // Left side\n      \"L \".concat(left, \" \").concat(bottom - height * pointDepth), \"L \".concat(center.x - width * wingSpread / 2, \" \").concat(center.y), \"L \".concat(left, \" \").concat(top + height * pointDepth),\n      // Close path\n      'Z'].join(' ');\n      return \"<path \\n            d=\\\"\".concat(pathData, \"\\\"\\n            fill=\\\"white\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"2\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TribalArrow, \"parameters\", {\n  width: {\n    min: 50,\n    max: 200,\n    \"default\": 100\n  },\n  height: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  pointDepth: {\n    min: 0.1,\n    max: 0.5,\n    \"default\": 0.3\n  },\n  wingSpread: {\n    min: 0.3,\n    max: 1.0,\n    \"default\": 0.7\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TribalArrow);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TribalArrow.js?");

/***/ }),

/***/ "./src/shapes/TribalPattern.js":
/*!*************************************!*\
  !*** ./src/shapes/TribalPattern.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar LadderShape = /*#__PURE__*/function (_Shape) {\n  function LadderShape() {\n    _classCallCheck(this, LadderShape);\n    return _callSuper(this, LadderShape, arguments);\n  }\n  _inherits(LadderShape, _Shape);\n  return _createClass(LadderShape, [{\n    key: \"validateOptions\",\n    value: function validateOptions(options) {\n      var validated = _objectSpread({}, options);\n\n      // Ensure verticalWidth is never larger than horizontalWidth\n      if ('verticalWidth' in options && 'horizontalWidth' in options) {\n        if (options.verticalWidth >= options.horizontalWidth) {\n          validated.verticalWidth = Math.min(options.verticalWidth, options.horizontalWidth * 0.5);\n        }\n      } else if ('verticalWidth' in options) {\n        validated.verticalWidth = Math.min(options.verticalWidth, this.horizontalWidth * 0.5);\n      }\n\n      // Ensure spacing is proportional to thickness\n      if ('thickness' in options && 'spacing' in options) {\n        validated.spacing = Math.max(options.spacing, options.thickness * 1.2);\n      } else if ('thickness' in options) {\n        validated.spacing = Math.max(this.spacing, options.thickness * 1.2);\n      }\n      return validated;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var parts = [];\n\n      // Calculate total height to center the shape\n      var totalHeight = (this.segments - 1) * this.spacing;\n      var startY = -totalHeight / 2;\n\n      // Add vertical bar\n      var verticalBar = \"<rect \\n            x=\\\"\".concat(-this.verticalWidth / 2, \"\\\"\\n            y=\\\"\").concat(startY - this.thickness / 2, \"\\\"\\n            width=\\\"\").concat(this.verticalWidth, \"\\\"\\n            height=\\\"\").concat(totalHeight + this.thickness, \"\\\"\\n            fill=\\\"white\\\"\\n        />\");\n      parts.push(verticalBar);\n\n      // Add horizontal segments\n      for (var i = 0; i < this.segments; i++) {\n        var y = startY + i * this.spacing;\n        var horizontalSegment = \"<rect \\n                x=\\\"\".concat(-this.horizontalWidth / 2, \"\\\"\\n                y=\\\"\").concat(y - this.thickness / 2, \"\\\"\\n                width=\\\"\").concat(this.horizontalWidth, \"\\\"\\n                height=\\\"\").concat(this.thickness, \"\\\"\\n                fill=\\\"white\\\"\\n            />\");\n        parts.push(horizontalSegment);\n      }\n      return parts.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(LadderShape, \"parameters\", {\n  segments: {\n    min: 2,\n    max: 8,\n    \"default\": 5\n  },\n  verticalWidth: {\n    min: 20,\n    max: 60,\n    \"default\": 40\n  },\n  // Narrower range to ensure good proportions\n  horizontalWidth: {\n    min: 60,\n    max: 200,\n    \"default\": 135\n  },\n  // Must be larger than verticalWidth\n  thickness: {\n    min: 10,\n    max: 50,\n    \"default\": 20\n  },\n  // Increased minimum to avoid thin lines\n  spacing: {\n    min: 30,\n    max: 80,\n    \"default\": 40\n  } // Relative to thickness for good spacing\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LadderShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TribalPattern.js?");

/***/ }),

/***/ "./src/shapes/TripleRoundedShape.js":
/*!******************************************!*\
  !*** ./src/shapes/TripleRoundedShape.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar TripleRoundedShape = /*#__PURE__*/function (_Shape) {\n  function TripleRoundedShape() {\n    _classCallCheck(this, TripleRoundedShape);\n    return _callSuper(this, TripleRoundedShape, arguments);\n  }\n  _inherits(TripleRoundedShape, _Shape);\n  return _createClass(TripleRoundedShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var scale = 0.8;\n      var segments = Math.round(this.segments);\n      var cornerRadius = this.cornerRadius * scale;\n      var spacing = this.spacing * scale;\n      var aspectRatio = this.aspectRatio;\n\n      // Calculate available space in the 400x400 viewBox\n      var totalWidth = 200; // Leave some margin\n      var adjustedWidth = totalWidth - spacing * (segments - 1);\n      var segmentWidth = adjustedWidth / segments;\n      var segmentHeight = segmentWidth * aspectRatio;\n\n      // Generate rectangles\n      var rects = [];\n      for (var i = 0; i < segments; i++) {\n        var xOffset = -totalWidth / 2 + (segmentWidth + spacing) * i;\n        var yOffset = -segmentHeight / 2;\n        rects.push(\"<rect \\n                x=\\\"\".concat(xOffset, \"\\\"\\n                y=\\\"\").concat(yOffset, \"\\\"\\n                width=\\\"\").concat(segmentWidth, \"\\\"\\n                height=\\\"\").concat(segmentHeight, \"\\\"\\n                rx=\\\"\").concat(cornerRadius, \"\\\"\\n                ry=\\\"\").concat(cornerRadius, \"\\\"\\n                fill=\\\"white\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"2\\\"\\n            />\"));\n      }\n      return rects.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TripleRoundedShape, \"parameters\", {\n  segments: {\n    min: 2,\n    max: 5,\n    \"default\": 3\n  },\n  cornerRadius: {\n    min: 20,\n    max: 100,\n    \"default\": 60\n  },\n  spacing: {\n    min: -20,\n    max: 20,\n    \"default\": -5\n  },\n  aspectRatio: {\n    min: 0.5,\n    max: 2.0,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TripleRoundedShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TripleRoundedShape.js?");

/***/ }),

/***/ "./src/shapes/TruchetPattern.js":
/*!**************************************!*\
  !*** ./src/shapes/TruchetPattern.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar TruchetPattern = /*#__PURE__*/function (_Shape) {\n  function TruchetPattern() {\n    _classCallCheck(this, TruchetPattern);\n    return _callSuper(this, TruchetPattern, arguments);\n  }\n  _inherits(TruchetPattern, _Shape);\n  return _createClass(TruchetPattern, [{\n    key: \"adaptSize\",\n    value:\n    // Determine appropriate tile size to fit within 80% of 400x400 viewport\n    function adaptSize() {\n      var maxDimension = 400 * 0.9;\n      var calculatedTileSize = maxDimension / this.gridSize;\n      this.tileSize = Math.min(this.tileSize, calculatedTileSize);\n    }\n\n    // Deterministic pseudorandom number generator\n  }, {\n    key: \"getPseudoRandom\",\n    value: function getPseudoRandom(x, y) {\n      var value = Math.sin(x * 12.9898 + y * 78.233 + this.seed) * 43758.5453;\n      return value - Math.floor(value);\n    }\n  }, {\n    key: \"createNoiseField\",\n    value: function createNoiseField() {\n      var _this = this;\n      // Create deterministic grid based on coordinates\n      this.grid = Array(this.gridSize).fill().map(function (_, y) {\n        return Array(_this.gridSize).fill().map(function (_, x) {\n          return _this.getPseudoRandom(x, y);\n        });\n      });\n\n      // Apply flow smoothing\n      var smoothedGrid = Array(this.gridSize).fill().map(function () {\n        return Array(_this.gridSize).fill(0);\n      });\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          var avg = this.grid[y][x];\n          var count = 1;\n\n          // Calculate average of neighboring cells\n          for (var dy = -1; dy <= 1; dy++) {\n            for (var dx = -1; dx <= 1; dx++) {\n              if (dx === 0 && dy === 0) continue;\n              var nx = x + dx;\n              var ny = y + dy;\n              if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize) {\n                avg += this.grid[ny][nx];\n                count++;\n              }\n            }\n          }\n\n          // Apply flow intensity\n          avg /= count;\n          smoothedGrid[y][x] = avg * this.flowIntensity + this.grid[y][x] * (1 - this.flowIntensity);\n\n          // Apply contrast\n          if (this.contrast > 0) {\n            smoothedGrid[y][x] = Math.pow(smoothedGrid[y][x], 1 + this.contrast * 2);\n          }\n        }\n      }\n      this.grid = smoothedGrid;\n    }\n  }, {\n    key: \"getRotation\",\n    value: function getRotation(x, y) {\n      var noiseValue = this.grid[y][x];\n      var baseRotation = Math.floor(noiseValue * 4) * 90;\n\n      // Apply pattern balance deterministically\n      var balanceValue = this.getPseudoRandom(x + 100, y + 100);\n      if (balanceValue > this.patternBalance) {\n        var rotIndex = Math.floor(this.getPseudoRandom(x + 200, y + 200) * 4);\n        return this.patterns[rotIndex];\n      }\n      return baseRotation;\n    }\n  }, {\n    key: \"createTile\",\n    value: function createTile(rotation, x, y) {\n      // Calculate position within grid\n      var xPos = x * this.tileSize;\n      var yPos = y * this.tileSize;\n\n      // Create transform for tile rotation\n      var transform = \"translate(\".concat(xPos, \",\").concat(yPos, \") rotate(\").concat(rotation, \", \").concat(this.tileSize / 2, \", \").concat(this.tileSize / 2, \")\");\n\n      // Create triangular tile with white fill\n      return \"<g transform=\\\"\".concat(transform, \"\\\">\\n            <path d=\\\"M 0 0 L \").concat(this.tileSize, \" 0 L 0 \").concat(this.tileSize, \" Z\\\" \\n                  fill=\\\"white\\\"\\n                  stroke=\\\"none\\\" />\\n        </g>\");\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Convert percentage values to decimals\n      this.flowIntensity = this.flowIntensity / 100;\n      this.patternBalance = this.patternBalance / 100;\n      this.contrast = this.contrast / 100;\n\n      // Initialize pattern rotations\n      this.patterns = [0, 90, 180, 270];\n\n      // Generate a stable seed for the pattern\n      this.seed = 12345;\n\n      // Adaptive sizing\n      this.adaptSize();\n      // Generate noise field for pattern\n      this.createNoiseField();\n\n      // Adaptive sizing and centering\n      this.adaptSize();\n      var totalWidth = this.gridSize * this.tileSize;\n      var offset = -totalWidth / 2;\n\n      // Create container group with centering transform\n      var shapes = [\"<g transform=\\\"translate(\".concat(offset, \",\").concat(offset, \")\\\">\")];\n\n      // Generate all tiles\n      for (var y = 0; y < this.gridSize; y++) {\n        for (var x = 0; x < this.gridSize; x++) {\n          var rotation = this.getRotation(x, y);\n          shapes.push(this.createTile(rotation, x, y));\n        }\n      }\n      shapes.push('</g>');\n      return shapes.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TruchetPattern, \"parameters\", {\n  gridSize: {\n    min: 2,\n    max: 4,\n    \"default\": 2\n  },\n  tileSize: {\n    min: 25,\n    max: 59,\n    \"default\": 50\n  },\n  flowIntensity: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  patternBalance: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  contrast: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TruchetPattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TruchetPattern.js?");

/***/ }),

/***/ "./src/shapes/TwistedStems.js":
/*!************************************!*\
  !*** ./src/shapes/TwistedStems.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar TwistedStems = /*#__PURE__*/function (_Shape) {\n  function TwistedStems() {\n    _classCallCheck(this, TwistedStems);\n    return _callSuper(this, TwistedStems, arguments);\n  }\n  _inherits(TwistedStems, _Shape);\n  return _createClass(TwistedStems, [{\n    key: \"drawBranch\",\n    value: function drawBranch(start, angle, length, depth, pathParts) {\n      // Calculate end point\n      var end = {\n        x: start.x + length * Math.cos(angle),\n        y: start.y + length * Math.sin(angle)\n      };\n\n      // Calculate control point with scaled curvature\n      var curveScale = Math.min(0.5, (this.curvature - 60) / 120); // Scale curvature effect\n      var curveOffset = length * curveScale;\n      var control = {\n        x: start.x + length * 0.5 * Math.cos(angle) - curveOffset * Math.sin(angle),\n        y: start.y + length * 0.5 * Math.sin(angle) + curveOffset * Math.cos(angle)\n      };\n\n      // Add current branch\n      pathParts.push(\"M \".concat(start.x, \" \").concat(start.y));\n      pathParts.push(\"Q \".concat(control.x, \" \").concat(control.y, \", \").concat(end.x, \" \").concat(end.y));\n\n      // Recursively draw sub-branches if we haven't reached max depth\n      if (depth > 1) {\n        var subLength = length * 0.6; // Reduce length for sub-branches\n        var spreadAngle = Math.PI / 6; // 30 degrees spread\n\n        // Draw left sub-branch\n        this.drawBranch(end, angle - spreadAngle, subLength, depth - 1, pathParts);\n\n        // Draw right sub-branch\n        this.drawBranch(end, angle + spreadAngle, subLength, depth - 1, pathParts);\n      }\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Scale factors to fit within viewBox\n      var scale = 200 / (this.spread * (this.depth + 1));\n      var baseLength = this.spread * scale;\n      var pathParts = [];\n\n      // Calculate angle step for main branches\n      var branches = Math.round(this.branches);\n      var angleStep = 2 * Math.PI / branches;\n\n      // Start point at center\n      var center = {\n        x: 0,\n        y: 0\n      };\n\n      // Draw each main branch\n      for (var i = 0; i < branches; i++) {\n        var angle = i * angleStep;\n        this.drawBranch(center, angle, baseLength, Math.round(this.depth), pathParts);\n      }\n      return \"<path \\n            d=\\\"\".concat(pathParts.join(' '), \"\\\"\\n            fill=\\\"none\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(TwistedStems, \"parameters\", {\n  branches: {\n    min: 4,\n    max: 8,\n    \"default\": 6\n  },\n  depth: {\n    min: 2,\n    max: 6,\n    \"default\": 3\n  },\n  spread: {\n    min: 30,\n    max: 100,\n    \"default\": 60\n  },\n  curvature: {\n    min: 60,\n    max: 120,\n    \"default\": 60\n  },\n  thickness: {\n    min: 1,\n    max: 6,\n    \"default\": 3\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TwistedStems);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/TwistedStems.js?");

/***/ }),

/***/ "./src/shapes/Vase.js":
/*!****************************!*\
  !*** ./src/shapes/Vase.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar VaseShape = /*#__PURE__*/function (_Shape) {\n  function VaseShape() {\n    _classCallCheck(this, VaseShape);\n    return _callSuper(this, VaseShape, arguments);\n  }\n  _inherits(VaseShape, _Shape);\n  return _createClass(VaseShape, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = [];\n      var phaseRad = this.phase * Math.PI / 180;\n      var steps = this.segments * 2 + 1;\n\n      // Generate right side points\n      for (var i = 0; i < steps; i++) {\n        var t = i / (steps - 1);\n        var y = (t - 0.5) * this.height;\n\n        // Calculate waist modulation effect\n        var waistPos = this.waistPos / 100;\n        var waistModIntensity = this.waistMod / 100;\n        var waistEffect = Math.exp(-Math.pow((t - waistPos) * 4, 2)) * waistModIntensity;\n\n        // Apply base width with waist narrowing\n        var baseWidth = this.width * (1 - waistEffect * 0.7);\n\n        // Calculate side modulation\n        var modAmt = this.modulation / 100 * this.width * 0.3;\n        var mod = Math.sin(t * Math.PI * this.segments * 2 + phaseRad) * modAmt;\n        var x = baseWidth + mod;\n        points.push([x, y]);\n      }\n\n      // Create SVG path\n      var roundingRadius = this.rounding / 100 * 30;\n      if (roundingRadius > 0) {\n        var pathData = '';\n\n        // Helper functions\n        var distance = function distance(p1, p2) {\n          var dx = p2[0] - p1[0];\n          var dy = p2[1] - p1[1];\n          return Math.sqrt(dx * dx + dy * dy);\n        };\n        var getDirection = function getDirection(p1, p2) {\n          var dx = p2[0] - p1[0];\n          var dy = p2[1] - p1[1];\n          var len = Math.sqrt(dx * dx + dy * dy);\n          return [dx / len, dy / len];\n        };\n\n        // Generate right side path\n        pathData = \"M \".concat(points[0][0], \",\").concat(points[0][1]);\n        for (var _i = 1; _i < points.length - 1; _i++) {\n          var prev = points[_i - 1];\n          var curr = points[_i];\n          var next = points[_i + 1];\n          var d1 = distance(prev, curr);\n          var d2 = distance(curr, next);\n          var radius = Math.min(roundingRadius, d1 * 0.49, d2 * 0.49);\n          var _getDirection = getDirection(prev, curr),\n            _getDirection2 = _slicedToArray(_getDirection, 2),\n            dir1x = _getDirection2[0],\n            dir1y = _getDirection2[1];\n          var _getDirection3 = getDirection(curr, next),\n            _getDirection4 = _slicedToArray(_getDirection3, 2),\n            dir2x = _getDirection4[0],\n            dir2y = _getDirection4[1];\n          var p1x = curr[0] - dir1x * radius;\n          var p1y = curr[1] - dir1y * radius;\n          var p2x = curr[0] + dir2x * radius;\n          var p2y = curr[1] + dir2y * radius;\n          pathData += \" L \".concat(p1x, \",\").concat(p1y, \" Q \").concat(curr[0], \",\").concat(curr[1], \" \").concat(p2x, \",\").concat(p2y);\n        }\n\n        // Add final line to last point\n        pathData += \" L \".concat(points[points.length - 1][0], \",\").concat(points[points.length - 1][1]);\n\n        // Generate left side path (mirrored)\n        pathData += \" L \".concat(-points[points.length - 1][0], \",\").concat(points[points.length - 1][1]);\n        for (var _i2 = points.length - 2; _i2 > 0; _i2--) {\n          var _next = points[_i2 - 1];\n          var _curr = points[_i2];\n          var _prev = points[_i2 + 1];\n          var _d = distance(_prev, _curr);\n          var _d2 = distance(_curr, _next);\n          var _radius = Math.min(roundingRadius, _d * 0.49, _d2 * 0.49);\n          var _getDirection5 = getDirection(_prev, _curr),\n            _getDirection6 = _slicedToArray(_getDirection5, 2),\n            _dir1x = _getDirection6[0],\n            _dir1y = _getDirection6[1];\n          var _getDirection7 = getDirection(_curr, _next),\n            _getDirection8 = _slicedToArray(_getDirection7, 2),\n            _dir2x = _getDirection8[0],\n            _dir2y = _getDirection8[1];\n          var _p1x = -(_curr[0] - _dir1x * _radius);\n          var _p1y = _curr[1] - _dir1y * _radius;\n          var _p2x = -(_curr[0] + _dir2x * _radius);\n          var _p2y = _curr[1] + _dir2y * _radius;\n          pathData += \" L \".concat(_p1x, \",\").concat(_p1y, \" Q \").concat(-_curr[0], \",\").concat(_curr[1], \" \").concat(_p2x, \",\").concat(_p2y);\n        }\n\n        // Close the path\n        pathData += \" L \".concat(-points[0][0], \",\").concat(points[0][1], \" Z\");\n        return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\");\n      } else {\n        // Simple polygonal path without rounding\n        var _pathData = \"M \".concat(points[0][0], \",\").concat(points[0][1]);\n        for (var _i3 = 1; _i3 < points.length; _i3++) {\n          _pathData += \" L \".concat(points[_i3][0], \",\").concat(points[_i3][1]);\n        }\n        for (var _i4 = points.length - 1; _i4 >= 0; _i4--) {\n          _pathData += \" L \".concat(-points[_i4][0], \",\").concat(points[_i4][1]);\n        }\n        _pathData += ' Z';\n        return \"<g transform=\\\"scale(\".concat(this.scale, \")\\\">\\n        <path d=\\\"\").concat(_pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\"/>\\n    </g>\");\n      }\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(VaseShape, \"parameters\", {\n  segments: {\n    min: 2,\n    max: 8,\n    \"default\": 4\n  },\n  height: {\n    min: 100,\n    max: 200,\n    \"default\": 120\n  },\n  width: {\n    min: 20,\n    max: 100,\n    \"default\": 42\n  },\n  modulation: {\n    min: 10,\n    max: 100,\n    \"default\": 82\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 90\n  },\n  rounding: {\n    min: 0,\n    max: 100,\n    \"default\": 100\n  },\n  waistMod: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  },\n  waistPos: {\n    min: 0,\n    max: 100,\n    \"default\": 50\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VaseShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Vase.js?");

/***/ }),

/***/ "./src/shapes/VoronoiShape.js":
/*!************************************!*\
  !*** ./src/shapes/VoronoiShape.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar VoronoiShape = /*#__PURE__*/function (_Shape) {\n  function VoronoiShape() {\n    _classCallCheck(this, VoronoiShape);\n    return _callSuper(this, VoronoiShape, arguments);\n  }\n  _inherits(VoronoiShape, _Shape);\n  return _createClass(VoronoiShape, [{\n    key: \"generatePoints\",\n    value: function generatePoints() {\n      this.resetRNG();\n      var points = [];\n      points.push([0, 0]);\n      var boundaryPointCount = Math.max(12, Math.floor(this.pointCount / 3));\n      for (var i = 0; i < boundaryPointCount; i++) {\n        var angle = i * 2 * Math.PI / boundaryPointCount;\n        var r = this.radius * 0.95;\n        points.push([r * Math.cos(angle), r * Math.sin(angle)]);\n      }\n      var minDist = this.radius * 0.5 / Math.sqrt(this.pointCount);\n      var attempts = 0;\n      var maxAttempts = this.pointCount * 20;\n      while (points.length < this.pointCount + boundaryPointCount && attempts < maxAttempts) {\n        attempts++;\n        var _angle = this.random() * Math.PI * 2;\n        var _r = this.radius * 0.9 * Math.sqrt(this.random());\n        var x = _r * Math.cos(_angle);\n        var y = _r * Math.sin(_angle);\n        var distFromCenter = Math.hypot(x, y);\n        var jitterScale = 1 - distFromCenter / this.radius;\n        var scaledJitter = this.jitter * jitterScale;\n        if (scaledJitter > 0) {\n          var jitterAngle = this.random() * Math.PI * 2;\n          var jitterAmount = this.random() * scaledJitter;\n          x += jitterAmount * Math.cos(jitterAngle);\n          y += jitterAmount * Math.sin(jitterAngle);\n        }\n        var tooClose = false;\n        var _iterator = _createForOfIteratorHelper(points),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var point = _step.value;\n            var dist = Math.hypot(x - point[0], y - point[1]);\n            if (dist < minDist) {\n              tooClose = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (!tooClose && Math.hypot(x, y) <= this.radius * 0.95) {\n          points.push([x, y]);\n        }\n      }\n      return points;\n    }\n  }, {\n    key: \"delaunayTriangulate\",\n    value: function delaunayTriangulate(points) {\n      var circumcircle = function circumcircle(a, b, c) {\n        var ax = a[0],\n          ay = a[1];\n        var bx = b[0],\n          by = b[1];\n        var cx = c[0],\n          cy = c[1];\n        var d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));\n        if (Math.abs(d) < 1e-10) return {\n          x: 0,\n          y: 0,\n          radius: Infinity\n        };\n        var aSq = ax * ax + ay * ay;\n        var bSq = bx * bx + by * by;\n        var cSq = cx * cx + cy * cy;\n        var x = (aSq * (by - cy) + bSq * (cy - ay) + cSq * (ay - by)) / d;\n        var y = (aSq * (cx - bx) + bSq * (ax - cx) + cSq * (bx - ax)) / d;\n        var radius = Math.hypot(x - ax, y - ay);\n        return {\n          x: x,\n          y: y,\n          radius: radius\n        };\n      };\n      var inCircumcircle = function inCircumcircle(point, triangle, circle) {\n        return Math.hypot(point[0] - circle.x, point[1] - circle.y) < circle.radius;\n      };\n      var maxRadius = this.radius * 2;\n      var superTriangle = [[-maxRadius, -maxRadius], [0, maxRadius * 2], [maxRadius * 2, -maxRadius]];\n      var triangles = [{\n        vertices: [0, 1, 2],\n        points: superTriangle\n      }];\n      var _loop = function _loop() {\n        var point = points[i];\n        var edges = [];\n        triangles = triangles.filter(function (triangle) {\n          var circle = circumcircle(triangle.points[0], triangle.points[1], triangle.points[2]);\n          var contained = inCircumcircle(point, triangle, circle);\n          if (contained) {\n            edges.push([triangle.vertices[0], triangle.vertices[1]]);\n            edges.push([triangle.vertices[1], triangle.vertices[2]]);\n            edges.push([triangle.vertices[2], triangle.vertices[0]]);\n          }\n          return !contained;\n        });\n        var uniqueEdges = [];\n        for (var _i = 0, _edges = edges; _i < _edges.length; _i++) {\n          var edge = _edges[_i];\n          var isUnique = true;\n          var _iterator2 = _createForOfIteratorHelper(edges),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var otherEdge = _step2.value;\n              if (edge !== otherEdge) {\n                if (edge[0] === otherEdge[1] && edge[1] === otherEdge[0] || edge[0] === otherEdge[0] && edge[1] === otherEdge[1]) {\n                  isUnique = false;\n                  break;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          if (isUnique) {\n            uniqueEdges.push(edge);\n          }\n        }\n        for (var _i2 = 0, _uniqueEdges = uniqueEdges; _i2 < _uniqueEdges.length; _i2++) {\n          var _edge = _uniqueEdges[_i2];\n          triangles.push({\n            vertices: [_edge[0], _edge[1], i + 3],\n            points: [_edge[0] < 3 ? superTriangle[_edge[0]] : points[_edge[0] - 3], _edge[1] < 3 ? superTriangle[_edge[1]] : points[_edge[1] - 3], point]\n          });\n        }\n      };\n      for (var i = 0; i < points.length; i++) {\n        _loop();\n      }\n      triangles = triangles.filter(function (triangle) {\n        return !(triangle.vertices[0] < 3 || triangle.vertices[1] < 3 || triangle.vertices[2] < 3);\n      });\n      return triangles.map(function (t) {\n        return {\n          indices: t.vertices.map(function (v) {\n            return v - 3;\n          }),\n          points: t.points\n        };\n      });\n    }\n  }, {\n    key: \"computeVoronoiCells\",\n    value: function computeVoronoiCells(points, triangles) {\n      var _this = this;\n      var cells = new Array(points.length).fill(0).map(function () {\n        return [];\n      });\n      triangles.forEach(function (triangle) {\n        var indices = triangle.indices,\n          triPoints = triangle.points;\n        var _triPoints = _slicedToArray(triPoints, 3),\n          a = _triPoints[0],\n          b = _triPoints[1],\n          c = _triPoints[2];\n        var d = 2 * (a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1]));\n        if (Math.abs(d) < 1e-10) return;\n        var aSq = a[0] * a[0] + a[1] * a[1];\n        var bSq = b[0] * b[0] + b[1] * b[1];\n        var cSq = c[0] * c[0] + c[1] * c[1];\n        var circumcenterX = (aSq * (b[1] - c[1]) + bSq * (c[1] - a[1]) + cSq * (a[1] - b[1])) / d;\n        var circumcenterY = (aSq * (c[0] - b[0]) + bSq * (a[0] - c[0]) + cSq * (b[0] - a[0])) / d;\n        var voronoiVertex = [circumcenterX, circumcenterY];\n        indices.forEach(function (index) {\n          if (index >= 0 && index < points.length) {\n            cells[index].push(voronoiVertex);\n          }\n        });\n      });\n      return cells.map(function (vertices, i) {\n        if (vertices.length < 3) return null;\n        var center = points[i];\n        var sortedVertices = vertices.sort(function (a, b) {\n          var angleA = Math.atan2(a[1] - center[1], a[0] - center[0]);\n          var angleB = Math.atan2(b[1] - center[1], b[0] - center[0]);\n          return angleA - angleB;\n        });\n        return _this.clipCellToCircle(sortedVertices, center);\n      }).filter(function (cell) {\n        return cell !== null;\n      });\n    }\n  }, {\n    key: \"clipCellToCircle\",\n    value: function clipCellToCircle(vertices, center) {\n      if (vertices.length < 3) return null;\n      var result = [];\n      var r = this.radius;\n      var _loop2 = function _loop2() {\n        var current = vertices[i];\n        var next = vertices[(i + 1) % vertices.length];\n        if (Math.hypot(current[0], current[1]) <= r) {\n          result.push(current);\n        }\n        var dx = next[0] - current[0];\n        var dy = next[1] - current[1];\n        var a = dx * dx + dy * dy;\n        var b = 2 * (dx * current[0] + dy * current[1]);\n        var c = current[0] * current[0] + current[1] * current[1] - r * r;\n        var discriminant = b * b - 4 * a * c;\n        if (discriminant >= 0) {\n          var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n          var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n          [t1, t2].forEach(function (t) {\n            if (t >= 0 && t <= 1) {\n              var intersectX = current[0] + t * dx;\n              var intersectY = current[1] + t * dy;\n              result.push([intersectX, intersectY]);\n            }\n          });\n        }\n      };\n      for (var i = 0; i < vertices.length; i++) {\n        _loop2();\n      }\n      return result.length >= 3 ? result : null;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this2 = this;\n      var points = this.generatePoints();\n      var triangles = this.delaunayTriangulate(points);\n      var cells = this.computeVoronoiCells(points, triangles);\n      var svgContent = \"<circle \\n            cx=\\\"0\\\" \\n            cy=\\\"0\\\" \\n            r=\\\"\".concat(this.radius, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.borderThickness, \"\\\"\\n            fill=\\\"none\\\"\\n        />\");\n      cells.forEach(function (cell) {\n        if (cell && cell.length >= 3) {\n          var pathData = \"M \".concat(cell[0][0], \" \").concat(cell[0][1]);\n          for (var i = 1; i < cell.length; i++) {\n            pathData += \" L \".concat(cell[i][0], \" \").concat(cell[i][1]);\n          }\n          pathData += ' Z';\n          svgContent += \"<path \\n                    d=\\\"\".concat(pathData, \"\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(_this2.cellLineThickness, \"\\\"\\n                    fill=\\\"none\\\"\\n                />\");\n        }\n      });\n      return svgContent;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(VoronoiShape, \"parameters\", {\n  radius: {\n    min: 50,\n    max: 150,\n    \"default\": 100\n  },\n  pointCount: {\n    min: 5,\n    max: 100,\n    \"default\": 30\n  },\n  borderThickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  cellLineThickness: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  },\n  jitter: {\n    min: 0,\n    max: 30,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VoronoiShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/VoronoiShape.js?");

/***/ }),

/***/ "./src/shapes/Wave.js":
/*!****************************!*\
  !*** ./src/shapes/Wave.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar WaveShape = /*#__PURE__*/function (_Shape) {\n  function WaveShape() {\n    _classCallCheck(this, WaveShape);\n    return _callSuper(this, WaveShape, arguments);\n  }\n  _inherits(WaveShape, _Shape);\n  return _createClass(WaveShape, [{\n    key: \"getControlPoints\",\n    value: function getControlPoints(x1, y1, x2, y2, smoothing) {\n      var dx = x2 - x1;\n      var tension = 1 - Math.max(0.1, Math.min(0.9, smoothing));\n      return {\n        cp1x: x1 + dx * tension,\n        cp1y: y1,\n        cp2x: x2 - dx * tension,\n        cp2y: y2\n      };\n    }\n  }, {\n    key: \"generateWavePoints\",\n    value: function generateWavePoints() {\n      var width = 160; // Increased width for better visibility\n      var segments = this.frequency * 2; // 2 points per wave cycle\n      var points = [];\n      var phaseRad = this.phase * Math.PI / 180;\n      for (var i = 0; i <= segments; i++) {\n        var t = i / segments;\n        var x = -width / 2 + width * t;\n        var y = 0;\n        y = Math.sin(t * Math.PI * 2 * this.frequency + phaseRad);\n        points.push([x, y * this.amplitude]);\n      }\n      return points;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var points = this.generateWavePoints();\n      var d = \"M \".concat(points[0][0], \" \").concat(points[0][1]);\n      for (var i = 1; i < points.length; i++) {\n        var curr = points[i];\n        var prev = points[i - 1];\n        var cp = this.getControlPoints(prev[0], prev[1], curr[0], curr[1], this.waveType === 'square' ? 0.1 : this.smoothness);\n        d += \" C \".concat(cp.cp1x, \" \").concat(cp.cp1y, \" \").concat(cp.cp2x, \" \").concat(cp.cp2y, \" \").concat(curr[0], \" \").concat(curr[1]);\n      }\n      return \"<path \\n            d=\\\"\".concat(d, \"\\\"\\n            stroke=\\\"white\\\"\\n            stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n            fill=\\\"none\\\"\\n            stroke-linecap=\\\"round\\\"\\n            stroke-linejoin=\\\"round\\\"\\n        />\");\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WaveShape, \"parameters\", {\n  amplitude: {\n    min: 10,\n    max: 150,\n    \"default\": 72\n  },\n  frequency: {\n    min: 1,\n    max: 8,\n    \"default\": 3\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 30\n  },\n  thickness: {\n    min: 1,\n    max: 16,\n    \"default\": 6\n  },\n  smoothness: {\n    min: 0.1,\n    max: 1,\n    \"default\": 0.1\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WaveShape);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/Wave.js?");

/***/ }),

/***/ "./src/shapes/WaveField.js":
/*!*********************************!*\
  !*** ./src/shapes/WaveField.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar WaveField = /*#__PURE__*/function (_Shape) {\n  function WaveField() {\n    _classCallCheck(this, WaveField);\n    return _callSuper(this, WaveField, arguments);\n  }\n  _inherits(WaveField, _Shape);\n  return _createClass(WaveField, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Convert parameters to proper scales and units\n      var waves = Math.round(this.waves);\n      var phase = this.phase * (Math.PI / 180); // Convert degrees to radians\n      var scale = 0.8; // Scale factor for the viewBox size\n      var spacing = this.layerSpacing * scale;\n\n      // Calculate safe bounds for the wave field\n      var padding = this.thickness * 2;\n      var width = 200 - padding * 2; // Based on viewBox size\n      var height = 200 - padding * 2;\n      var startX = -100 + padding;\n      var startY = -100 + padding;\n\n      // Calculate maximum safe amplitude to prevent out-of-bounds\n      var totalWaveHeight = (waves - 1) * spacing;\n      var maxAmplitude = (height - totalWaveHeight) / 2;\n      var amplitude = Math.min(this.amplitude * scale, maxAmplitude);\n\n      // Calculate vertical center position\n      var centerY = 0; // Center of viewBox\n      var waveStartY = centerY - totalWaveHeight / 2;\n      var steps = 60;\n      var lines = [];\n\n      // Generate each wave\n      for (var wave = 0; wave < waves; wave++) {\n        var wavePhase = phase + wave * Math.PI / 2;\n        var baseY = waveStartY + wave * spacing;\n        var points = [];\n\n        // Calculate points for this wave\n        for (var step = 0; step <= steps; step++) {\n          var progress = step / steps;\n          var x = startX + width * progress;\n          var y = baseY;\n          if (this.frequency > 0) {\n            // Standard sine wave\n            y += amplitude * Math.sin(2 * Math.PI * this.frequency * progress + wavePhase);\n          } else {\n            // Special case for frequency = 0: gentle slope\n            var slope = Math.sin(wavePhase);\n            var normalizedProgress = 2 * progress - 1; // -1 to 1\n            y += amplitude * slope * (1 - normalizedProgress * normalizedProgress);\n          }\n\n          // Ensure point stays within bounds\n          y = Math.max(startY, Math.min(y, startY + height));\n          points.push(\"\".concat(x, \",\").concat(y));\n        }\n\n        // Create polyline for this wave\n        if (points.length > 0) {\n          lines.push(\"<polyline \\n                    points=\\\"\".concat(points.join(' '), \"\\\"\\n                    fill=\\\"none\\\"\\n                    stroke=\\\"white\\\"\\n                    stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                    stroke-linecap=\\\"round\\\"\\n                    stroke-linejoin=\\\"round\\\"\\n                />\"));\n        }\n      }\n      return lines.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WaveField, \"parameters\", {\n  waves: {\n    min: 3,\n    max: 6,\n    \"default\": 4\n  },\n  amplitude: {\n    min: 25,\n    max: 85,\n    \"default\": 40\n  },\n  frequency: {\n    min: 1,\n    max: 4,\n    \"default\": 2\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  thickness: {\n    min: 1,\n    max: 10,\n    \"default\": 2\n  },\n  layerSpacing: {\n    min: 10,\n    max: 50,\n    \"default\": 20\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WaveField);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WaveField.js?");

/***/ }),

/***/ "./src/shapes/WaveFlower.js":
/*!**********************************!*\
  !*** ./src/shapes/WaveFlower.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar WaveFlower = /*#__PURE__*/function (_Shape) {\n  function WaveFlower() {\n    _classCallCheck(this, WaveFlower);\n    return _callSuper(this, WaveFlower, arguments);\n  }\n  _inherits(WaveFlower, _Shape);\n  return _createClass(WaveFlower, [{\n    key: \"getRadius\",\n    value: function getRadius(angle, baseRadius, waveFreq, phase, amplitude) {\n      // Convert phase to radians and calculate wave pattern\n      var wavePattern = Math.cos(angle * waveFreq + phase * Math.PI / 180);\n      return baseRadius + amplitude * wavePattern;\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      // Scale parameters to fit within viewBox (-200 -200 400 400)\n      var scale = 0.8; // Scale to fit viewBox\n      var maxRadius = 100 - this.thickness * scale;\n\n      // Scale the parameters\n      var baseRadius = this.radius * scale * 0.5;\n      var thickness = this.thickness * scale;\n      var spacing = this.spacing * scale * 0.5;\n      var waveAmplitude = this.waveAmplitude * scale * 0.5;\n      var paths = [];\n\n      // Generate each ring\n      for (var i = 0; i < this.ringCount; i++) {\n        var ringProgress = i / Math.max(1, this.ringCount - 1);\n        var computedRingRadius = baseRadius + spacing * i;\n        var ringRadius = Math.min(computedRingRadius, maxRadius - waveAmplitude);\n\n        // Generate points for the ring\n        var numPoints = 360; // High resolution for smooth curves\n        var angleStep = 2 * Math.PI / numPoints;\n        var ringPoints = [];\n        for (var p = 0; p <= numPoints; p++) {\n          var angle = p * angleStep;\n          var currentRadius = this.getRadius(angle, ringRadius, this.waveFrequency, this.phase + ringProgress * 180, waveAmplitude);\n          var x = currentRadius * Math.cos(angle);\n          var y = currentRadius * Math.sin(angle);\n          if (p === 0) {\n            ringPoints.push(\"M \".concat(x, \" \").concat(y));\n          } else {\n            ringPoints.push(\"L \".concat(x, \" \").concat(y));\n          }\n        }\n\n        // Close the path\n        ringPoints.push('Z');\n\n        // Add the ring to our collection\n        paths.push(\"<path \\n                d=\\\"\".concat(ringPoints.join(' '), \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(thickness, \"\\\"\\n                stroke-linecap=\\\"round\\\"\\n                stroke-linejoin=\\\"round\\\"\\n            />\"));\n      }\n\n      // Return all paths as a single string\n      return paths.join('\\n');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WaveFlower, \"parameters\", {\n  ringCount: {\n    min: 4,\n    max: 12,\n    \"default\": 6\n  },\n  radius: {\n    min: 50,\n    max: 150,\n    \"default\": 40\n  },\n  thickness: {\n    min: 1,\n    max: 8,\n    \"default\": 5\n  },\n  spacing: {\n    min: 10,\n    max: 50,\n    \"default\": 30\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 45\n  },\n  waveAmplitude: {\n    min: 0,\n    max: 50,\n    \"default\": 20\n  },\n  waveFrequency: {\n    min: 5,\n    max: 10,\n    \"default\": 6\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WaveFlower);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WaveFlower.js?");

/***/ }),

/***/ "./src/shapes/WaveFrame.js":
/*!*********************************!*\
  !*** ./src/shapes/WaveFrame.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar WaveFrame = /*#__PURE__*/function (_Shape) {\n  function WaveFrame() {\n    _classCallCheck(this, WaveFrame);\n    return _callSuper(this, WaveFrame, arguments);\n  }\n  _inherits(WaveFrame, _Shape);\n  return _createClass(WaveFrame, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      this.sides = Math.round(this.sides);\n      this.phaseRad = this.phase * Math.PI / 180;\n      this.freq2Pi = this.frequency * 2 * Math.PI;\n      this.startPhase = Math.PI / 2;\n\n      // Limit maximum curve complexity\n      var maxCurves = Math.min(this.frequency * 2, 12);\n      var curvesPerEdge = Math.max(4, maxCurves);\n\n      // Pre-calculate sine and cosine values for vertices\n      var angleStep = 2 * Math.PI / this.sides;\n      var radius = this.size / 2;\n\n      // Generate vertices\n      var vertices = [];\n      for (var i = 0; i <= this.sides; i++) {\n        var angle = i % this.sides * angleStep;\n        var x = radius * Math.cos(angle);\n        var y = radius * Math.sin(angle);\n        vertices.push([x, y]);\n      }\n\n      // Build path\n      var path = '';\n      for (var _i = 0; _i < this.sides; _i++) {\n        // Make sure both vertices exist before calling generateWaveEdge\n        if (vertices[_i] && vertices[_i + 1]) {\n          path += this.generateWaveEdge(vertices[_i], vertices[_i + 1], curvesPerEdge);\n        }\n      }\n      return \"<path d=\\\"\".concat(path, \" Z\\\" fill=\\\"white\\\"/>\");\n    }\n  }, {\n    key: \"generateWaveEdge\",\n    value: function generateWaveEdge(start, end, curveCount) {\n      var _this = this;\n      // Ensure we have valid start and end points\n      if (!start || !end || !Array.isArray(start) || !Array.isArray(end) || start.length < 2 || end.length < 2) {\n        return '';\n      }\n\n      // Pre-calculate edge vectors\n      var dx = end[0] - start[0];\n      var dy = end[1] - start[1];\n      var edgeLength = Math.sqrt(dx * dx + dy * dy);\n\n      // Early exit for very small edges\n      if (edgeLength < 1) return '';\n\n      // Cache normalized vectors\n      var invLength = 1 / edgeLength;\n      var normal = [-dy * invLength, dx * invLength];\n      var tangent = [dx * invLength, dy * invLength];\n\n      // Pre-calculate control point distance\n      var controlDist = edgeLength / curveCount * this.smoothness;\n      var path = '';\n\n      // Use a more efficient wave calculation\n      var calculateWavePoint = function calculateWavePoint(t) {\n        var waveT = _this.startPhase + t * _this.freq2Pi + _this.phaseRad;\n        var sinT = Math.sin(waveT);\n        var cosT = Math.cos(waveT);\n        var offset = sinT * _this.amplitude;\n        var derivative = cosT * _this.amplitude * _this.freq2Pi;\n\n        // Base point\n        var x = start[0] + dx * t;\n        var y = start[1] + dy * t;\n\n        // Offset point\n        var px = x + normal[0] * offset;\n        var py = y + normal[1] * offset;\n\n        // Tangent vector (optimized calculation)\n        var tx = tangent[0] - normal[0] * derivative * invLength;\n        var ty = tangent[1] - normal[1] * derivative * invLength;\n        return {\n          point: [px, py],\n          tangent: [tx, ty]\n        };\n      };\n\n      // Generate curve segments\n      for (var i = 0; i < curveCount; i++) {\n        var t0 = i / curveCount;\n        var t1 = (i + 1) / curveCount;\n        var p0 = calculateWavePoint(t0);\n        var p1 = calculateWavePoint(t1);\n\n        // Calculate control points\n        var cp1x = p0.point[0] + p0.tangent[0] * controlDist;\n        var cp1y = p0.point[1] + p0.tangent[1] * controlDist;\n        var cp2x = p1.point[0] - p1.tangent[0] * controlDist;\n        var cp2y = p1.point[1] - p1.tangent[1] * controlDist;\n        if (i === 0) {\n          path = \"M \".concat(p0.point[0], \",\").concat(p0.point[1]);\n        }\n        path += \" C \".concat(cp1x, \",\").concat(cp1y, \" \").concat(cp2x, \",\").concat(cp2y, \" \").concat(p1.point[0], \",\").concat(p1.point[1]);\n      }\n      return path;\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WaveFrame, \"parameters\", {\n  size: {\n    min: 50,\n    max: 150,\n    \"default\": 150\n  },\n  sides: {\n    min: 3,\n    max: 12,\n    \"default\": 6\n  },\n  amplitude: {\n    min: 1,\n    max: 50,\n    \"default\": 20\n  },\n  frequency: {\n    min: 1,\n    max: 20,\n    \"default\": 2\n  },\n  phase: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  smoothness: {\n    min: 0.1,\n    max: 1,\n    \"default\": 1.0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WaveFrame);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WaveFrame.js?");

/***/ }),

/***/ "./src/shapes/WavePattern.js":
/*!***********************************!*\
  !*** ./src/shapes/WavePattern.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar WavePattern = /*#__PURE__*/function (_Shape) {\n  function WavePattern() {\n    _classCallCheck(this, WavePattern);\n    return _callSuper(this, WavePattern, arguments);\n  }\n  _inherits(WavePattern, _Shape);\n  return _createClass(WavePattern, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var waves = [];\n      var segmentHeight = this.segmentWidth; // Maintain 45-degree angles\n\n      // Calculate total dimensions\n      var totalWidth = this.columns * this.segmentWidth;\n      var totalHeight = (this.rows - 1) * this.rowSpacing;\n\n      // Center the pattern\n      var startX = -totalWidth / 2;\n      var startY = -totalHeight / 2;\n\n      // Generate each row\n      for (var row = 0; row < this.rows; row++) {\n        var y = startY + row * this.rowSpacing;\n        var points = [];\n\n        // Generate points based on column count\n        for (var i = 0; i <= this.columns; i++) {\n          var x = startX + i * this.segmentWidth;\n          var yOffset = i % 2 === 0 ? 0 : segmentHeight;\n          points.push(\"\".concat(x, \",\").concat(y + yOffset));\n        }\n        waves.push(\"<polyline \\n                points=\\\"\".concat(points.join(' '), \"\\\"\\n                fill=\\\"none\\\"\\n                stroke=\\\"white\\\"\\n                stroke-width=\\\"\").concat(this.thickness, \"\\\"\\n                stroke-linecap=\\\"square\\\"\\n                stroke-linejoin=\\\"miter\\\"\\n            />\"));\n      }\n      return waves.join('');\n    }\n  }]);\n}(_Shape__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WavePattern, \"parameters\", {\n  rows: {\n    min: 1,\n    max: 6,\n    \"default\": 4\n  },\n  columns: {\n    min: 2,\n    max: 8,\n    \"default\": 6\n  },\n  // Number of zigzag segments\n  segmentWidth: {\n    min: 20,\n    max: 60,\n    \"default\": 25\n  },\n  // Single segment width\n  thickness: {\n    min: 4,\n    max: 20,\n    \"default\": 10\n  },\n  rowSpacing: {\n    min: 20,\n    max: 80,\n    \"default\": 35\n  } // Vertical spacing between rows\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WavePattern);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WavePattern.js?");

/***/ }),

/***/ "./src/shapes/WavyLine.js":
/*!********************************!*\
  !*** ./src/shapes/WavyLine.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar WavyLine = /*#__PURE__*/function (_Shape) {\n  function WavyLine() {\n    _classCallCheck(this, WavyLine);\n    return _callSuper(this, WavyLine, arguments);\n  }\n  _inherits(WavyLine, _Shape);\n  return _createClass(WavyLine, [{\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      // Convert rotation values from degrees to radians\n      var rotX = this.rotationX * Math.PI / 180;\n      var rotY = this.rotationY * Math.PI / 180;\n      var rotZ = this.rotationZ * Math.PI / 180;\n\n      // Generate the two waves with extrusion\n      var path = this.generateExtrudedWave();\n\n      // Rotate all points for 3D effect\n      var rotatedPath = path.map(function (point) {\n        return _this.rotate3D(point.x, point.y, point.z, rotX, rotY, rotZ);\n      });\n\n      // Create SVG path from the rotated points\n      var pathData = this.pointsToSvgPath(rotatedPath);\n      return \"<path d=\\\"\".concat(pathData, \"\\\" fill=\\\"white\\\" stroke=\\\"none\\\" />\");\n    }\n  }, {\n    key: \"generateExtrudedWave\",\n    value: function generateExtrudedWave() {\n      var points = [];\n      var totalWidth = this.wavelength * this.segments;\n      var startX = -totalWidth / 2;\n      var endX = totalWidth / 2;\n\n      // Number of points for smooth curves - increase for better quality\n      var numPoints = Math.max(100, this.segments * 50);\n\n      // Front face (top wave)\n      for (var i = 0; i < numPoints; i++) {\n        var t = i / (numPoints - 1);\n        var x = startX + t * (endX - startX);\n        var y = Math.sin(t * Math.PI * this.segments) * this.amplitude;\n        var z = this.depth / 2; // Front face\n\n        points.push({\n          x: x,\n          y: y,\n          z: z\n        });\n      }\n\n      // Right side connection - add extra points for smooth connection\n      var rightFront = points[points.length - 1];\n      var rightBack = {\n        x: rightFront.x,\n        y: rightFront.y,\n        z: -this.depth / 2\n      };\n\n      // Add the corner point\n      points.push(rightBack);\n\n      // Back face (bottom wave) - in reverse order for proper path construction\n      for (var _i = numPoints - 1; _i >= 0; _i--) {\n        var _t = _i / (numPoints - 1);\n        var _x = startX + _t * (endX - startX);\n        var _y = Math.sin(_t * Math.PI * this.segments) * this.amplitude;\n        var _z = -this.depth / 2; // Back face\n\n        points.push({\n          x: _x,\n          y: _y,\n          z: _z\n        });\n      }\n\n      // Left side connection - add the final corner point to close the shape\n      var leftBack = points[points.length - 1];\n      var leftFront = {\n        x: leftBack.x,\n        y: leftBack.y,\n        z: this.depth / 2\n      };\n\n      // Add the corner point to complete the loop\n      points.push(leftFront);\n      return points;\n    }\n  }, {\n    key: \"pointsToSvgPath\",\n    value: function pointsToSvgPath(points) {\n      if (points.length < 3) return '';\n      var pathData = \"M \".concat(points[0].x, \",\").concat(points[0].y);\n\n      // Draw the entire shape using simple line segments for a clean look\n      for (var i = 1; i < points.length; i++) {\n        pathData += \" L \".concat(points[i].x, \",\").concat(points[i].y);\n      }\n\n      // Close the path\n      pathData += ' Z';\n      return pathData;\n    }\n  }, {\n    key: \"rotate3D\",\n    value: function rotate3D(x, y, z, rotX, rotY, rotZ) {\n      // Rotate around Z axis\n      var x1 = x * Math.cos(rotZ) - y * Math.sin(rotZ);\n      var y1 = x * Math.sin(rotZ) + y * Math.cos(rotZ);\n\n      // Rotate around X axis\n      var y2 = y1 * Math.cos(rotX) - z * Math.sin(rotX);\n      var z2 = y1 * Math.sin(rotX) + z * Math.cos(rotX);\n\n      // Rotate around Y axis\n      var x3 = x1 * Math.cos(rotY) + z2 * Math.sin(rotY);\n      var z3 = -x1 * Math.sin(rotY) + z2 * Math.cos(rotY);\n      return {\n        x: x3,\n        y: y2,\n        z: z3\n      };\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WavyLine, \"parameters\", {\n  wavelength: {\n    min: 50,\n    max: 100,\n    \"default\": 100\n  },\n  amplitude: {\n    min: 10,\n    max: 100,\n    \"default\": 80\n  },\n  segments: {\n    min: 1,\n    max: 5,\n    \"default\": 2\n  },\n  depth: {\n    min: 10,\n    max: 100,\n    \"default\": 60\n  },\n  rotationX: {\n    min: -180,\n    max: 180,\n    \"default\": -45\n  },\n  rotationY: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  },\n  rotationZ: {\n    min: -180,\n    max: 180,\n    \"default\": -90\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WavyLine);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WavyLine.js?");

/***/ }),

/***/ "./src/shapes/WavyLine3D.js":
/*!**********************************!*\
  !*** ./src/shapes/WavyLine3D.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape.js */ \"./src/shapes/Shape.js\");\n/* harmony import */ var _perlin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../perlin.js */ \"./src/perlin.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar WavyLine3D = /*#__PURE__*/function (_Shape) {\n  function WavyLine3D() {\n    _classCallCheck(this, WavyLine3D);\n    return _callSuper(this, WavyLine3D, arguments);\n  }\n  _inherits(WavyLine3D, _Shape);\n  return _createClass(WavyLine3D, [{\n    key: \"getNoise\",\n    value: function getNoise(x, y, z) {\n      return _perlin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].noise(x * this.noiseScale + this.seed, y * this.noiseScale + this.seed, z * this.noiseScale + this.seed);\n    }\n  }, {\n    key: \"generateShape\",\n    value: function generateShape() {\n      var _this = this;\n      var rotX = this.rotationX * Math.PI / 180;\n      var rotY = this.rotationY * Math.PI / 180;\n      var rotZ = this.rotationZ * Math.PI / 180;\n      var paths = [];\n      var center = {\n        x: 0,\n        y: 0,\n        z: 0\n      };\n      for (var l = 0; l < this.lines; l++) {\n        var lineRatio = l / (this.lines - 1);\n        var yOffset = (lineRatio - 0.5) * this.amplitude * 2;\n        var pathPoints = this.generateHorizontalPath(lineRatio, yOffset);\n        paths.push(pathPoints);\n      }\n      var rotatedPaths = paths.map(function (path) {\n        return path.map(function (point) {\n          return _objectSpread(_objectSpread({}, point), {}, {\n            rotated: _this.rotate3D(point.x - center.x, point.y - center.y, point.z - center.z, rotX, rotY, rotZ)\n          });\n        });\n      });\n      var pathsWithDepth = rotatedPaths.map(function (path) {\n        var avgZ = path.reduce(function (sum, p) {\n          return sum + p.rotated.z;\n        }, 0) / path.length;\n        return {\n          path: path,\n          avgZ: avgZ\n        };\n      });\n      pathsWithDepth.sort(function (a, b) {\n        return b.avgZ - a.avgZ;\n      });\n      var elements = [];\n      var _iterator = _createForOfIteratorHelper(pathsWithDepth),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var path = _step.value.path;\n          var pathData = this.pointsToSvgPath(path);\n\n          // Calculate line thickness based on z-depth instead of opacity\n          var avgZ = path.reduce(function (sum, p) {\n            return sum + p.rotated.z;\n          }, 0) / path.length;\n          var zFactor = (avgZ + 50) / 100;\n          var scaledThickness = (this.thickness * (0.5 + zFactor)).toFixed(2);\n          elements.push(\"<path\\n        d=\\\"\".concat(pathData, \"\\\"\\n        stroke=\\\"white\\\"\\n        stroke-width=\\\"\").concat(scaledThickness, \"\\\"\\n        fill=\\\"none\\\"\\n        stroke-linejoin=\\\"round\\\"\\n        stroke-linecap=\\\"round\\\"\\n      />\"));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return elements.join('');\n    }\n  }, {\n    key: \"generateHorizontalPath\",\n    value: function generateHorizontalPath(lineRatio, yOffset) {\n      var points = [];\n      var totalWidth = this.wavelength * this.segments;\n      var startX = -totalWidth / 2;\n      var endX = totalWidth / 2;\n      var numPoints = this.segments * 16 + 1;\n      for (var i = 0; i < numPoints; i++) {\n        var t = i / (numPoints - 1);\n        var x = startX + t * (endX - startX);\n        var phase = lineRatio * 0.2;\n        var smoothT = t * t * (3 - 2 * t);\n        var baseY = Math.sin((smoothT + phase) * Math.PI * this.segments) * this.amplitude;\n        var noise = this.getNoise(smoothT * 3, lineRatio * 2, this.seed / 500) * this.noiseStrength;\n        var noiseInfluence = noise * (0.3 + 0.4 * Math.sin(lineRatio * Math.PI));\n        var zFactor = 0.8 - 0.4 * Math.abs(lineRatio - 0.5) * 2;\n        var zBase = Math.cos((smoothT + phase) * Math.PI * this.segments) * this.depth * 0.5 * zFactor;\n        var zNoise = this.getNoise(smoothT * 2, lineRatio * 1.5, this.seed / 400) * this.noiseStrength * 0.3;\n        var z = zBase + zNoise;\n        var xNoise = this.getNoise(smoothT * 2, lineRatio, this.seed / 300) * this.noiseStrength * 0.2;\n        var y = baseY + noiseInfluence + yOffset;\n        points.push({\n          x: x + xNoise,\n          y: y,\n          z: z\n        });\n      }\n      return points;\n    }\n  }, {\n    key: \"pointsToSvgPath\",\n    value: function pointsToSvgPath(points) {\n      if (points.length < 2) return '';\n      var pathData = \"M \".concat(points[0].rotated.x, \",\").concat(points[0].rotated.y);\n      if (points.length <= 3) {\n        for (var i = 0; i < points.length - 1; i++) {\n          var current = points[i].rotated;\n          var next = points[i + 1].rotated;\n          var dx = next.x - current.x;\n          var dy = next.y - current.y;\n          var ctrlFactor = this.curvature * 0.4;\n          var cp1x = current.x + dx * ctrlFactor;\n          var cp1y = current.y + dy * ctrlFactor;\n          var cp2x = next.x - dx * ctrlFactor;\n          var cp2y = next.y - dy * ctrlFactor;\n          pathData += \" C \".concat(cp1x, \",\").concat(cp1y, \" \").concat(cp2x, \",\").concat(cp2y, \" \").concat(next.x, \",\").concat(next.y);\n        }\n      } else {\n        for (var _i = 0; _i < points.length - 1; _i++) {\n          var p0 = points[Math.max(0, _i - 1)].rotated;\n          var p1 = points[_i].rotated;\n          var p2 = points[_i + 1].rotated;\n          var p3 = points[Math.min(points.length - 1, _i + 2)].rotated;\n          var tension = 1 - this.curvature * 0.8;\n          var _cp1x = p1.x + (p2.x - p0.x) / 6 * tension;\n          var _cp1y = p1.y + (p2.y - p0.y) / 6 * tension;\n          var _cp2x = p2.x - (p3.x - p1.x) / 6 * tension;\n          var _cp2y = p2.y - (p3.y - p1.y) / 6 * tension;\n          pathData += \" C \".concat(_cp1x, \",\").concat(_cp1y, \" \").concat(_cp2x, \",\").concat(_cp2y, \" \").concat(p2.x, \",\").concat(p2.y);\n        }\n      }\n      return pathData;\n    }\n  }, {\n    key: \"rotate3D\",\n    value: function rotate3D(x, y, z, rotX, rotY, rotZ) {\n      var x1 = x * Math.cos(rotZ) - y * Math.sin(rotZ);\n      var y1 = x * Math.sin(rotZ) + y * Math.cos(rotZ);\n      var y2 = y1 * Math.cos(rotX) - z * Math.sin(rotX);\n      var z2 = y1 * Math.sin(rotX) + z * Math.cos(rotX);\n      var x3 = x1 * Math.cos(rotY) + z2 * Math.sin(rotY);\n      var z3 = -x1 * Math.sin(rotY) + z2 * Math.cos(rotY);\n      return {\n        x: x3,\n        y: y2,\n        z: z3\n      };\n    }\n  }]);\n}(_Shape_js__WEBPACK_IMPORTED_MODULE_0__.Shape);\n_defineProperty(WavyLine3D, \"parameters\", {\n  thickness: {\n    min: 0.5,\n    max: 10,\n    \"default\": 1.5\n  },\n  wavelength: {\n    min: 50,\n    max: 200,\n    \"default\": 120\n  },\n  amplitude: {\n    min: 10,\n    max: 100,\n    \"default\": 50\n  },\n  segments: {\n    min: 3,\n    max: 12,\n    \"default\": 4\n  },\n  lines: {\n    min: 3,\n    max: 20,\n    \"default\": 12\n  },\n  depth: {\n    min: 10,\n    max: 100,\n    \"default\": 40\n  },\n  noiseScale: {\n    min: 0.1,\n    max: 2,\n    \"default\": 0.6\n  },\n  noiseStrength: {\n    min: 0,\n    max: 100,\n    \"default\": 15\n  },\n  curvature: {\n    min: 0.1,\n    max: 1,\n    \"default\": 0.8\n  },\n  rotationX: {\n    min: -180,\n    max: 180,\n    \"default\": 20\n  },\n  rotationY: {\n    min: -180,\n    max: 180,\n    \"default\": 10\n  },\n  rotationZ: {\n    min: -180,\n    max: 180,\n    \"default\": 0\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WavyLine3D);\n\n//# sourceURL=webpack://generative-shapes/./src/shapes/WavyLine3D.js?");

/***/ }),

/***/ "./src/shapesRegistry.js":
/*!*******************************!*\
  !*** ./src/shapesRegistry.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar shapeModules = __webpack_require__(\"./src/shapes sync ^\\\\.\\\\/(?%21Shape).*\\\\.js$\");\nvar shapeRegistry = {};\nshapeModules.keys().forEach(function (key) {\n  var module = shapeModules(key);\n  var ShapeClass = module[\"default\"] || Object.values(module)[0];\n  if (ShapeClass && ShapeClass.name) {\n    shapeRegistry[ShapeClass.name] = ShapeClass;\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shapeRegistry);\n\n//# sourceURL=webpack://generative-shapes/./src/shapesRegistry.js?");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://generative-shapes/./src/styles.css?");

/***/ }),

/***/ "data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%23999%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%23999%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = \"data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27%23999%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e\";\n\n//# sourceURL=webpack://generative-shapes/data:image/svg+xml;charset=UTF-8,%253csvg_xmlns=%2527http://www.w3.org/2000/svg%2527_viewBox=%25270_0_24_24%2527_fill=%2527none%2527_stroke=%2527%2523999%2527_stroke-width=%25272%2527_stroke-linecap=%2527round%2527_stroke-linejoin=%2527round%2527%253e%253cpolyline_points=%25276_9_12_15_18_9%2527%253e%253c/polyline%253e%253c/svg%253e?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;
